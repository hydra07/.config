(self["webpackChunkbrowser_extension"] = self["webpackChunkbrowser_extension"] || []).push([[136],{

/***/ 16267:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// EXTERNAL MODULE: ./Extension/src/common/log.js
var log = __webpack_require__(9224);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.includes.js
var es_array_includes = __webpack_require__(90943);
// EXTERNAL MODULE: ./node_modules/@adguard/tsurlfilter/dist/es/index.js
var es = __webpack_require__(6530);
// EXTERNAL MODULE: ./Extension/src/background/utils/request-types.js
var request_types = __webpack_require__(83485);
// EXTERNAL MODULE: ./Extension/src/common/strings.js
var strings = __webpack_require__(39100);
;// CONCATENATED MODULE: ./Extension/src/background/utils/dates.js
/**
 * Util class for dates
 */
const dates = function () {
  const DateUtils = {
    isSameHour(a, b) {
      return this.isSameDay(a, b) && a.getHours() === b.getHours();
    },

    isSameDay(a, b) {
      return this.isSameMonth(a, b) && a.getDate() === b.getDate();
    },

    isSameMonth(a, b) {
      if (!a || !b) {
        return false;
      }

      return a.getYear() === b.getYear() && a.getMonth() === b.getMonth();
    },

    getDifferenceInHours(a, b) {
      return (a.getTime() - b.getTime()) / 1000 / 60 / 60;
    },

    getDifferenceInDays(a, b) {
      return this.getDifferenceInHours(a, b) / 24;
    },

    getDifferenceInMonths(a, b) {
      return this.getDifferenceInDays(a, b) / 30;
    }

  };
  return DateUtils;
}();
;// CONCATENATED MODULE: ./Extension/src/background/utils/collections.js
/**
 * Util class for work with collections
 */
const collections = (() => {
  const CollectionUtils = {
    remove(collection, element) {
      if (!element || !collection) {
        return;
      }

      const index = collection.indexOf(element);

      if (index >= 0) {
        collection.splice(index, 1);
      }
    },

    removeAll(collection, element) {
      if (!element || !collection) {
        return;
      }

      for (let i = collection.length - 1; i >= 0; i -= 1) {
        if (collection[i] === element) {
          collection.splice(i, 1);
        }
      }
    },

    /**
     * Removes elements from collection if predicate returns true
     * @param collection
     * @param predicate
     */
    removeBy(collection, predicate) {
      if (!predicate || !collection) {
        return;
      }

      for (let i = collection.length - 1; i >= 0; i -= 1) {
        if (predicate(collection[i])) {
          collection.splice(i, 1);
        }
      }
    },

    removeRule(collection, rule) {
      if (!rule || !collection) {
        return;
      }

      for (let i = collection.length - 1; i >= 0; i -= 1) {
        if (rule.getText() === collection[i].getText()) {
          collection.splice(i, 1);
        }
      }
    },

    removeDuplicates(arr) {
      if (!arr || arr.length === 1) {
        return arr;
      }

      return arr.filter((elem, pos) => arr.indexOf(elem) === pos);
    },

    getRulesText(collection) {
      const text = [];

      if (!collection) {
        return text;
      }

      for (let i = 0; i < collection.length; i += 1) {
        text.push(collection[i].getText());
      }

      return text;
    },

    /**
     * Find element in array by property
     * @param array
     * @param property
     * @param value
     * @returns {*}
     */
    find(array, property, value) {
      if (typeof array.find === 'function') {
        return array.find(a => a[property] === value);
      }

      for (let i = 0; i < array.length; i += 1) {
        const elem = array[i];

        if (elem[property] === value) {
          return elem;
        }
      }

      return null;
    },

    /**
     * Checks if specified object is array
     * We don't use instanceof because it is too slow: http://jsperf.com/instanceof-performance/2
     * @param obj Object
     */
    isArray: Array.isArray || function (obj) {
      return `${obj}` === '[object Array]';
    },

    /**
     * Returns array elements of a, which is not included in b
     *
     * @param a
     * @param b
     */
    getArraySubtraction(a, b) {
      return a.filter(i => b.indexOf(i) < 0);
    }

  };
  return CollectionUtils;
})();
;// CONCATENATED MODULE: ./Extension/src/background/utils/concurrent.js
/* eslint-disable prefer-rest-params */

/**
 * Util class for support timeout, retry operations, debounce
 */
const concurrent = function () {
  const ConcurrentUtils = {
    runAsync(callback, context) {
      const params = Array.prototype.slice.call(arguments, 2);
      setTimeout(() => {
        callback.apply(context, params);
      }, 0);
    },

    retryUntil(predicate, main, details) {
      if (typeof details !== 'object') {
        details = {};
      }

      let now = 0;
      const next = details.next || 200;
      const until = details.until || 2000;

      const check = function () {
        if (predicate() === true || now >= until) {
          main();
          return;
        }

        now += next;
        setTimeout(check, next);
      };

      setTimeout(check, 1);
    },

    debounce(func, wait) {
      let timeout;
      return function () {
        const context = this;
        const args = arguments;

        const later = function () {
          timeout = null;
          func.apply(context, args);
        };

        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    },

    /**
     * Returns a new function that, when invoked, invokes `func` at most once per `wait` milliseconds.
     * https://github.com/component/throttle
     *
     * @param {Function} func Function to wrap.
     * @param {Number} wait Number of milliseconds that must elapse between `func` invocations.
     * @return {Function} A new function that wraps the `func` function passed in.
     */
    throttle(func, wait) {
      let ctx;
      let args;
      let rtn;
      let timeoutID; // caching

      let last = 0;

      function call() {
        timeoutID = 0;
        last = +new Date();
        rtn = func.apply(ctx, args);
        ctx = null;
        args = null;
      }

      return function throttled() {
        ctx = this;
        args = arguments;
        const delta = new Date() - last;

        if (!timeoutID) {
          if (delta >= wait) {
            call();
          } else {
            timeoutID = setTimeout(call, wait - delta);
          }
        }

        return rtn;
      };
    }

  };
  return ConcurrentUtils;
}();
;// CONCATENATED MODULE: ./Extension/src/background/utils/channels.js
/* eslint-disable prefer-rest-params */

/**
 * Simple publish-subscribe implementation
 */
const channels = (() => {
  const EventChannels = (() => {
    const EventChannel = function () {
      let listeners = null;
      let listenerCallback = null;

      const addListener = function (callback) {
        if (typeof callback !== 'function') {
          throw new Error('Illegal callback');
        }

        if (listeners !== null) {
          listeners.push(callback);
          return;
        }

        if (listenerCallback !== null) {
          listeners = [];
          listeners.push(listenerCallback);
          listeners.push(callback);
          listenerCallback = null;
        } else {
          listenerCallback = callback;
        }
      };

      const removeListener = function (callback) {
        if (listenerCallback !== null) {
          listenerCallback = null;
        } else {
          const index = listeners.indexOf(callback);

          if (index >= 0) {
            listeners.splice(index, 1);
          }
        }
      };

      const notify = function () {
        if (listenerCallback !== null) {
          return listenerCallback.apply(listenerCallback, arguments);
        }

        if (listeners !== null) {
          for (let i = 0; i < listeners.length; i += 1) {
            const listener = listeners[i];
            listener.apply(listener, arguments);
          }
        }
      };

      const notifyInReverseOrder = function () {
        if (listenerCallback !== null) {
          return listenerCallback.apply(listenerCallback, arguments);
        }

        if (listeners !== null) {
          for (let i = listeners.length - 1; i >= 0; i -= 1) {
            const listener = listeners[i];
            listener.apply(listener, arguments);
          }
        }
      };

      return {
        addListener,
        removeListener,
        notify,
        notifyInReverseOrder
      };
    };

    const namedChannels = Object.create(null);

    const newChannel = function () {
      return new EventChannel();
    };

    const newNamedChannel = function (name) {
      const channel = newChannel();
      namedChannels[name] = channel;
      return channel;
    };

    const getNamedChannel = function (name) {
      return namedChannels[name];
    };

    return {
      newChannel,
      newNamedChannel,
      getNamedChannel
    };
  })();

  return EventChannels;
})();
;// CONCATENATED MODULE: ./Extension/src/background/utils/workaround.js
/**
 * We collect here all workarounds and ugly hacks:)
 */
const workaround = function () {
  const WorkaroundUtils = {
    /**
     * Converts blocked counter to the badge text.
     * Workaround for FF - make 99 max.
     *
     * @param blocked Blocked requests count
     */
    getBlockedCountText(blocked) {
      let blockedText = blocked === '0' ? '' : blocked;

      if (blocked - 0 > 99) {
        blockedText = '\u221E';
      }

      return blockedText;
    }

  };
  return WorkaroundUtils;
}();
;// CONCATENATED MODULE: ./Extension/src/background/utils/i18n.js

/**
 * Simple i18n utils
 */

const i18n = function () {
  function isArrayElement(array, elem) {
    return array.indexOf(elem) >= 0;
  }

  function isObjectKey(object, key) {
    return key in object;
  }

  return {
    /**
     * Tries to find locale in the given collection of locales
     * @param locales Collection of locales (array or object)
     * @param locale Locale (e.g. en, en_GB, pt_BR)
     * @returns matched locale from the locales collection or null
     */
    normalize(locales, locale) {
      if (!locale) {
        return null;
      } // Transform Language-Country => Language_Country


      locale = locale.replace('-', '_');
      let search;

      if (collections.isArray(locales)) {
        search = isArrayElement;
      } else {
        search = isObjectKey;
      }

      if (search(locales, locale)) {
        return locale;
      } // Try to search by the language


      const parts = locale.split('_');
      const language = parts[0];

      if (search(locales, language)) {
        return language;
      }

      return null;
    }

  };
}();
// EXTERNAL MODULE: ./Extension/src/common/constants.js
var constants = __webpack_require__(84568);
;// CONCATENATED MODULE: ./Extension/src/background/utils/filters.js

/**
 * Util class for detect filter type. Includes various filter identifiers
 */

const filters = (() => {
  const FilterUtils = {
    isUserFilterRule(rule) {
      return rule.getFilterListId() === constants/* ANTIBANNER_FILTERS_ID.USER_FILTER_ID */.gu.USER_FILTER_ID;
    },

    isAllowlistFilterRule(rule) {
      return rule.getFilterListId() === constants/* ANTIBANNER_FILTERS_ID.ALLOWLIST_FILTER_ID */.gu.ALLOWLIST_FILTER_ID;
    }

  }; // Make accessible only constants without functions. They will be passed to content-page

  FilterUtils.ids = constants/* ANTIBANNER_FILTERS_ID */.gu; // Copy filter ids to api

  Object.keys(constants/* ANTIBANNER_FILTERS_ID */.gu).forEach(key => {
    FilterUtils[key] = constants/* ANTIBANNER_FILTERS_ID */.gu[key];
  });
  return FilterUtils;
})();
// EXTERNAL MODULE: ./node_modules/punycode/punycode.es6.js
var punycode_es6 = __webpack_require__(2860);
;// CONCATENATED MODULE: ./Extension/src/background/utils/url.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */

/* eslint-disable camelcase, no-control-regex, max-len */


const url = function () {
  const RE_V4 = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|0x[0-9a-f][0-9a-f]?|0[0-7]{3})\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|0x[0-9a-f][0-9a-f]?|0[0-7]{3})$/i;
  const RE_V4_HEX = /^0x([0-9a-f]{8})$/i;
  const RE_V4_NUMERIC = /^[0-9]+$/;
  const RE_V4inV6 = /(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
  const RE_BAD_CHARACTERS = /([^0-9a-f:])/i;
  const RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]$)/i;
  /**
   * Helper methods to work with URLs
   */

  const UrlUtils = {
    isHttpRequest(url) {
      return url && url.indexOf('http') === 0;
    },

    isHttpOrWsRequest(url) {
      return url && (url.indexOf('http') === 0 || url.indexOf('ws') === 0);
    },

    toPunyCode(domain) {
      if (!domain) {
        return '';
      }

      if (/^[\x00-\x7F]+$/.test(domain)) {
        return domain;
      }

      return punycode_es6/* default.toASCII */.ZP.toASCII(domain);
    },

    /**
     * Retrieves hostname from URL
     */
    getHost(url) {
      if (!url) {
        return null;
      }

      let firstIdx = url.indexOf('//');

      if (firstIdx === -1) {
        /**
         * It's non hierarchical structured URL (e.g. stun: or turn:)
         * https://tools.ietf.org/html/rfc4395#section-2.2
         * https://tools.ietf.org/html/draft-nandakumar-rtcweb-stun-uri-08#appendix-B
         */
        firstIdx = url.indexOf(':');

        if (firstIdx === -1) {
          return null;
        }

        firstIdx -= 1;
      }

      const nextSlashIdx = url.indexOf('/', firstIdx + 2);
      const startParamsIdx = url.indexOf('?', firstIdx + 2);
      let lastIdx = nextSlashIdx;

      if (startParamsIdx > 0 && (startParamsIdx < nextSlashIdx || nextSlashIdx < 0)) {
        lastIdx = startParamsIdx;
      }

      let host = lastIdx === -1 ? url.substring(firstIdx + 2) : url.substring(firstIdx + 2, lastIdx);
      const portIndex = host.indexOf(':');
      host = portIndex === -1 ? host : host.substring(0, portIndex); // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1586

      const lastChar = host.charAt(host.length - 1);

      if (lastChar === '.') {
        host = host.slice(0, -1);
      }

      return host;
    },

    getDomainName(url) {
      const host = this.getHost(url);
      return this.getCroppedDomainName(host);
    },

    getCroppedDomainName(host) {
      return strings/* strings.startWith */.j.startWith(host, 'www.') ? host.substring(4) : host;
    },

    isIpv4(address) {
      if (RE_V4.test(address)) {
        return true;
      }

      if (RE_V4_HEX.test(address)) {
        return true;
      }

      if (RE_V4_NUMERIC.test(address)) {
        return true;
      }

      return false;
    },

    isIpv6(address) {
      let a4addon = 0;
      const address4 = address.match(RE_V4inV6);

      if (address4) {
        const temp4 = address4[0].split('.');

        for (let i = 0; i < 4; i += 1) {
          if (/^0[0-9]+/.test(temp4[i])) {
            return false;
          }
        }

        address = address.replace(RE_V4inV6, '');

        if (/[0-9]$/.test(address)) {
          return false;
        }

        address += temp4.join(':');
        a4addon = 2;
      }

      if (RE_BAD_CHARACTERS.test(address)) {
        return false;
      }

      if (RE_BAD_ADDRESS.test(address)) {
        return false;
      }

      function count(string, substring) {
        return (string.length - string.replace(new RegExp(substring, 'g'), '').length) / substring.length;
      }

      const halves = count(address, '::');

      if (halves === 1 && count(address, ':') <= 6 + 2 + a4addon) {
        return true;
      }

      if (halves === 0 && count(address, ':') === 7 + a4addon) {
        return true;
      }

      return false;
    },

    urlEquals(u1, u2) {
      if (!u1 || !u2) {
        return false;
      } // eslint-disable-next-line prefer-destructuring


      u1 = u1.split(/[#?]/)[0]; // eslint-disable-next-line prefer-destructuring

      u2 = u2.split(/[#?]/)[0];
      return u1 === u2;
    }

  };
  return UrlUtils;
}();
;// CONCATENATED MODULE: ./Extension/src/background/utils/common.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */










/**
 * Background tab id in browsers is defined as -1
 */

const BACKGROUND_TAB_ID = -1;
/**
 * Main frame id is equal to 0
 */

const MAIN_FRAME_ID = 0;
/**
 * Utilities namespace
 */

const utils = {
  strings: strings/* strings */.j,
  dates: dates,
  collections: collections,
  concurrent: concurrent,
  channels: channels,
  workaround: workaround,
  i18n: i18n,
  filters: filters,
  url: url
};
/**
 * Converts chrome tabs into tabs
 * https://developer.chrome.com/extensions/tabs#type-Tab
 * @param chromeTab
 * @returns tab
 */

function toTabFromChromeTab(chromeTab) {
  return {
    tabId: chromeTab.id,
    url: chromeTab.url,
    title: chromeTab.title,
    incognito: chromeTab.incognito,
    status: chromeTab.status
  };
}
/**
 * Unload handler. When extension is unload then 'fireUnload' is invoked.
 * You can add own handler with method 'when'
 * @type {{when, fireUnload}}
 */

const unload = function () {
  const unloadChannel = utils.channels.newChannel();

  const when = function (callback) {
    if (typeof callback !== 'function') {
      return;
    }

    unloadChannel.addListener(() => {
      try {
        callback();
      } catch (ex) {
        log/* log.error */.c.error('Error while invoke unload method');
        log/* log.error */.c.error(ex);
      }
    });
  };

  const fireUnload = function (reason) {
    log/* log.info */.c.info(`Unload is fired: ${reason}`);
    unloadChannel.notifyInReverseOrder(reason);
  };

  return {
    when,
    fireUnload
  };
}();
// EXTERNAL MODULE: ./Extension/src/common/common-script.js
var common_script = __webpack_require__(71351);
// EXTERNAL MODULE: ./Extension/src/background/extension-api/browser.js
var extension_api_browser = __webpack_require__(92273);
;// CONCATENATED MODULE: ./Extension/src/background/utils/lazy.js
/**
 * This function allows cache property in object. Use with javascript getter.
 *
 * var Object = {
 *
 *      get someProperty(){
 *          return lazyGet(Object, 'someProperty', function() {
 *              return calculateSomeProperty();
 *          });
 *      }
 * }
 *
 * @param object Object
 * @param prop Original property name
 * @param calculateFunc Calculation function
 * @returns {*}
 */
const lazyGet = function (object, prop, calculateFunc) {
  const cachedProp = `_${prop}`;

  if (cachedProp in object) {
    return object[cachedProp];
  }

  const value = calculateFunc.apply(object);
  object[cachedProp] = value;
  return value;
};
/**
 * Clear cached property
 * @param object Object
 * @param prop Original property name
 */

const lazyGetClear = function (object, prop) {
  delete object[`_${prop}`];
};
// EXTERNAL MODULE: ./Extension/src/common/user-agent-utils.js
var user_agent_utils = __webpack_require__(3702);
;// CONCATENATED MODULE: ./Extension/src/background/prefs.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */



/**
 * Extension global preferences.
 */

const prefs = (() => {
  const Prefs = {
    get mobile() {
      return lazyGet(Prefs, 'mobile', () => user_agent_utils/* isAndroid */.Dt);
    },

    get platform() {
      return lazyGet(Prefs, 'platform', () => window.browser ? 'firefox' : 'chromium');
    },

    get browser() {
      return lazyGet(Prefs, 'browser', () => {
        let browser;

        if (user_agent_utils/* isYaBrowser */.vs) {
          browser = 'YaBrowser';
        } else if (user_agent_utils/* isEdge */.un) {
          browser = 'Edge';
        } else if (user_agent_utils/* isEdgeChromium */.kD) {
          browser = 'EdgeChromium';
        } else if (user_agent_utils/* isOpera */.f0) {
          browser = 'Opera';
        } else if (user_agent_utils/* isFirefox */.vU) {
          browser = 'Firefox';
        } else {
          browser = 'Chrome';
        }

        return browser;
      });
    },

    get chromeVersion() {
      return lazyGet(Prefs, 'chromeVersion', () => user_agent_utils/* chromeVersion */.CE);
    },

    get firefoxVersion() {
      return lazyGet(Prefs, 'firefoxVersion', () => user_agent_utils/* firefoxVersion */.rI);
    },

    /**
     * https://msdn.microsoft.com/ru-ru/library/hh869301(v=vs.85).aspx
     * @returns {*}
     */
    get edgeVersion() {
      return lazyGet(Prefs, 'edgeVersion', function () {
        if (this.browser === 'Edge') {
          const {
            userAgent
          } = navigator;
          const i = userAgent.indexOf('Edge/');

          if (i < 0) {
            return {
              rev: 0,
              build: 0
            };
          }

          const version = userAgent.substring(i + 'Edge/'.length);
          const parts = version.split('.');
          return {
            rev: Number.parseInt(parts[0], 10),
            build: Number.parseInt(parts[1], 10)
          };
        }
      });
    },

    /**
     * Makes sense in case of FF add-on only
     */
    speedupStartup() {
      return false;
    },

    get ICONS() {
      return lazyGet(Prefs, 'ICONS', () => ({
        ICON_GREEN: {
          '19': extension_api_browser/* browser.runtime.getURL */.X.runtime.getURL('assets/icons/green-19.png'),
          '38': extension_api_browser/* browser.runtime.getURL */.X.runtime.getURL('assets/icons/green-38.png')
        },
        ICON_GRAY: {
          '19': extension_api_browser/* browser.runtime.getURL */.X.runtime.getURL('assets/icons/gray-19.png'),
          '38': extension_api_browser/* browser.runtime.getURL */.X.runtime.getURL('assets/icons/gray-38.png')
        }
      }));
    },

    // interval 60 seconds in Firefox is set so big due to excessive IO operations on every storage save
    // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1006
    get statsSaveInterval() {
      return this.browser === 'Firefox' ? 1000 * 60 : 1000;
    }

  };
  /**
   * Collect browser specific features here
   */

  Prefs.features = function () {
    var _browser$tabs, _browser$tabs2;

    // Get the global extension object (browser for FF, chrome for Chromium)
    const browser = window.browser || window.chrome;
    const responseContentFilteringSupported = typeof browser !== 'undefined' && typeof browser.webRequest !== 'undefined' && typeof browser.webRequest.filterResponseData !== 'undefined';
    const canUseInsertCSSAndExecuteScript = typeof ((_browser$tabs = browser.tabs) === null || _browser$tabs === void 0 ? void 0 : _browser$tabs.insertCSS) !== 'undefined' && typeof ((_browser$tabs2 = browser.tabs) === null || _browser$tabs2 === void 0 ? void 0 : _browser$tabs2.executeScript) !== 'undefined';
    return {
      responseContentFilteringSupported,
      canUseInsertCSSAndExecuteScript,
      hasBackgroundTab: typeof browser !== 'undefined' // Background requests have sense only in case of webext

    };
  }();

  return Prefs;
})();
;// CONCATENATED MODULE: ./Extension/src/background/extension-api/background-page.js


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */

/* eslint-disable max-len */







const backgroundPage = (() => {
  const runtime = function () {
    const onMessage = {
      addListener(callback) {
        // https://developer.chrome.com/extensions/runtime#event-onMessage
        common_script/* runtimeImpl.onMessage.addListener */.VX.onMessage.addListener((message, sender) => {
          const senderOverride = Object.create(null);

          if (sender.tab) {
            senderOverride.tab = toTabFromChromeTab(sender.tab);
          }

          if (typeof sender.frameId !== 'undefined') {
            senderOverride.frameId = sender.frameId;
          }

          return callback(message, senderOverride);
        });
      }

    };
    return {
      setUninstallURL: extension_api_browser/* browser.runtime.setUninstallURL */.X.runtime.setUninstallURL,
      reload: extension_api_browser/* browser.runtime.reload */.X.runtime.reload,
      onMessage,
      onConnect: extension_api_browser/* browser.runtime.onConnect */.X.runtime.onConnect,

      get lastError() {
        return extension_api_browser/* browser.runtime.lastError */.X.runtime.lastError;
      }

    };
  }(); // Calculates scheme of this extension (e.g.: chrome-extension:// or moz-extension://)


  const extensionScheme = function () {
    const url = extension_api_browser/* browser.runtime.getURL */.X.runtime.getURL('');

    if (!url) {
      return url;
    }

    const index = url.indexOf('://');

    if (index > 0) {
      return url.substring(0, index);
    }

    return url;
  }();
  /**
   * We are skipping requests to internal resources of extensions
   * (e.g. chrome-extension:// or moz-extension://... etc.)
   * @param details Request details
   * @returns {boolean}
   */


  function shouldSkipRequest(details) {
    return details.tabId === BACKGROUND_TAB_ID && details.url.indexOf(extensionScheme) === 0;
  }

  const linkHelper = document.createElement('a');
  /**
   * Fixing request type:
   * https://code.google.com/p/chromium/issues/detail?id=410382
   *
   * @param url Request url
   * @returns String Fixed object type
   */

  function parseRequestTypeFromUrl(url) {
    linkHelper.href = url;
    const path = linkHelper.pathname;
    let requestType = (0,request_types/* parseContentTypeFromUrlPath */.O)(path);

    if (requestType === null) {
      // https://code.google.com/p/chromium/issues/detail?id=410382
      requestType = request_types/* RequestTypes.OBJECT */.l.OBJECT;
    }

    return requestType;
  }
  /**
   * An array of HTTP headers.
   * Each header is represented as a dictionary containing the keys name
   * and either value or binaryValue.
   * https://developer.chrome.com/extensions/webRequest#type-HttpHeaders
   * @typedef HttpHeaders
   * @type {Array.<{ name: String, value: String, binaryValue }>}
   */

  /**
   * @typedef RequestDetails
   * @type {Object}
   * @property {String} requestUrl - request url
   * @property {String} referrerUrl - the origin where the request was initiated
   * @property {{tabId: Number}} tab - request tab with tabId in property
   * @property {Number} requestId - the ID of the request
   * @property {Number} statusCode - standard HTTP status code
   * @property {String} method - standard HTTP method
   * @property {Number} frameId - ID of current frame. Frame IDs are unique within a tab.
   * @property {Number} requestFrameId - ID of frame where request is executed
   * @property {Number} requestType - request type {@link RequestTypes}
   * @property {HttpHeaders} [requestHeaders] - the HTTP request headers
   * @property {HttpHeaders} [responseHeaders] - the HTTP response headers
   * @property {String} redirectUrl - new URL in onBeforeRedirect event
   */

  /**
   * Argument passed to the webRequest event listener.
   * Every webRequest event listener has its own object with request details.
   * To learn more see https://developer.chrome.com/extensions/webRequest or
   * https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/webRequest
   * @typedef {Object} WebRequestDetails
   */

  /**
   * Transforms raw request details from different browsers into unified format
   * @param {WebRequestDetails} details raw webRequest details
   * @returns {RequestDetails} prepared request details
   */


  function getRequestDetails(details) {
    const tab = {
      tabId: details.tabId
    };
    /**
     * FF sends http instead of ws protocol at the http-listeners layer
     * Although this is expected, as the Upgrade request is indeed an HTTP request,
     * we use a chromium based approach in this case.
     */

    if (details.type === 'websocket' && details.url.indexOf('http') === 0) {
      details.url = details.url.replace(/^http(s)?:/, 'ws$1:');
    } // https://developer.chrome.com/extensions/webRequest#event-onBeforeRequest


    const requestDetails = {
      requestUrl: details.url,
      // request url
      url: details.url,
      tab,
      // request tab,
      tabId: details.tabId,
      requestId: details.requestId,
      statusCode: details.statusCode,
      method: details.method
    };
    let frameId = 0; // id of this frame (only for main_frame and sub_frame types)

    let requestFrameId = 0; // id of frame where request is executed

    let requestType; // request type

    switch (details.type) {
      case 'main_frame':
        frameId = 0;
        requestType = request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT;
        break;

      case 'sub_frame':
        frameId = details.frameId; // for sub_frame use parentFrameId as id of frame that wraps this frame

        requestFrameId = details.parentFrameId;
        requestType = request_types/* RequestTypes.SUBDOCUMENT */.l.SUBDOCUMENT;
        break;

      default:
        requestFrameId = details.frameId;
        requestType = details.type.toUpperCase();
        break;
    } // Relate request to main_frame


    if (requestFrameId === -1) {
      requestFrameId = 0;
    }

    if (requestType === 'IMAGESET') {
      requestType = request_types/* RequestTypes.IMAGE */.l.IMAGE;
    }

    if (requestType === request_types/* RequestTypes.OTHER */.l.OTHER) {
      requestType = parseRequestTypeFromUrl(details.url);
    }
    /**
     * ping type is 'ping' in Chrome
     * but Firefox considers it as 'beacon'
     */


    if (requestType === 'BEACON') {
      requestType = request_types/* RequestTypes.PING */.l.PING;
    }
    /**
     * Use `OTHER` type as a fallback
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/777
     */


    if (!(requestType in request_types/* RequestTypes */.l)) {
      requestType = request_types/* RequestTypes.OTHER */.l.OTHER;
    }

    requestDetails.frameId = frameId;
    requestDetails.requestFrameId = requestFrameId;
    requestDetails.requestType = requestType;

    if (details.requestHeaders) {
      requestDetails.requestHeaders = details.requestHeaders;
    }

    if (details.responseHeaders) {
      requestDetails.responseHeaders = details.responseHeaders;
    }

    if (details.requestBody) {
      requestDetails.requestBody = details.requestBody;
    }

    if (details.tabId === BACKGROUND_TAB_ID) {
      // In case of background request, its details contains referrer url
      // Chrome uses `initiator`: https://developer.chrome.com/extensions/webRequest#event-onBeforeRequest
      // FF uses `originUrl`: https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/webRequest/onBeforeRequest#Additional_objects
      requestDetails.referrerUrl = details.originUrl || details.initiator;
    }

    requestDetails.originUrl = details.originUrl || details.initiator;
    requestDetails.thirdParty = es/* isThirdPartyRequest */.ag(requestDetails.requestUrl, requestDetails.originUrl);
    return requestDetails;
  }

  const onBeforeRequest = {
    /**
     * Wrapper for webRequest.onBeforeRequest event
     * It prepares requestDetails and passes them to the callback
     * @param callback callback function receives {RequestDetails} and handles event
     * @param {String} urls url match pattern https://developer.chrome.com/extensions/match_patterns
     * @param {string[]} types
     * @param {string[]} extraInfoSpecsDirty
     */
    addListener(callback, urls, types, extraInfoSpecsDirty) {
      const filters = {};

      if (urls) {
        filters.urls = urls;
      }

      if (types) {
        filters.types = types;
      }

      const extraInfoSpec = ['blocking'];

      if (extraInfoSpecsDirty && extraInfoSpecsDirty.length > 0) {
        extraInfoSpecsDirty.forEach(spec => {
          extraInfoSpec.push(spec);
        });
      } // https://developer.chrome.com/extensions/webRequest#event-onBeforeRequest


      extension_api_browser/* browser.webRequest.onBeforeRequest.addListener */.X.webRequest.onBeforeRequest.addListener(details => {
        if (shouldSkipRequest(details)) {
          return;
        }

        const requestDetails = getRequestDetails(details);
        return callback(requestDetails);
      }, filters, extraInfoSpec);
    }

  };
  /**
   * Apply 'extraHeaders' option for request/response headers access/change. See:
   * https://groups.google.com/a/chromium.org/forum/#!topic/chromium-extensions/vYIaeezZwfQ
   * https://chromium-review.googlesource.com/c/chromium/src/+/1338165
   */

  const onBeforeSendHeadersExtraInfoSpec = ['requestHeaders', 'blocking'];
  const onHeadersReceivedExtraInfoSpec = ['responseHeaders', 'blocking'];

  if (typeof extension_api_browser/* browser.webRequest.OnBeforeSendHeadersOptions */.X.webRequest.OnBeforeSendHeadersOptions !== 'undefined' && extension_api_browser/* browser.webRequest.OnBeforeSendHeadersOptions.hasOwnProperty */.X.webRequest.OnBeforeSendHeadersOptions.hasOwnProperty('EXTRA_HEADERS')) {
    onBeforeSendHeadersExtraInfoSpec.push('extraHeaders');
  }

  if (typeof extension_api_browser/* browser.webRequest.OnHeadersReceivedOptions */.X.webRequest.OnHeadersReceivedOptions !== 'undefined' && extension_api_browser/* browser.webRequest.OnHeadersReceivedOptions.hasOwnProperty */.X.webRequest.OnHeadersReceivedOptions.hasOwnProperty('EXTRA_HEADERS')) {
    onHeadersReceivedExtraInfoSpec.push('extraHeaders');
  }

  const onHeadersReceived = {
    /**
     * Wrapper for webRequest.onHeadersReceived event
     * It prepares requestDetails and passes them to the callback
     * @param callback callback function receives {RequestDetails} and handles event
     * @param {Array.<String>} urls url match pattern https://developer.chrome.com/extensions/match_patterns
     */
    addListener(callback, urls) {
      extension_api_browser/* browser.webRequest.onHeadersReceived.addListener */.X.webRequest.onHeadersReceived.addListener(details => {
        if (shouldSkipRequest(details)) {
          return;
        }

        const requestDetails = getRequestDetails(details);
        const result = callback(requestDetails);

        if (result) {
          return 'responseHeaders' in result ? {
            responseHeaders: result.responseHeaders
          } : {};
        }
      }, urls ? {
        urls
      } : {}, onHeadersReceivedExtraInfoSpec);
    }

  };
  const onBeforeSendHeaders = {
    /**
     * Wrapper for webRequest.onBeforeSendHeaders event
     * It prepares requestDetails and passes them to the callback
     * @param callback callback function receives {RequestDetails} and handles event
     * @param {Array.<String>} urls url match pattern https://developer.chrome.com/extensions/match_patterns
     */
    addListener(callback, urls) {
      let requestFilter = {};
      /**
       * Sometimes extraHeaders option of onBeforeSendHeaders handler is blocking network
       * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1634
       * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1644
       * https://bugs.chromium.org/p/chromium/issues/detail?id=938560
       * https://bugs.chromium.org/p/chromium/issues/detail?id=1075905
       * This issue was fixed in the Canary v85.0.4178.0 and would be fixed
       * in the Chrome with the same version
       * Until v85 we have decided to filter requests with types:
       * 'stylesheet', 'script', 'media'
       */

      if (prefs.browser === 'Chrome' && prefs.chromeVersion < 85) {
        const allTypes = ['main_frame', 'sub_frame', 'stylesheet', 'script', 'image', 'font', 'object', 'xmlhttprequest', 'ping', 'csp_report', 'media', 'websocket', 'other']; // this request types block requests, if use them with extraHeaders and blocking options

        const nonExtraHeadersTypes = ['stylesheet', 'script', 'media'];
        const extraHeadersTypes = allTypes.filter(type => !nonExtraHeadersTypes.includes(type)); // Assign instead of spread used because FF begin to support them from v55
        // https://caniuse.com/#feat=mdn-javascript_operators_spread_spread_in_object_literals

        requestFilter = Object.assign(requestFilter, {
          types: extraHeadersTypes
        });
      }

      if (urls) {
        // Assign instead of spread used because FF begin to support them from v55
        // https://caniuse.com/#feat=mdn-javascript_operators_spread_spread_in_object_literals
        requestFilter = Object.assign(requestFilter, {
          urls
        });
      }

      extension_api_browser/* browser.webRequest.onBeforeSendHeaders.addListener */.X.webRequest.onBeforeSendHeaders.addListener(details => {
        if (shouldSkipRequest(details)) {
          return;
        }

        const requestDetails = getRequestDetails(details);
        const result = callback(requestDetails);

        if (result) {
          return 'requestHeaders' in result ? {
            requestHeaders: result.requestHeaders
          } : {};
        }
      }, requestFilter, onBeforeSendHeadersExtraInfoSpec);
    }

  };
  const onResponseStarted = {
    /**
     * Wrapper for webRequest.onResponseStarted event
     * It prepares requestDetails and passes them to the callback
     * @param callback callback function receives {RequestDetails} and handles event
     * @param {String} urls url match pattern https://developer.chrome.com/extensions/match_patterns
     */
    addListener(callback, urls) {
      extension_api_browser/* browser.webRequest.onResponseStarted.addListener */.X.webRequest.onResponseStarted.addListener(details => {
        if (shouldSkipRequest(details)) {
          return;
        }

        const requestDetails = getRequestDetails(details);
        return callback(requestDetails);
      }, urls ? {
        urls
      } : {}, ['responseHeaders']);
    }

  };
  const onErrorOccurred = {
    /**
     * Wrapper for webRequest.onErrorOccurred event
     * It prepares requestDetails and passes them to the callback
     * @param callback callback function receives {RequestDetails} and handles event
     * @param {String} urls url match pattern https://developer.chrome.com/extensions/match_patterns
     */
    addListener(callback, urls) {
      extension_api_browser/* browser.webRequest.onErrorOccurred.addListener */.X.webRequest.onErrorOccurred.addListener(details => {
        if (shouldSkipRequest(details)) {
          return;
        }

        const requestDetails = getRequestDetails(details);
        return callback(requestDetails);
      }, urls ? {
        urls
      } : {});
    }

  };
  const onCompleted = {
    /**
     * Wrapper for webRequest.onCompleted event
     * It prepares requestDetails and passes them to the callback
     * @param callback callback function receives {RequestDetails} and handles event
     * @param {String} urls url match pattern https://developer.chrome.com/extensions/match_patterns
     */
    addListener(callback, urls) {
      extension_api_browser/* browser.webRequest.onCompleted.addListener */.X.webRequest.onCompleted.addListener(details => {
        if (shouldSkipRequest(details)) {
          return;
        }

        const requestDetails = getRequestDetails(details);
        return callback(requestDetails);
      }, urls ? {
        urls
      } : {}, ['responseHeaders']);
    }

  };
  const onBeforeRedirect = {
    /**
     * Wrapper for webRequest.onBeforeRedirect event
     * It prepares requestDetails and passes them to the callback
     * @param callback callback function receives {RequestDetails} and handles event
     * @param {Array.<String>} urls url match pattern https://developer.chrome.com/extensions/match_patterns
     */
    addListener(callback, urls) {
      extension_api_browser/* browser.webRequest.onBeforeRedirect.addListener */.X.webRequest.onBeforeRedirect.addListener(details => {
        if (shouldSkipRequest(details)) {
          return;
        }

        const requestDetails = getRequestDetails(details);
        requestDetails.redirectUrl = details.redirectUrl;
        return callback(requestDetails);
      }, urls ? {
        urls
      } : {});
    }

  };
  /**
   * Gets URL of a file that belongs to our extension
   * https://developer.chrome.com/apps/runtime#method-getURL
   */
  // eslint-disable-next-line prefer-destructuring

  const getURL = extension_api_browser/* browser.runtime.getURL */.X.runtime.getURL;
  const app = {
    /**
     * Extension ID
     */
    getId() {
      return extension_api_browser/* browser.runtime.id */.X.runtime.id;
    },

    /**
     * Gets extension scheme
     * @returns "chrome-extension" for Chrome," ms-browser-extension" for Edge
     */
    getUrlScheme() {
      const url = backgroundPage.getURL('test.html');
      const index = url.indexOf('://');
      return url.substring(0, index);
    },

    /**
     * Extension version
     */
    getVersion() {
      return extension_api_browser/* browser.runtime.getManifest */.X.runtime.getManifest().version;
    },

    /**
     * Extension UI locale
     */
    getLocale() {
      return extension_api_browser/* browser.i18n.getUILanguage */.X.i18n.getUILanguage();
    },

    /**
     * Returns extension's full url
     */
    getExtensionUrl() {
      const url = getURL('');
      return url.substring(0, url.length - 1);
    },

    /**
     * If referrer of request contains full url of extension,
     * then this request is considered as extension's own request
     * (e.g. request for filter downloading)
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1437
     * @param referrerUrl
     * @returns {boolean}
     */
    isOwnRequest(referrerUrl) {
      return referrerUrl && referrerUrl.indexOf(this.getExtensionUrl()) === 0;
    }

  };
  const webRequest = {
    onBeforeRequest,
    handlerBehaviorChanged: extension_api_browser/* browser.webRequest.handlerBehaviorChanged */.X.webRequest.handlerBehaviorChanged,
    onCompleted,
    onErrorOccurred,
    onHeadersReceived,
    onBeforeSendHeaders,
    onResponseStarted,
    onBeforeRedirect,
    webSocketSupported: typeof extension_api_browser/* browser.webRequest.ResourceType */.X.webRequest.ResourceType !== 'undefined' && extension_api_browser/* browser.webRequest.ResourceType.WEBSOCKET */.X.webRequest.ResourceType.WEBSOCKET === 'websocket',
    filterResponseData: extension_api_browser/* browser.webRequest.filterResponseData */.X.webRequest.filterResponseData
  };
  const onCreatedNavigationTarget = {
    addListener(callback) {
      // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/webNavigation/onCreatedNavigationTarget#Browser_compatibility
      if (typeof extension_api_browser/* browser.webNavigation.onCreatedNavigationTarget */.X.webNavigation.onCreatedNavigationTarget === 'undefined') {
        return;
      }

      extension_api_browser/* browser.webNavigation.onCreatedNavigationTarget.addListener */.X.webNavigation.onCreatedNavigationTarget.addListener(details => {
        if (details.tabId === BACKGROUND_TAB_ID) {
          return;
        }

        callback({
          tabId: details.tabId,
          sourceTabId: details.sourceTabId,
          url: details.url
        });
      });
    }

  };
  const onCommitted = {
    /**
     * Wrapper for webNavigation.onCommitted event
     * It prepares webNavigation details and passes them to the callback
     * @param callback callback function receives object similar to {RequestDetails}
     * and handles event
     */
    addListener(callback) {
      // https://developer.chrome.com/extensions/webNavigation#event-onCommitted
      extension_api_browser/* browser.webNavigation.onCommitted.addListener */.X.webNavigation.onCommitted.addListener(details => {
        // makes webNavigation.onCommitted details similar to webRequestDetails
        details.requestType = details.frameId === 0 ? request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT : request_types/* RequestTypes.SUBDOCUMENT */.l.SUBDOCUMENT;
        details.tab = {
          tabId: details.tabId
        };
        details.requestUrl = details.url;
        callback(details);
      }, {
        url: [{
          urlPrefix: 'http'
        }, {
          urlPrefix: 'https'
        }]
      });
    }

  }; // https://developer.chrome.com/extensions/webNavigation

  const webNavigation = {
    onCreatedNavigationTarget,
    onCommitted,
    onDOMContentLoaded: extension_api_browser/* browser.webNavigation.onDOMContentLoaded */.X.webNavigation.onDOMContentLoaded
  };
  const browserActionSupported = typeof extension_api_browser/* browser.browserAction.setIcon */.X.browserAction.setIcon !== 'undefined';
  const browserAction = {
    /* eslint-disable-next-line no-unused-vars */
    async setBrowserAction(tab, icon, badge, badgeColor, title) {
      if (!browserActionSupported) {
        return;
      }

      const {
        tabId
      } = tab;

      const onIconReady = async () => {
        try {
          await extension_api_browser/* browser.browserAction.setBadgeText */.X.browserAction.setBadgeText({
            tabId,
            text: badge
          });
        } catch (e) {
          log/* log.debug */.c.debug(new Error(e.message));
          return;
        }

        if (badge) {
          try {
            await extension_api_browser/* browser.browserAction.setBadgeBackgroundColor */.X.browserAction.setBadgeBackgroundColor({
              tabId,
              color: badgeColor
            });
          } catch (e) {
            log/* log.debug */.c.debug(new Error(e.message));
          }
        } // title setup via manifest.json file
        // chrome.browserAction.setTitle({tabId: tabId, title: title});

      };
      /**
       * Workaround for MS Edge.
       * For some reason Edge changes the inner state of the "icon"
       * object and adds a tabId property inside.
       */


      delete icon.tabId;

      if (extension_api_browser/* browser.runtime.lastError */.X.runtime.lastError) {
        return;
      }

      try {
        // use path rather than imageData due to conversion problems in firefox for android
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/2032
        await extension_api_browser/* browser.browserAction.setIcon */.X.browserAction.setIcon({
          tabId,
          path: icon
        });
      } catch (e) {
        log/* log.debug */.c.debug(new Error(e.message));
        return;
      }

      onIconReady();
    },

    setPopup() {// Do nothing. Popup is already installed in manifest file
    },

    resize() {// Do nothing
    },

    close() {// Do nothing
    }

  }; // eslint-disable-next-line prefer-destructuring

  const contextMenus = extension_api_browser/* browser.contextMenus */.X.contextMenus; // eslint-disable-next-line prefer-destructuring

  const i18n = extension_api_browser/* browser.i18n */.X.i18n;
  return {
    runtime,
    getURL,
    app,
    webRequest,
    webNavigation,
    browserAction,
    contextMenus,
    i18n
  };
})();
;// CONCATENATED MODULE: ./Extension/src/background/utils/local-storage.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * Local storage implementation for chromium-based browsers
 */

const localStorageImpl = function () {
  const ADGUARD_SETTINGS_PROP = 'adguard-settings';
  let values = null;
  /**
   * Reads data from storage.local
   * @param path Path
   */

  async function read(path) {
    const results = await extension_api_browser/* browser.storage.local.get */.X.storage.local.get(path);
    return results ? results[path] : null;
  }
  /**
   * Writes data to storage.local
   * @param path Path
   * @param data Data to write
   */


  async function write(path, data) {
    const item = {};
    item[path] = data;
    await extension_api_browser/* browser.storage.local.set */.X.storage.local.set(item);
  }
  /**
   * Due to async initialization of storage, we have to check it before accessing values object
   * @returns {boolean}
   */


  function isInitialized() {
    return values !== null;
  }
  /**
   * Retrieves value by key from cached values
   * @param key
   * @returns {*}
   */


  function getItem(key) {
    if (!isInitialized()) {
      return null;
    }

    return values[key];
  }

  function setItem(key, value) {
    if (!isInitialized()) {
      return;
    }

    values[key] = value;
    write(ADGUARD_SETTINGS_PROP, values);
  }

  function removeItem(key) {
    if (!isInitialized()) {
      return;
    }

    delete values[key];
    write(ADGUARD_SETTINGS_PROP, values);
  }

  function hasItem(key) {
    if (!isInitialized()) {
      return false;
    }

    return key in values;
  }
  /**
   * We can't use localStorage object anymore and we've decided to store all data into storage.local
   * localStorage is affected by cleaning tools: https://github.com/AdguardTeam/AdguardBrowserExtension/issues/681
   * storage.local has async nature and we have to preload all key-values pairs into memory on extension startup
   */


  async function init() {
    if (isInitialized()) {
      // Already initialized
      return;
    }

    let items;

    try {
      items = await read(ADGUARD_SETTINGS_PROP);
    } catch (e) {
      log/* log.error */.c.error(e);
    }

    values = items || Object.create(null);
  }

  return {
    getItem,
    setItem,
    removeItem,
    hasItem,
    init,
    isInitialized
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/rules-storage/rules-storage.chrome.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Filter rules storage implementation
 */

const chromeRulesStorageImpl = (() => {
  const read = async path => {
    const results = await extension_api_browser/* browser.storage.local.get */.X.storage.local.get(path);
    let lines = [];

    if (results && results[path] instanceof Array) {
      lines = results[path];
    }

    return lines;
  };

  const write = async (path, data) => {
    const item = {};
    item[path] = data;
    await extension_api_browser/* browser.storage.local.set */.X.storage.local.set(item);
  };

  const remove = async path => {
    await extension_api_browser/* browser.storage.local.remove */.X.storage.local.remove(path);
  };

  return {
    read,
    write,
    remove
  };
})();

/* harmony default export */ const rules_storage_chrome = (chromeRulesStorageImpl);
;// CONCATENATED MODULE: ./Extension/src/background/rules-storage/index.js
// !IMPORTANT!
// './rules-storage.__ABSTRACT_BROWSER__' is replaced during webpack compilation
// with NormalModuleReplacementPlugin to proper browser implementation
// './rules-storage.chrome' or ./rules-storage.firefox


;// CONCATENATED MODULE: ./Extension/src/background/storage.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */



/**
 * This class manages local storage
 */

const storage_localStorage = function (localStorageImpl) {
  const getItem = function (key) {
    return localStorageImpl.getItem(key);
  };

  const setItem = function (key, value) {
    try {
      localStorageImpl.setItem(key, value);
    } catch (ex) {
      log/* log.error */.c.error(`Error while saving item ${key} to the localStorage: ${ex}`);
    }
  };

  const removeItem = function (key) {
    localStorageImpl.removeItem(key);
  };

  const hasItem = function (key) {
    return localStorageImpl.hasItem(key);
  };

  const init = async function () {
    if (typeof localStorageImpl.init === 'function') {
      await localStorageImpl.init();
    }
  };

  const isInitialized = function () {
    // WebExtension storage has async initialization
    if (typeof localStorageImpl.isInitialized === 'function') {
      return localStorageImpl.isInitialized();
    }

    return true;
  };

  return {
    getItem,
    setItem,
    removeItem,
    hasItem,
    init,
    isInitialized
  };
}(localStorageImpl);
/**
 * This class manages storage for filters.
 */

const rulesStorage = (rulesStorageImpl => {
  function getFilePath(filterId) {
    return `filterrules_${filterId}.txt`;
  }
  /**
   * Loads filter from the storage
   *
   * @param filterId  Filter identifier
   */


  const read = async filterId => {
    const filePath = getFilePath(filterId);
    let rules;

    try {
      rules = await rulesStorageImpl.read(filePath);
    } catch (e) {
      log/* log.error */.c.error(`Error while reading rules from file ${filePath} cause: ${e}`);
    }

    return rules;
  };
  /**
   * Saves filter rules to storage
   *
   * @param filterId      Filter identifier
   * @param filterRules   Filter rules
   */


  const write = async (filterId, filterRules) => {
    const filePath = getFilePath(filterId);

    try {
      await rulesStorageImpl.write(filePath, filterRules);
    } catch (e) {
      log/* log.error */.c.error(`Error writing filters to file ${filePath}. Cause: ${e}`);
    }
  };
  /**
   * Removes filter from storage
   * @param filterId
   */


  const remove = async filterId => {
    const filePath = getFilePath(filterId);

    try {
      await rulesStorageImpl.remove(filePath);
    } catch (e) {
      log/* log.error */.c.error(`Error removing filter ${filePath}. Cause: ${e}`);
    }
  };
  /**
   * IndexedDB implementation of the rules storage requires async initialization.
   * Also in some cases IndexedDB isn't supported, so we have to replace implementation
   * with the browser.storage
   */


  const init = async () => {
    if (typeof rulesStorageImpl.init === 'function') {
      const api = await rulesStorageImpl.init();
      rulesStorageImpl = api;
    }
  };

  return {
    read,
    write,
    remove,
    init
  };
})(rules_storage_chrome);
;// CONCATENATED MODULE: ./Extension/src/background/notifier.js
/* eslint-disable no-plusplus */

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * Simple mediator
 */

const listeners = (() => {
  const EventNotifierEventsMap = Object.create(null);
  const EventNotifier = {
    listenersMap: Object.create(null),
    listenersEventsMap: Object.create(null),
    listenerId: 0,

    /**
     * Subscribes listener to the specified events
     *
     * @param events    List of event types listener will be notified of
     * @param listener  Listener object
     * @returns Index of the listener
     */
    addSpecifiedListener(events, listener) {
      if (typeof listener !== 'function') {
        throw new Error('Illegal listener');
      }

      const listenerId = this.listenerId++;
      this.listenersMap[listenerId] = listener;
      this.listenersEventsMap[listenerId] = events;
      return listenerId;
    },

    /**
     * Subscribe specified listener to all events
     *
     * @param listener Listener
     * @returns Index of the listener
     */
    addListener(listener) {
      if (typeof listener !== 'function') {
        throw new Error('Illegal listener');
      }

      const listenerId = this.listenerId++;
      this.listenersMap[listenerId] = listener;
      return listenerId;
    },

    /**
     * Unsubscribe listener
     * @param listenerId Index of listener to unsubscribe
     */
    removeListener(listenerId) {
      delete this.listenersMap[listenerId];
      delete this.listenersEventsMap[listenerId];
    },

    /**
     * Notifies listeners about the events passed as arguments of this function.
     */
    notifyListeners(...args) {
      const [event] = args;

      if (!event || !(event in EventNotifierEventsMap)) {
        throw new Error(`Illegal event: ${event}`);
      }

      Object.entries(this.listenersMap).forEach(([listenerId, listener]) => {
        const events = this.listenersEventsMap[listenerId];

        if (events && events.length > 0 && events.indexOf(event) < 0) {
          return;
        }

        try {
          listener.apply(listener, args);
        } catch (ex) {
          log/* log.error */.c.error('Error invoking listener for {0} cause: {1}', event, ex);
        }
      });
    },

    /**
     * Asynchronously notifies all listeners about the events passed as arguments of this function.
     * Some events should be dispatched asynchronously, for instance this is very important for Safari:
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/251
     */
    notifyListenersAsync(...args) {
      setTimeout(() => {
        EventNotifier.notifyListeners(...args);
      }, 500);
    }

  }; // Make accessible only constants without functions. They will be passed to content-page

  EventNotifier.events = constants/* NOTIFIER_TYPES */.Qp; // Copy global properties

  Object.entries(constants/* NOTIFIER_TYPES */.Qp).forEach(([key, event]) => {
    EventNotifier[key] = event;

    if (event in EventNotifierEventsMap) {
      throw new Error(`Duplicate event:  ${event}`);
    }

    EventNotifierEventsMap[event] = key;
  });
  return EventNotifier;
})();
;// CONCATENATED MODULE: ./Extension/src/background/extension-api/tabs.js


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */

/* eslint-disable max-len */





/**
 * Chromium tabs implementation
 * @type {{onCreated, onRemoved, onUpdated, onActivated, create, remove, activate, reload, sendMessage, getAll, getActive, fromChromeTab}}
 */

const tabsImpl = function () {
  /**
   * tabId parameter must be integer
   * @param tabId
   */
  function tabIdToInt(tabId) {
    return Number.parseInt(tabId, 10);
  }

  function logOperationError(operation, e) {
    log/* log.error */.c.error('Error while executing operation{1}: {0}', e, operation ? ` '${operation}'` : '');
  }
  /**
   * Returns id of active tab
   * @returns {Promise<number|null>}
   */


  const getActive = async function () {
    /**
     * lastFocusedWindow parameter isn't supported by Opera
     * But seems currentWindow has the same effect in our case.
     * See for details:
     * https://developer.chrome.com/extensions/windows#current-window
     * https://dev.opera.com/extensions/tab-window/#accessing-the-current-tab
     * https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/tabs/query
     */
    let tabs;

    try {
      tabs = await extension_api_browser/* browser.tabs.query */.X.tabs.query({
        currentWindow: true,
        active: true
      });
    } catch (e) {
      log/* log.debug */.c.debug(new Error(e.message));
    }

    if (tabs && tabs.length > 0) {
      return tabs[0].id;
    }

    return null;
  }; // https://developer.chrome.com/extensions/tabs#event-onCreated


  const onCreatedChannel = utils.channels.newChannel();
  extension_api_browser/* browser.tabs.onCreated.addListener */.X.tabs.onCreated.addListener(chromeTab => {
    onCreatedChannel.notify(toTabFromChromeTab(chromeTab));
  }); // https://developer.chrome.com/extensions/tabs#event-onCreated

  const onRemovedChannel = utils.channels.newChannel();
  extension_api_browser/* browser.tabs.onRemoved.addListener */.X.tabs.onRemoved.addListener(tabId => {
    onRemovedChannel.notify(tabId);
  });
  const onUpdatedChannel = utils.channels.newChannel(); // https://developer.chrome.com/extensions/tabs#event-onUpdated

  extension_api_browser/* browser.tabs.onUpdated.addListener */.X.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
    onUpdatedChannel.notify(toTabFromChromeTab(tab));
  }); // https://developer.chrome.com/extensions/tabs#event-onActivated

  const onActivatedChannel = utils.channels.newChannel();
  extension_api_browser/* browser.tabs.onActivated.addListener */.X.tabs.onActivated.addListener(activeInfo => {
    onActivatedChannel.notify(activeInfo.tabId);
  }); // https://developer.chrome.com/extensions/windows#event-onFocusChanged

  extension_api_browser/* browser.windows.onFocusChanged.addListener */.X.windows.onFocusChanged.addListener(async windowId => {
    if (windowId === extension_api_browser/* browser.windows.WINDOW_ID_NONE */.X.windows.WINDOW_ID_NONE) {
      return;
    }

    const tabId = await getActive();

    if (tabId) {
      onActivatedChannel.notify(tabId);
    }
  });
  /**
   * Give focus to a window
   * @param tabId Tab identifier
   * @param windowId Window identifier
   */

  async function focusWindow(tabId, windowId) {
    /**
     * Updating already focused window produces bug in Edge browser
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/675
     */
    const activeTabId = await getActive();

    if (activeTabId && tabId !== activeTabId) {
      // Focus window
      try {
        await extension_api_browser/* browser.windows.update */.X.windows.update(windowId, {
          focused: true
        });
      } catch (e) {
        logOperationError(`Update window ${windowId}`, e);
      }
    }
  }
  /**
   * Creates new tab
   * @param createData
   */


  const create = async function (createData) {
    const {
      url,
      inNewWindow,
      width,
      height,
      top,
      left,
      isFullscreen
    } = createData;
    const active = createData.active === true;

    if (createData.type === 'popup' // Does not work properly in Anniversary builds
    && !browserUtils.isEdgeBeforeCreatorsUpdate() // Isn't supported by Android WebExt
    && !prefs.mobile) {
      // https://developer.chrome.com/extensions/windows#method-create
      // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/windows/create
      const windowState = isFullscreen ? {
        state: 'fullscreen'
      } : {
        width: width || 1000,
        height: height || 650,
        top: top || 0,
        left: left || 0
      };
      let tabId;

      try {
        const {
          id
        } = await extension_api_browser/* browser.windows.create */.X.windows.create({
          url,
          type: 'popup',
          ...windowState
        });
        tabId = id;
      } catch (e) {
        // Reopen tab with default pos if it was closed too far beyond the screen
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/2100
        if (e.message.includes('Invalid value for bounds.')) {
          const {
            id
          } = await extension_api_browser/* browser.windows.create */.X.windows.create({
            url,
            type: 'popup',
            ...windowState,
            top: 0,
            left: 0
          });
          tabId = id;
        }
      } // Firefox currently can't .create with top and left due to bug
      // https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/windows/create
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1271047


      if (browserUtils.isFirefoxBrowser() && typeof windowState.top === 'number') {
        await extension_api_browser/* browser.windows.update */.X.windows.update(tabId, windowState);
      }

      return;
    }

    const isHttp = url.indexOf('http') === 0;

    async function onWindowFound(win) {
      // https://developer.chrome.com/extensions/tabs#method-create
      const chromeTab = await extension_api_browser/* browser.tabs.create */.X.tabs.create({
        /**
         * In the Firefox browser for Android there is not concept of windows
         * There is only one window whole time
         * That's why if we try to provide windowId, method fails with error.
         */
        windowId: !prefs.mobile ? win.id : undefined,
        url,
        active
      });

      if (active) {
        await focusWindow(chromeTab.id, chromeTab.windowId);
      }

      return toTabFromChromeTab(chromeTab);
    }

    const onWindowCreatedWithTab = async win => {
      const [tab] = win.tabs;

      if (active) {
        await focusWindow(tab.id, tab.windowId);
      }

      return toTabFromChromeTab(tab);
    };

    function isAppropriateWindow(win) {
      // We can't open not-http (e.g. 'chrome-extension://') urls in incognito mode
      return win.type === 'normal' && (isHttp || !win.incognito);
    }

    if (!inNewWindow) {
      // https://developer.chrome.com/extensions/windows#method-create
      // https://developer.chrome.com/extensions/windows#method-getLastFocused
      // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/windows/create
      // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/windows/getLastFocused
      const win = await extension_api_browser/* browser.windows.getLastFocused */.X.windows.getLastFocused();

      if (isAppropriateWindow(win)) {
        return onWindowFound(win);
      } // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/569


      const wins = await extension_api_browser/* browser.windows.getAll */.X.windows.getAll({});

      if (wins) {
        for (let i = 0; i < wins.length; i += 1) {
          const win = wins[i];

          if (isAppropriateWindow(win)) {
            return onWindowFound(win);
          }
        }
      } // Create new window


      const newWin = await extension_api_browser/* browser.windows.create */.X.windows.create();
      return onWindowFound(newWin);
    } // if inNewWindow
    // we open window with "url" to avoid empty new tab creation


    const newWin = await extension_api_browser/* browser.windows.create */.X.windows.create({
      url
    });
    return onWindowCreatedWithTab(newWin);
  };

  const remove = async tabId => {
    // https://developer.chrome.com/extensions/tabs#method-remove
    // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/tabs/remove
    try {
      await extension_api_browser/* browser.tabs.remove */.X.tabs.remove(tabIdToInt(tabId));
    } catch (e) {
      return;
    }

    return tabId;
  };

  const activate = async function (tabId) {
    try {
      // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/tabs/update
      const chromeTab = await extension_api_browser/* browser.tabs.update */.X.tabs.update(tabIdToInt(tabId), {
        active: true
      });
      await focusWindow(tabId, chromeTab.windowId);
      return tabId;
    } catch (e) {
      logOperationError('Before tab update', e);
    }
  };
  /**
   * Sends message to tabs
   * @param tabId
   * @param message
   * @param options
   * @returns {Promise<*>}
   */


  const sendMessage = async (tabId, message, options) => {
    // https://developer.chrome.com/extensions/tabs#method-sendMessage
    // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/tabs/sendMessage
    const args = [tabIdToInt(tabId), message];

    if (typeof options === 'object') {
      args.push(options);
    }

    try {
      const response = await extension_api_browser/* browser.tabs.sendMessage */.X.tabs.sendMessage(...args);
      return response;
    } catch (e) {
      log/* log.debug */.c.debug(e.message);
    }
  };

  const reload = async (tabId, url) => {
    if (url) {
      if (browserUtils.isEdgeBrowser()) {
        /**
         * For security reasons, in Firefox and Edge, this may not be a privileged URL.
         * So passing any of the following URLs will fail, with runtime.lastError being set to an error message:
         * chrome: URLs
         * javascript: URLs
         * data: URLs
         * privileged about: URLs (for example, about:config, about:addons, about:debugging).
         *
         * Non-privileged URLs (about:home, about:newtab, about:blank) are allowed.
         *
         * So we use a content script instead.
         */

        /**
         * Content script may not have been loaded at this point yet.
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/580
         */
        setTimeout(() => {
          sendMessage(tabId, {
            type: 'update-tab-url',
            url
          });
        }, 100);
      } else {
        try {
          await extension_api_browser/* browser.tabs.update */.X.tabs.update(tabIdToInt(tabId), {
            url
          });
        } catch (e) {
          logOperationError('Tab update', e);
        }
      } // https://developer.chrome.com/extensions/tabs#method-reload
      // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/tabs/reload#Browser_compatibility

    } else if (extension_api_browser/* browser.tabs.reload */.X.tabs.reload) {
      try {
        await extension_api_browser/* browser.tabs.reload */.X.tabs.reload(tabIdToInt(tabId), {
          bypassCache: true
        });
      } catch (e) {
        logOperationError('Tab reload', e);
      }
    } else {
      // Reload page without cache via content script
      sendMessage(tabId, {
        type: 'no-cache-reload'
      });
    }
  };

  const getAll = async () => {
    // https://developer.chrome.com/extensions/tabs#method-query
    // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/tabs/query
    const chromeTabs = await extension_api_browser/* browser.tabs.query */.X.tabs.query({});
    const result = [];

    for (let i = 0; i < chromeTabs.length; i += 1) {
      const chromeTab = chromeTabs[i];
      result.push(toTabFromChromeTab(chromeTab));
    }

    return result;
  };
  /**
   * Gets tab by id
   * @param tabId Tab identifier
   */


  const get = async tabId => {
    try {
      const chromeTab = await extension_api_browser/* browser.tabs.get */.X.tabs.get(tabIdToInt(tabId));
      return toTabFromChromeTab(chromeTab);
    } catch (e) {
      logOperationError('Get tab', e);
    }
  };
  /**
   * Updates tab url
   * @param {number} tabId
   * @param {string} url
   */


  const updateUrl = async (tabId, url) => {
    if (tabId === 0) {
      return;
    }

    try {
      await extension_api_browser/* browser.tabs.update */.X.tabs.update(tabId, {
        url
      });
    } catch (e) {
      log/* log.error */.c.error(new Error(e.message));
    }
  };
  /**
   * True if `browser.tabs.insertCSS` supports `cssOrigin: "user"`.
   */


  let userCSSSupport = true;
  /**
   * Inserts CSS using the `browser.tabs.insertCSS` under the hood.
   * This method always injects CSS using `runAt: document_start`/
   *
   * @param {number} tabId Tab id or null if you want to inject into the active tab
   * @param {number} requestFrameId Target frame id (CSS will be inserted into that frame)
   * @param {number} code CSS code to insert
   */

  const insertCssCode = !extension_api_browser/* browser.tabs.insertCSS */.X.tabs.insertCSS ? undefined : async (tabId, requestFrameId, code) => {
    const injectDetails = {
      code,
      runAt: 'document_start',
      frameId: requestFrameId,
      matchAboutBlank: true
    };

    if (userCSSSupport) {
      // If this is set for not supporting browser, it will throw an error.
      injectDetails.cssOrigin = 'user';
    }

    try {
      await extension_api_browser/* browser.tabs.insertCSS */.X.tabs.insertCSS(tabId, injectDetails);
    } catch (e) {
      // e.message in edge is undefined
      const errorMessage = e.message || e; // Some browsers do not support user css origin // TODO which one?

      if (/\bcssOrigin\b/.test(errorMessage)) {
        userCSSSupport = false;
      }
    }
  };
  /**
   * Executes the specified JS code using `browser.tabs.executeScript` under the hood.
   * This method forces `runAt: document_start`.
   *
   * @param {number} tabId Tab id or null if you want to inject into the active tab
   * @param {requestFrameId} requestFrameId Target frame id (script will be injected into that frame)
   * @param {requestFrameId} code Javascript code to execute
   */

  const executeScriptCode = !extension_api_browser/* browser.tabs.executeScript */.X.tabs.executeScript ? undefined : async (tabId, requestFrameId, code) => {
    try {
      await extension_api_browser/* browser.tabs.executeScript */.X.tabs.executeScript(tabId, {
        code,
        frameId: requestFrameId,
        runAt: 'document_start',
        matchAboutBlank: true
      });
    } catch (e) {
      log/* log.debug */.c.debug(new Error(e.message));
    }
  };
  /**
   * Executes the specified javascript file in the top frame of the specified tab.
   * This method forces `runAt: document_start`.
   *
   * @param {number} tabId Tab id or null if you want to inject into the active tab
   * @param {Object} options
   * @param {string} options.file - Path to the javascript file
   * @param {number} [options.frameId=0] - id of the frame, default to the 0;
   * @param {function} callback Called when the script injection is complete
   */

  const executeScriptFile = !extension_api_browser/* browser.tabs.executeScript */.X.tabs.executeScript ? undefined : async (tabId, options) => {
    const {
      file,
      frameId = 0
    } = options;
    const executeScriptOptions = {
      file,
      runAt: 'document_start'
    }; // Chrome 49 throws an exception if browser.tabs.executeScript is called
    // with a frameId equal to 0

    if (frameId !== 0) {
      executeScriptOptions.frameId = frameId;
    }

    try {
      await extension_api_browser/* browser.tabs.executeScript */.X.tabs.executeScript(tabId, executeScriptOptions);
    } catch (e) {
      log/* log.debug */.c.debug(new Error(e.message));
    }
  };
  return {
    onCreated: onCreatedChannel,
    onRemoved: onRemovedChannel,
    onUpdated: onUpdatedChannel,
    onActivated: onActivatedChannel,
    create,
    remove,
    activate,
    reload,
    sendMessage,
    getAll,
    getActive,
    get,
    updateUrl,
    insertCssCode,
    executeScriptCode,
    executeScriptFile
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/tabs/tabs-api.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */



const tabsApi = (tabsImpl => {
  const tabs = Object.create(null); // Fired when a tab is created. Note that the tab's URL may not be set at the time
  // this event fired, but you can listen to onUpdated events to be notified when a URL is set.

  const onCreatedChannel = utils.channels.newChannel(); // Fired when a tab is closed.

  const onRemovedChannel = utils.channels.newChannel(); // Fired when a tab is updated.

  const onUpdatedChannel = utils.channels.newChannel(); // Fires when the active tab in a window changes.

  const onActivatedChannel = utils.channels.newChannel();
  /**
   * Saves tab to collection and notify listeners
   * @param aTab
   */

  function onTabCreated(aTab) {
    const tab = tabs[aTab.tabId];

    if (tab) {
      // Tab has been already synchronized
      return;
    }

    tabs[aTab.tabId] = aTab;
    onCreatedChannel.notify(aTab);
  } // Synchronize opened tabs


  (async () => {
    const aTabs = await tabsImpl.getAll();

    for (let i = 0; i < aTabs.length; i += 1) {
      const aTab = aTabs[i];
      tabs[aTab.tabId] = aTab;
    }
  })();

  tabsImpl.onCreated.addListener(onTabCreated);
  tabsImpl.onRemoved.addListener(tabId => {
    const tab = tabs[tabId];

    if (tab) {
      onRemovedChannel.notify(tab);
      delete tabs[tabId];
    }
  });
  tabsImpl.onUpdated.addListener(aTab => {
    const tab = tabs[aTab.tabId];

    if (tab) {
      tab.url = aTab.url;
      tab.title = aTab.title;
      tab.status = aTab.status; // If the tab was updated it means that it wasn't used to send requests in the background

      tab.synthetic = false;
      onUpdatedChannel.notify(tab);
    }
  });
  tabsImpl.onActivated.addListener(tabId => {
    const tab = tabs[tabId];

    if (tab) {
      onActivatedChannel.notify(tab);
    }
  }); // --------- Actions ---------
  // Creates a new tab.

  const create = async details => {
    return tabsImpl.create(details);
  }; // Closes tab.


  const remove = async tabId => {
    return tabsImpl.remove(tabId);
  }; // Activates tab (Also makes tab's window in focus).


  const activate = function (tabId) {
    return tabsImpl.activate(tabId);
  }; // Reloads tab.


  const reload = async (tabId, url) => {
    await tabsImpl.reload(tabId, url);
  }; // Updates tab url


  const updateUrl = (tabId, url) => {
    tabsImpl.updateUrl(tabId, url);
  }; // Sends message to tab


  const sendMessage = function (tabId, message, options) {
    return tabsImpl.sendMessage(tabId, message, options);
  };
  /**
   * Sometimes chrome does not return url and title on tab update events,
   * but returns tabs with urls when tabs are requested by tabs api
   * That is why during getting tabs we sync their urls with actual values
   */


  const syncTabs = (targetTabs, actualTab) => {
    const {
      tabId
    } = actualTab;
    const tab = targetTabs[tabId];

    if (!tab) {
      targetTabs[tabId] = actualTab;
      return actualTab;
    }

    if (!tab.url && actualTab.url) {
      tab.url = actualTab.url;
    }

    if (!tab.title && actualTab.title) {
      tab.title = actualTab.title;
    } // update tab state in the target tabs array


    targetTabs[tabId] = tab;
    return tab;
  }; // Gets all opened tabs


  const getAll = async () => {
    const aTabs = await tabsImpl.getAll();
    const result = [];

    for (let i = 0; i < aTabs.length; i += 1) {
      const aTab = aTabs[i];
      const tab = syncTabs(tabs, aTab);
      result.push(tab);
    }

    return result;
  }; // Calls callback with each tab


  const forEach = function (callback) {
    (async () => {
      const aTabs = await tabsImpl.getAll();

      for (let i = 0; i < aTabs.length; i += 1) {
        const aTab = aTabs[i];
        let tab = tabs[aTab.tabId];

        if (!tab) {
          // Synchronize state
          tabs[aTab.tabId] = aTab;
          tab = aTab;
        }

        callback(tab);
      }
    })();
  }; // Gets active tab


  const getActive = async tabId => {
    if (!tabId) {
      tabId = await tabsImpl.getActive();
    }

    if (!tabId) {
      return null;
    }

    let tab = tabs[tabId];

    if (tab) {
      if (!tab.url || !tab.title) {
        const aTab = await tabsImpl.get(tabId);

        if (aTab) {
          syncTabs(tabs, aTab);
        }
      }

      return tab;
    } // Tab not found in the local state, but we are sure that this tab exists. Sync...
    // TODO[Edge]: Relates to Edge Bug https://github.com/AdguardTeam/AdguardBrowserExtension/issues/481


    tab = await tabsImpl.get(tabId);
    onTabCreated(tab);
    return tab;
  };

  const isIncognito = function (tabId) {
    const tab = tabs[tabId];
    return tab && tab.incognito === true;
  }; // Records tab's frame


  const recordTabFrame = function (tabId, frameId, url, domainName) {
    let tab = tabs[tabId];

    if (!tab && frameId === 0) {
      // Sync tab for that 'onCreated' event was missed.
      // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/481
      tab = {
        tabId,
        url,
        status: 'loading',
        // We mark this tabs as synthetic because actually they may not exists
        synthetic: true
      };
      onTabCreated(tab);
    }

    if (tab) {
      if (!tab.frames) {
        tab.frames = Object.create(null);
      }

      tab.frames[frameId] = {
        url,
        domainName
      };
    }
  };

  const clearTabFrames = function (tabId) {
    const tab = tabs[tabId];

    if (tab) {
      tab.frames = null;
    }
  }; // Gets tab's frame by id


  const getTabFrame = function (tabId, frameId) {
    const tab = tabs[tabId];

    if (tab && tab.frames) {
      return tab.frames[frameId || 0];
    }

    return null;
  };
  /**
   * Checks if the tab is new tab for popup or not
   * May be false positive for FF at least because new tab url in FF is "about:blank" too
   * @param tabId
   * @returns {boolean}
   */


  const isNewPopupTab = tabId => {
    const tab = tabs[tabId];

    if (!tab) {
      return false;
    }

    return !!(tab.url === '' || tab.url === 'about:blank');
  }; // Update tab metadata


  const updateTabMetadata = function (tabId, values) {
    const tab = tabs[tabId];

    if (tab) {
      if (!tab.metadata) {
        tab.metadata = Object.create(null);
      } // eslint-disable-next-line no-restricted-syntax


      for (const key in values) {
        if (values.hasOwnProperty && values.hasOwnProperty(key)) {
          tab.metadata[key] = values[key];
        }
      }
    }
  }; // Gets tab metadata


  const getTabMetadata = (tabId, key) => {
    const tab = tabs[tabId];

    if (tab && tab.metadata) {
      return tab.metadata[key];
    }

    return null;
  };

  const clearTabMetadata = tabId => {
    const tab = tabs[tabId];

    if (tab) {
      tab.metadata = null;
    }
  }; // Injecting resources to tabs


  const {
    insertCssCode
  } = tabsImpl;
  const {
    executeScriptCode
  } = tabsImpl;
  const {
    executeScriptFile
  } = tabsImpl;
  return {
    // Events
    onCreated: onCreatedChannel,
    onRemoved: onRemovedChannel,
    onUpdated: onUpdatedChannel,
    onActivated: onActivatedChannel,
    // Actions
    create,
    remove,
    activate,
    reload,
    sendMessage,
    getAll,
    forEach,
    getActive,
    isIncognito,
    updateUrl,
    // Frames
    recordTabFrame,
    clearTabFrames,
    getTabFrame,
    isNewPopupTab,
    // Other
    updateTabMetadata,
    getTabMetadata,
    clearTabMetadata,
    insertCssCode,
    executeScriptCode,
    executeScriptFile
  };
})(tabsImpl);


;// CONCATENATED MODULE: ./Extension/src/background/utils/browser-utils.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */







const browserUtils = function () {
  /**
   * Extension version (x.x.x)
   * @param version
   * @constructor
   */
  const Version = function (version) {
    this.version = Object.create(null);
    const parts = String(version || '').split('.');

    function parseVersionPart(part) {
      if (Number.isNaN(part)) {
        return 0;
      }

      return Math.max(part - 0, 0);
    }

    for (let i = 3; i >= 0; i -= 1) {
      this.version[i] = parseVersionPart(parts[i]);
    }
  };
  /**
   * Compares with other version
   * @param o
   * @returns {number}
   */


  Version.prototype.compare = function (o) {
    for (let i = 0; i < 4; i += 1) {
      if (this.version[i] > o.version[i]) {
        return 1;
      }

      if (this.version[i] < o.version[i]) {
        return -1;
      }
    }

    return 0;
  };

  const browserUtils = {
    getClientId() {
      let clientId = storage_localStorage.getItem('client-id');

      if (!clientId) {
        const result = [];
        const suffix = Date.now() % 1e8;
        const symbols = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890';

        for (let i = 0; i < 8; i += 1) {
          const symbol = symbols[Math.floor(Math.random() * symbols.length)];
          result.push(symbol);
        }

        clientId = result.join('') + suffix;
        storage_localStorage.setItem('client-id', clientId);
      }

      return clientId;
    },

    /**
     * Checks if version matches simple (without labels) semantic versioning scheme
     * https://semver.org/
     * @param {string} version
     * @return {boolean}
     */
    isSemver(version) {
      const semverRegex = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)$/;
      return semverRegex.test(version);
    },

    /**
     * Checks if left version is greater than the right version
     */
    isGreaterVersion(leftVersion, rightVersion) {
      const left = new Version(leftVersion);
      const right = new Version(rightVersion);
      return left.compare(right) > 0;
    },

    isGreaterOrEqualsVersion(leftVersion, rightVersion) {
      const left = new Version(leftVersion);
      const right = new Version(rightVersion);
      return left.compare(right) >= 0;
    },

    /**
     * Returns major number of version
     *
     * @param version
     */
    getMajorVersionNumber(version) {
      const v = new Version(version);
      return v.version[0];
    },

    /**
     * Returns minor number of version
     *
     * @param version
     */
    getMinorVersionNumber(version) {
      const v = new Version(version);
      return v.version[1];
    },

    /**
     * @returns Extension version
     */
    getAppVersion() {
      return storage_localStorage.getItem('app-version');
    },

    setAppVersion(version) {
      storage_localStorage.setItem('app-version', version);
    },

    isYaBrowser() {
      return prefs.browser === 'YaBrowser';
    },

    isOperaBrowser() {
      return prefs.browser === 'Opera';
    },

    isEdgeBrowser() {
      return prefs.browser === 'Edge';
    },

    isEdgeChromiumBrowser() {
      return prefs.browser === 'EdgeChromium';
    },

    isFirefoxBrowser() {
      return prefs.browser === 'Firefox';
    },

    isChromeBrowser() {
      return prefs.browser === 'Chrome';
    },

    isChromium() {
      return prefs.platform === 'chromium';
    },

    isWindowsOs() {
      return user_agent_utils/* isWindowsOs */.CA;
    },

    isMacOs() {
      return user_agent_utils/* isMacOs */.Q5;
    },

    /**
     * Finds header object by header name (case insensitive)
     * @param headers Headers collection
     * @param headerName Header name
     * @returns {*}
     */
    findHeaderByName(headers, headerName) {
      if (headers) {
        for (let i = 0; i < headers.length; i += 1) {
          const header = headers[i];

          if (header.name.toLowerCase() === headerName.toLowerCase()) {
            return header;
          }
        }
      }

      return null;
    },

    /**
     * Finds header value by name (case insensitive)
     * @param headers Headers collection
     * @param headerName Header name
     * @returns {null}
     */
    getHeaderValueByName(headers, headerName) {
      const header = this.findHeaderByName(headers, headerName);
      return header ? header.value : null;
    },

    /**
     * Set header value. Only for Chrome
     * @param headers
     * @param headerName
     * @param headerValue
     */
    setHeaderValue(headers, headerName, headerValue) {
      if (!headers) {
        headers = [];
      }

      const header = this.findHeaderByName(headers, headerName);

      if (header) {
        header.value = headerValue;
      } else {
        headers.push({
          name: headerName,
          value: headerValue
        });
      }

      return headers;
    },

    /**
     * Removes header from headers by name
     *
     * @param {Array} headers
     * @param {String} headerName
     * @return {boolean} True if header were removed
     */
    removeHeader(headers, headerName) {
      let removed = false;

      if (headers) {
        for (let i = headers.length - 1; i >= 0; i -= 1) {
          const header = headers[i];

          if (header.name.toLowerCase() === headerName.toLowerCase()) {
            headers.splice(i, 1);
            removed = true;
          }
        }
      }

      return removed;
    },

    getSafebrowsingBackUrl(tab) {
      // https://code.google.com/p/chromium/issues/detail?id=11854
      const previousUrl = tabsApi.getTabMetadata(tab.tabId, 'previousUrl');

      if (previousUrl && previousUrl.indexOf('http') === 0) {
        return previousUrl;
      }

      const referrerUrl = tabsApi.getTabMetadata(tab.tabId, 'referrerUrl');

      if (referrerUrl && referrerUrl.indexOf('http') === 0) {
        return referrerUrl;
      }

      return 'about:newtab';
    },

    /**
     * Retrieve languages from navigator
     * @param {number} [limit] Limit of preferred languages
     * @returns {Array}
     */
    getNavigatorLanguages(limit) {
      let languages = []; // https://developer.mozilla.org/ru/docs/Web/API/NavigatorLanguage/languages

      if (collections.isArray(navigator.languages)) {
        // get all languages if 'limit' is not specified
        const langLimit = limit || navigator.languages.length;
        languages = navigator.languages.slice(0, langLimit);
      } else if (navigator.language) {
        languages.push(navigator.language); // .language is first in .languages
      }

      return languages;
    },

    /**
     * Affected issues:
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/602
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/566
     * 'Popup' window
     * Creators update is not yet released, so we use Insider build 15063 instead.
     */
    EDGE_CREATORS_UPDATE: 15063,

    isEdgeBeforeCreatorsUpdate() {
      return this.isEdgeBrowser() && prefs.edgeVersion.build < this.EDGE_CREATORS_UPDATE;
    },

    /**
     * Returns extension params: clientId, version and locale
     */
    getExtensionParams() {
      const clientId = encodeURIComponent(this.getClientId());
      const locale = encodeURIComponent(backgroundPage.app.getLocale());
      const version = encodeURIComponent(backgroundPage.app.getVersion());
      const id = encodeURIComponent(backgroundPage.app.getId());
      const params = [];
      params.push(`v=${version}`);
      params.push(`cid=${clientId}`);
      params.push(`lang=${locale}`);
      params.push(`id=${id}`);
      return params;
    },

    /**
     * @typedef PermissionsObj
     * A Permissions object represents a collection of permissions
     * https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/permissions/Permissions
     * @property {Array<string>} permissions
     * @property {Array<string>} [origins]
     */

    /**
     * Checks if extension has required permissions
     * @param {PermissionsObj} permissions
     * @returns {Promise<boolean>}
     */
    containsPermissions: permissions => {
      return extension_api_browser/* browser.permissions.contains */.X.permissions.contains(permissions);
    },

    /**
     * Requests required permissions
     * @param {PermissionsObj} permissions
     * @returns {Promise<boolean>}
     */
    requestPermissions: permissions => {
      return extension_api_browser/* browser.permissions.request */.X.permissions.request(permissions);
    },

    /**
     * Removes required permissions
     * @param {PermissionsObj} permissions
     * @returns {Promise<boolean>}
     */
    removePermission: permissions => {
      return extension_api_browser/* browser.permissions.remove */.X.permissions.remove(permissions);
    }
  };
  return browserUtils;
}();
// EXTERNAL MODULE: ./Extension/src/pages/constants.js
var pages_constants = __webpack_require__(32155);
;// CONCATENATED MODULE: ./Extension/src/background/settings/user-settings.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */

/* eslint-disable max-len */








/**
 * Object that manages user settings.
 * @constructor
 */

const settings = (() => {
  const DEFAULT_FILTERS_UPDATE_PERIOD = -1;
  const settings = {
    DISABLE_DETECT_FILTERS: 'detect-filters-disabled',
    DISABLE_SHOW_PAGE_STATS: 'disable-show-page-statistic',

    /* flag used to show link to comparison of desktop and browser adblocker versions */
    DISABLE_SHOW_ADGUARD_PROMO_INFO: 'show-info-about-adguard-disabled',
    DISABLE_SAFEBROWSING: 'safebrowsing-disabled',
    DISABLE_FILTERING: 'adguard-disabled',
    DISABLE_COLLECT_HITS: 'hits-count-disabled',
    DISABLE_SHOW_CONTEXT_MENU: 'context-menu-disabled',
    USE_OPTIMIZED_FILTERS: 'use-optimized-filters',
    DEFAULT_ALLOWLIST_MODE: 'default-whitelist-mode',
    ALLOWLIST_ENABLED: 'allowlist-enabled',
    DISABLE_SHOW_APP_UPDATED_NOTIFICATION: 'show-app-updated-disabled',
    FILTERS_UPDATE_PERIOD: 'filters-update-period',
    APPEARANCE_THEME: 'appearance-theme',

    /* User filter */
    USER_FILTER_ENABLED: 'user-filter-enabled',

    /* STEALTH MODE */
    DISABLE_STEALTH_MODE: 'stealth_disable_stealth_mode',
    HIDE_REFERRER: 'stealth-hide-referrer',
    HIDE_SEARCH_QUERIES: 'stealth-hide-search-queries',
    SEND_DO_NOT_TRACK: 'stealth-send-do-not-track',
    BLOCK_CHROME_CLIENT_DATA: 'stealth-remove-x-client',
    BLOCK_WEBRTC: 'stealth-block-webrtc',
    SELF_DESTRUCT_THIRD_PARTY_COOKIES: 'stealth-block-third-party-cookies',
    SELF_DESTRUCT_THIRD_PARTY_COOKIES_TIME: 'stealth-block-third-party-cookies-time',
    SELF_DESTRUCT_FIRST_PARTY_COOKIES: 'stealth-block-first-party-cookies',
    SELF_DESTRUCT_FIRST_PARTY_COOKIES_TIME: 'stealth-block-first-party-cookies-time',

    /* UI misc */
    HIDE_RATE_BLOCK: 'hide-rate-block',
    USER_RULES_EDITOR_WRAP: 'user-rules-editor-wrap'
  };
  const properties = Object.create(null);
  const propertyUpdateChannel = utils.channels.newChannel();
  /**
   * Lazy default properties
   */

  const defaultProperties = {
    get defaults() {
      return lazyGet(this, 'defaults', () => {
        // Initialize default properties
        const defaults = Object.fromEntries(Object.keys(settings).map(name => [name, false]));
        defaults[settings.DISABLE_SHOW_ADGUARD_PROMO_INFO] = !browserUtils.isWindowsOs() && !browserUtils.isMacOs() || browserUtils.isEdgeBrowser();
        defaults[settings.DISABLE_SAFEBROWSING] = true;
        defaults[settings.DISABLE_COLLECT_HITS] = true;
        defaults[settings.DEFAULT_ALLOWLIST_MODE] = true;
        defaults[settings.ALLOWLIST_ENABLED] = true;
        defaults[settings.USE_OPTIMIZED_FILTERS] = prefs.mobile;
        defaults[settings.DISABLE_DETECT_FILTERS] = false;
        defaults[settings.DISABLE_SHOW_APP_UPDATED_NOTIFICATION] = false;
        defaults[settings.FILTERS_UPDATE_PERIOD] = DEFAULT_FILTERS_UPDATE_PERIOD;
        defaults[settings.DISABLE_STEALTH_MODE] = true;
        defaults[settings.HIDE_REFERRER] = true;
        defaults[settings.HIDE_SEARCH_QUERIES] = true;
        defaults[settings.SEND_DO_NOT_TRACK] = true;
        defaults[settings.BLOCK_CHROME_CLIENT_DATA] = !!browserUtils.isChromeBrowser();
        defaults[settings.BLOCK_WEBRTC] = false;
        defaults[settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES] = true;
        defaults[settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES_TIME] = pages_constants/* DEFAULT_THIRD_PARTY_COOKIES_SELF_DESTRUCT_MIN */.eN;
        defaults[settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES] = false;
        defaults[settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES_TIME] = pages_constants/* DEFAULT_FIRST_PARTY_COOKIES_SELF_DESTRUCT_MIN */.uj;
        defaults[settings.APPEARANCE_THEME] = pages_constants/* APPEARANCE_THEMES.SYSTEM */.cC.SYSTEM;
        defaults[settings.USER_FILTER_ENABLED] = true;
        defaults[settings.HIDE_RATE_BLOCK] = false;
        defaults[settings.USER_RULES_EDITOR_WRAP] = false;
        return defaults;
      });
    }

  };

  const getProperty = function (propertyName) {
    if (propertyName in properties) {
      return properties[propertyName];
    }
    /**
     * Don't cache values in case of uninitialized storage
     */


    if (!storage_localStorage.isInitialized()) {
      return defaultProperties.defaults[propertyName];
    }

    let propertyValue = null;

    if (storage_localStorage.hasItem(propertyName)) {
      try {
        propertyValue = JSON.parse(storage_localStorage.getItem(propertyName));
      } catch (ex) {
        log/* log.error */.c.error('Error get property {0}, cause: {1}', propertyName, ex);
      }
    } else if (propertyName in defaultProperties.defaults) {
      propertyValue = defaultProperties.defaults[propertyName];
    }

    properties[propertyName] = propertyValue;
    return propertyValue;
  };

  const setProperty = (propertyName, propertyValue) => {
    storage_localStorage.setItem(propertyName, JSON.stringify(propertyValue));
    properties[propertyName] = propertyValue;
    propertyUpdateChannel.notify(propertyName, propertyValue);
    listeners.notifyListeners(listeners.SETTING_UPDATED, {
      propertyName,
      propertyValue
    });
  };

  const getAllSettings = function () {
    const result = {
      names: Object.create(null),
      values: Object.create(null),
      defaultValues: Object.create(null)
    };
    Object.entries(settings).forEach(([key, value]) => {
      const setting = settings[key];
      result.names[key] = setting;
      result.values[value] = getProperty(setting);
      result.defaultValues[value] = defaultProperties.defaults[setting];
    });
    return result;
  };
  /**
   * True if filtering is disabled globally.
   *
   * @returns {boolean} true if disabled
   */


  const isFilteringDisabled = function () {
    return getProperty(settings.DISABLE_FILTERING);
  };

  const changeFilteringDisabled = function (disabled) {
    setProperty(settings.DISABLE_FILTERING, disabled);
  };

  const isAutodetectFilters = function () {
    return !getProperty(settings.DISABLE_DETECT_FILTERS);
  };

  const changeAutodetectFilters = function (enabled, options) {
    setProperty(settings.DISABLE_DETECT_FILTERS, !enabled, options);
  };

  const showPageStatistic = function () {
    return !getProperty(settings.DISABLE_SHOW_PAGE_STATS);
  };

  const changeShowPageStatistic = function (enabled, options) {
    setProperty(settings.DISABLE_SHOW_PAGE_STATS, !enabled, options);
  };

  const isShowInfoAboutAdguardFullVersion = function () {
    return !getProperty(settings.DISABLE_SHOW_ADGUARD_PROMO_INFO);
  };

  const changeShowInfoAboutAdguardFullVersion = function (show, options) {
    setProperty(settings.DISABLE_SHOW_ADGUARD_PROMO_INFO, !show, options);
  };

  const isShowAppUpdatedNotification = function () {
    return !getProperty(settings.DISABLE_SHOW_APP_UPDATED_NOTIFICATION);
  };

  const isHideRateBlock = function () {
    return getProperty(settings.HIDE_RATE_BLOCK);
  };

  const isUserRulesEditorWrap = function () {
    return getProperty(settings.USER_RULES_EDITOR_WRAP);
  };

  const changeShowAppUpdatedNotification = function (show, options) {
    setProperty(settings.DISABLE_SHOW_APP_UPDATED_NOTIFICATION, !show, options);
  };

  const changeHideRateBlock = function (hide, options) {
    setProperty(settings.HIDE_RATE_BLOCK, hide, options);
  };

  const changeUserRulesEditorWrap = function (enabled, options) {
    setProperty(settings.USER_RULES_EDITOR_WRAP, enabled, options);
  };

  const changeEnableSafebrowsing = function (enabled, options) {
    setProperty(settings.DISABLE_SAFEBROWSING, !enabled, options);
  };

  const safebrowsingInfoEnabled = function () {
    return !getProperty(settings.DISABLE_SAFEBROWSING);
  };

  const collectHitsCount = function () {
    return !getProperty(settings.DISABLE_COLLECT_HITS);
  };

  const changeCollectHitsCount = function (enabled, options) {
    setProperty(settings.DISABLE_COLLECT_HITS, !enabled, options);
  };

  const showContextMenu = function () {
    return !getProperty(settings.DISABLE_SHOW_CONTEXT_MENU);
  };

  const changeShowContextMenu = function (enabled, options) {
    setProperty(settings.DISABLE_SHOW_CONTEXT_MENU, !enabled, options);
  };

  const isDefaultAllowlistMode = function () {
    return getProperty(settings.DEFAULT_ALLOWLIST_MODE);
  };

  const isUseOptimizedFiltersEnabled = function () {
    return getProperty(settings.USE_OPTIMIZED_FILTERS);
  };

  const changeUseOptimizedFiltersEnabled = function (enabled, options) {
    setProperty(settings.USE_OPTIMIZED_FILTERS, !!enabled, options);
  };

  const changeDefaultAllowlistMode = function (enabled) {
    setProperty(settings.DEFAULT_ALLOWLIST_MODE, enabled);
  };

  const setAllowlistEnabledState = enabled => {
    setProperty(settings.ALLOWLIST_ENABLED, enabled);
  };

  const getAllowlistEnabledState = () => {
    return getProperty(settings.ALLOWLIST_ENABLED);
  };
  /**
   * Sets filters update period after conversion in number
   * @param period
   */


  const setFiltersUpdatePeriod = function (period) {
    let parsed = Number.parseInt(period, 10);

    if (Number.isNaN(parsed)) {
      parsed = DEFAULT_FILTERS_UPDATE_PERIOD;
    }

    setProperty(settings.FILTERS_UPDATE_PERIOD, parsed);
  };
  /**
   * Returns filter update period, converted in number
   * @returns {number}
   */


  const getFiltersUpdatePeriod = function () {
    const value = getProperty(settings.FILTERS_UPDATE_PERIOD);
    let parsed = Number.parseInt(value, 10);

    if (Number.isNaN(parsed)) {
      parsed = DEFAULT_FILTERS_UPDATE_PERIOD;
    }

    return parsed;
  };

  const disableShowAdguardPromoInfo = function () {
    setProperty(settings.DISABLE_SHOW_ADGUARD_PROMO_INFO, true);
  };

  const isDisableShowAdguardPromoInfo = function () {
    return getProperty(settings.DISABLE_SHOW_ADGUARD_PROMO_INFO);
  };

  const getDisableStealthMode = () => getProperty(settings.DISABLE_STEALTH_MODE);

  const getSelfDestructThirdPartyCookies = () => getProperty(settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES);

  const getSelfDestructThirdPartyCookiesTime = () => getProperty(settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES_TIME);

  const getSelfDestructFirstPartyCookies = () => getProperty(settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES);

  const getSelfDestructFirstPartyCookiesTime = () => getProperty(settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES_TIME);

  const getHideReferrer = () => getProperty(settings.HIDE_REFERRER);

  const getHideSearchQueries = () => getProperty(settings.HIDE_SEARCH_QUERIES);

  const getSendDoNotTrack = () => getProperty(settings.SEND_DO_NOT_TRACK);

  const isWebRTCDisabled = () => getProperty(settings.BLOCK_WEBRTC);

  const isRemoveXClientData = () => getProperty(settings.BLOCK_CHROME_CLIENT_DATA);

  const getAppearanceTheme = () => getProperty(settings.APPEARANCE_THEME);

  const setDisableStealthMode = value => {
    setProperty(settings.DISABLE_STEALTH_MODE, value);
  };

  const setSelfDestructThirdPartyCookies = value => {
    setProperty(settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES, value);
  };

  const setSelfDestructThirdPartyCookiesTime = value => {
    setProperty(settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES_TIME, value);
  };

  const setSelfDestructFirstPartyCookies = value => {
    setProperty(settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES, value);
  };

  const setSelfDestructFirstPartyCookiesTime = value => {
    setProperty(settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES_TIME, value);
  };

  const setHideReferrer = value => {
    setProperty(settings.HIDE_REFERRER, value);
  };

  const setHideSearchQueries = value => {
    setProperty(settings.HIDE_SEARCH_QUERIES, value);
  };

  const setSendDoNotTrack = value => {
    setProperty(settings.SEND_DO_NOT_TRACK, value);
  };

  const setWebRTCDisabled = value => {
    setProperty(settings.BLOCK_WEBRTC, value);
  };

  const setRemoveXClientData = value => {
    setProperty(settings.BLOCK_CHROME_CLIENT_DATA, value);
  };

  const setAppearanceTheme = theme => {
    const isExistingTheme = Object.values(pages_constants/* APPEARANCE_THEMES */.cC).some(t => t === theme);

    if (!isExistingTheme) {
      setProperty(settings.APPEARANCE_THEME, defaultProperties.defaults[settings.APPEARANCE_THEME]);
    } else {
      setProperty(settings.APPEARANCE_THEME, theme);
    }
  };

  const getUserFilterEnabled = () => {
    return getProperty(settings.USER_FILTER_ENABLED);
  };

  const setUserFilterEnabled = state => {
    setProperty(settings.USER_FILTER_ENABLED, state);
  };

  const api = { ...settings
  };
  api.getProperty = getProperty;
  api.setProperty = setProperty;
  api.getAllSettings = getAllSettings;
  api.onUpdated = propertyUpdateChannel;
  api.isFilteringDisabled = isFilteringDisabled;
  api.changeFilteringDisabled = changeFilteringDisabled;
  api.isAutodetectFilters = isAutodetectFilters;
  api.changeAutodetectFilters = changeAutodetectFilters;
  api.showPageStatistic = showPageStatistic;
  api.changeShowPageStatistic = changeShowPageStatistic;
  api.isShowInfoAboutAdguardFullVersion = isShowInfoAboutAdguardFullVersion;
  api.changeShowInfoAboutAdguardFullVersion = changeShowInfoAboutAdguardFullVersion;
  api.isShowAppUpdatedNotification = isShowAppUpdatedNotification;
  api.isHideRateBlock = isHideRateBlock;
  api.isUserRulesEditorWrap = isUserRulesEditorWrap;
  api.changeShowAppUpdatedNotification = changeShowAppUpdatedNotification;
  api.changeHideRateBlock = changeHideRateBlock;
  api.changeUserRulesEditorWrap = changeUserRulesEditorWrap;
  api.changeEnableSafebrowsing = changeEnableSafebrowsing;
  api.safebrowsingInfoEnabled = safebrowsingInfoEnabled;
  api.collectHitsCount = collectHitsCount;
  api.changeCollectHitsCount = changeCollectHitsCount;
  api.showContextMenu = showContextMenu;
  api.changeShowContextMenu = changeShowContextMenu;
  api.isDefaultAllowlistMode = isDefaultAllowlistMode;
  api.isUseOptimizedFiltersEnabled = isUseOptimizedFiltersEnabled;
  api.changeUseOptimizedFiltersEnabled = changeUseOptimizedFiltersEnabled;
  api.changeDefaultAllowlistMode = changeDefaultAllowlistMode;
  api.setAllowlistEnabledState = setAllowlistEnabledState;
  api.getAllowlistEnabledState = getAllowlistEnabledState;
  api.getFiltersUpdatePeriod = getFiltersUpdatePeriod;
  api.setFiltersUpdatePeriod = setFiltersUpdatePeriod;
  api.disableShowAdguardPromoInfo = disableShowAdguardPromoInfo;
  api.isDisableShowAdguardPromoInfo = isDisableShowAdguardPromoInfo;
  api.DEFAULT_FILTERS_UPDATE_PERIOD = DEFAULT_FILTERS_UPDATE_PERIOD;
  api.getDisableStealthMode = getDisableStealthMode;
  api.getSelfDestructThirdPartyCookies = getSelfDestructThirdPartyCookies;
  api.getSelfDestructThirdPartyCookiesTime = getSelfDestructThirdPartyCookiesTime;
  api.getSelfDestructFirstPartyCookies = getSelfDestructFirstPartyCookies;
  api.getSelfDestructFirstPartyCookiesTime = getSelfDestructFirstPartyCookiesTime;
  api.getHideReferrer = getHideReferrer;
  api.getHideSearchQueries = getHideSearchQueries;
  api.getSendDoNotTrack = getSendDoNotTrack;
  api.isWebRTCDisabled = isWebRTCDisabled;
  api.isRemoveXClientData = isRemoveXClientData;
  api.setDisableStealthMode = setDisableStealthMode;
  api.setSelfDestructThirdPartyCookies = setSelfDestructThirdPartyCookies;
  api.setSelfDestructThirdPartyCookiesTime = setSelfDestructThirdPartyCookiesTime;
  api.setSelfDestructFirstPartyCookies = setSelfDestructFirstPartyCookies;
  api.setSelfDestructFirstPartyCookiesTime = setSelfDestructFirstPartyCookiesTime;
  api.setHideReferrer = setHideReferrer;
  api.setHideSearchQueries = setHideSearchQueries;
  api.setSendDoNotTrack = setSendDoNotTrack;
  api.setWebRTCDisabled = setWebRTCDisabled;
  api.setRemoveXClientData = setRemoveXClientData; // Appearance mode methods

  api.setAppearanceTheme = setAppearanceTheme;
  api.getAppearanceTheme = getAppearanceTheme; // User filter settings

  api.getUserFilterEnabled = getUserFilterEnabled;
  api.setUserFilterEnabled = setUserFilterEnabled; // Default properties

  api.defaultProperties = defaultProperties.defaults;
  return api;
})();
;// CONCATENATED MODULE: ./Extension/src/background/filter/allowlist.js


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */







/**
 * Read domains and initialize filters in a lazy manner
 */

class DomainsHolder {
  constructor(storageKey) {
    this.storageKey = storageKey;
  }
  /**
   * Retrieves domains from local storage
   * @param prop
   * @returns {string[]}
   */


  static getDomainsFromLocalStorage(prop) {
    let domains = [];

    try {
      const json = storage_localStorage.getItem(prop);

      if (json) {
        domains = JSON.parse(json);
      }
    } catch (ex) {
      log/* log.error */.c.error('Error retrieving the allowlist domains {0}, cause {1}', prop, ex);
    }

    return domains;
  }

  get domains() {
    return lazyGet(this, 'domains', () => {
      return DomainsHolder.getDomainsFromLocalStorage(this.storageKey);
    });
  }

  add(domain) {
    if (this.domains.indexOf(domain) < 0) {
      this.domains.push(domain);
    }
  }

  includes(domain) {
    return this.domains.some(d => {
      return d === domain || utils.url.getCroppedDomainName(d) === domain;
    });
  }

}

const allowlist = (() => {
  const ALLOWLIST_DOMAINS_LS_PROP = 'white-list-domains';
  const BLOCKLIST_DOMAINS_LS_PROP = 'block-list-domains';
  /**
   * Rule which is returned, when allowlist is inverted
   * @type {NetworkRule}
   */

  const allowAllAllowlistRule = new es/* NetworkRule */.nC('@@allowlist-all$document', utils.filters.ALLOWLIST_FILTER_ID);
  /**
   * Returns allowlist mode
   * In default mode the filtering is enabled for all sites
   * In inverted model the filtering is disabled for all sites
   */

  function isDefaultAllowlistMode() {
    return settings.isDefaultAllowlistMode();
  }

  const allowlistDomainsHolder = new DomainsHolder(ALLOWLIST_DOMAINS_LS_PROP);
  const blocklistDomainsHolder = new DomainsHolder(BLOCKLIST_DOMAINS_LS_PROP);

  function notifyAllowlistUpdated() {
    listeners.notifyListeners(listeners.UPDATE_ALLOWLIST_FILTER_RULES);
  }
  /**
   * Create allowlist rule from input text
   * @param domain Domain
   * @returns {*}
   * @private
   */


  function createAllowlistRule(domain) {
    if (utils.strings.isEmpty(domain)) {
      return null;
    }

    return new es/* NetworkRule */.nC(`@@//${domain}$document`, utils.filters.ALLOWLIST_FILTER_ID);
  }
  /**
   * Adds domain to array of allowlist domains
   * @param domain
   */


  function addDomainToAllowlist(domain) {
    if (!domain) {
      return;
    }

    if (isDefaultAllowlistMode()) {
      allowlistDomainsHolder.add(domain);
    } else {
      blocklistDomainsHolder.add(domain);
    }
  }
  /**
   * Remove domain form allowlist domains
   * @param domain
   */


  function removeDomainFromAllowlist(domain) {
    if (!domain) {
      return;
    }
    /**
     * Match domains from collection if they equal exactly do domain
     * and if they equal to domain after removing www
     */


    const predicate = domainFromCollection => {
      return domainFromCollection === domain || utils.url.getCroppedDomainName(domainFromCollection) === domain;
    };

    if (isDefaultAllowlistMode()) {
      utils.collections.removeBy(allowlistDomainsHolder.domains, predicate);
    } else {
      utils.collections.removeBy(blocklistDomainsHolder.domains, predicate);
    }
  }
  /**
   * Save domains to local storage
   */


  function saveDomainsToLocalStorage() {
    storage_localStorage.setItem(ALLOWLIST_DOMAINS_LS_PROP, JSON.stringify(allowlistDomainsHolder.domains));
    storage_localStorage.setItem(BLOCKLIST_DOMAINS_LS_PROP, JSON.stringify(blocklistDomainsHolder.domains));
  }
  /**
   * Remove domain from allowlist
   * @param domain
   */


  function removeFromAllowlist(domain) {
    removeDomainFromAllowlist(domain);
    saveDomainsToLocalStorage();
    notifyAllowlistUpdated();
  }
  /**
   * Adds domain to allowlist
   * @param domain
   */


  function addToAllowlist(domain) {
    if (utils.strings.isEmpty(domain)) {
      return;
    }

    addDomainToAllowlist(domain);
    saveDomainsToLocalStorage();
    notifyAllowlistUpdated();
  }
  /**
   * Search for allowlist rule by url.
   */


  const findAllowlistRule = function (url) {
    if (!url) {
      return null;
    }

    const host = utils.url.getDomainName(url);
    const allowlistEnabled = settings.getAllowlistEnabledState();

    if (isDefaultAllowlistMode()) {
      if (allowlistEnabled && allowlistDomainsHolder.includes(host)) {
        return createAllowlistRule(host);
      }

      return null;
    } // condition for inverted mode


    if (allowlistEnabled && blocklistDomainsHolder.includes(host)) {
      // filtering is enabled on this website
      return null;
    }

    return allowAllAllowlistRule;
  };
  /**
   * Changes allowlist mode
   * @param defaultMode
   */


  const changeDefaultAllowlistMode = function (defaultMode) {
    settings.changeDefaultAllowlistMode(defaultMode);
    notifyAllowlistUpdated();
  };
  /**
   * Stop (or start in case of inverted mode) filtration for url
   * @param url
   */


  const allowlistUrl = function (url) {
    const domain = utils.url.getDomainName(url);

    if (isDefaultAllowlistMode()) {
      addToAllowlist(domain);
    } else {
      removeFromAllowlist(domain);
    }
  };
  /**
   * Start (or stop in case of inverted mode) filtration for url
   * @param url
   */


  const unAllowlistUrl = function (url) {
    const domain = utils.url.getDomainName(url);

    if (isDefaultAllowlistMode()) {
      removeFromAllowlist(domain);
    } else {
      addToAllowlist(domain);
    }
  };
  /**
   * Clear allowlisted only
   */


  const clearAllowlisted = function () {
    storage_localStorage.removeItem(ALLOWLIST_DOMAINS_LS_PROP);
    lazyGetClear(allowlistDomainsHolder, 'domains');
  };
  /**
   * Add domains to allowlist
   * @param domains
   */


  const addAllowlisted = function (domains) {
    if (!domains) {
      return;
    }

    for (let i = 0; i < domains.length; i += 1) {
      const domain = domains[i];
      allowlistDomainsHolder.add(domain);
    }

    saveDomainsToLocalStorage();
  };
  /**
   * Clear blocklisted only
   */


  const clearBlocklisted = function () {
    storage_localStorage.removeItem(BLOCKLIST_DOMAINS_LS_PROP);
    lazyGetClear(blocklistDomainsHolder, 'domains');
  };
  /**
   * Add domains to blocklist
   * @param domains
   */


  const addBlocklisted = function (domains) {
    if (!domains) {
      return;
    }

    for (let i = 0; i < domains.length; i += 1) {
      const domain = domains[i];
      blocklistDomainsHolder.add(domain);
    }

    saveDomainsToLocalStorage();
  };
  /**
   * Updates domains in allowlist
   * @param domains
   */


  const updateAllowlistDomains = function (domains) {
    domains = domains || [];

    if (isDefaultAllowlistMode()) {
      clearAllowlisted();
      addAllowlisted(domains);
    } else {
      clearBlocklisted();
      addBlocklisted(domains);
    }

    notifyAllowlistUpdated();
  };
  /**
   * Configures allowlist service
   * @param allowlist Allowlist domains
   * @param blocklist Blocklist domains
   * @param allowlistMode Allowlist mode
   */


  const configure = function ({
    allowlist,
    blocklist,
    mode,
    enabled
  }) {
    clearAllowlisted();
    clearBlocklisted();
    addAllowlisted(allowlist || []);
    addBlocklisted(blocklist || []);
    settings.changeDefaultAllowlistMode(mode);
    settings.setAllowlistEnabledState(enabled);
    notifyAllowlistUpdated();
  };
  /**
   * Returns the array of allowlist domains
   */


  const getAllowlistDomains = function () {
    if (isDefaultAllowlistMode()) {
      return allowlistDomainsHolder.domains;
    }

    return blocklistDomainsHolder.domains;
  };
  /**
   * Returns the array of allowlisted domains
   */


  const getAllowlistedDomains = function () {
    return allowlistDomainsHolder.domains;
  };
  /**
   * Returns the array of blocklisted domains, inverted mode
   */


  const getBlocklistedDomains = function () {
    return blocklistDomainsHolder.domains;
  };
  /**
   * Initializes allowlist filter
   */


  const init = function () {
    /**
     * Access to allowlist/blacklist domains before the proper initialization of localStorage
     * leads to wrong caching of its values
     * To prevent it we should clear cached values
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/933
     */
    lazyGetClear(allowlistDomainsHolder, 'domains');
    lazyGetClear(blocklistDomainsHolder, 'domains');
  };

  return {
    init,
    configure,
    getAllowlistDomains,
    getAllowlistedDomains,
    getBlocklistedDomains,
    updateAllowlistDomains,
    findAllowlistRule,
    allowlistUrl,
    unAllowlistUrl,
    isDefaultMode: isDefaultAllowlistMode,
    changeDefaultAllowlistMode
  };
})();
// EXTERNAL MODULE: ./node_modules/nanoid/index.browser.js
var index_browser = __webpack_require__(32380);
// EXTERNAL MODULE: ./Extension/src/common/translators/translator.js
var translator = __webpack_require__(99875);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.map.delete-all.js
var esnext_map_delete_all = __webpack_require__(13929);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.map.every.js
var esnext_map_every = __webpack_require__(57851);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.map.filter.js
var esnext_map_filter = __webpack_require__(63633);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.map.find.js
var esnext_map_find = __webpack_require__(81652);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.map.find-key.js
var esnext_map_find_key = __webpack_require__(67515);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.map.includes.js
var esnext_map_includes = __webpack_require__(68034);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.map.key-of.js
var esnext_map_key_of = __webpack_require__(61480);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.map.map-keys.js
var esnext_map_map_keys = __webpack_require__(59027);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.map.map-values.js
var esnext_map_map_values = __webpack_require__(35739);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.map.merge.js
var esnext_map_merge = __webpack_require__(99283);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.map.reduce.js
var esnext_map_reduce = __webpack_require__(4473);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.map.some.js
var esnext_map_some = __webpack_require__(90989);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.map.update.js
var esnext_map_update = __webpack_require__(17194);
;// CONCATENATED MODULE: ./Extension/src/background/filter/userrules.js














/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */






/**
 * Class for manage user rules
 */

const userrules = function () {
  /**
   * Synthetic user filter
   */
  const userFilter = {
    filterId: utils.filters.USER_FILTER_ID
  };
  /**
   * Adds list of rules to the user filter
   *
   * @param rulesText List of rules to add
   */

  const addRules = function (rulesText) {
    listeners.notifyListeners(listeners.ADD_RULES, userFilter, rulesText);
  };
  /**
   * Removes all user's custom rules
   */


  const clearRules = function () {
    listeners.notifyListeners(listeners.UPDATE_FILTER_RULES, userFilter, []);
  };
  /**
   * Removes user's custom rule
   *
   * @param ruleText Rule text
   */


  const removeRule = function (ruleText) {
    listeners.notifyListeners(listeners.REMOVE_RULE, userFilter, [ruleText]);
  };
  /**
   * Save user rules text to storage
   * @param content Rules text
   */


  const updateUserRulesText = function (content) {
    const lines = content.length > 0 ? content.split(/\n/) : [];
    listeners.notifyListeners(listeners.UPDATE_FILTER_RULES, userFilter, lines);
  };
  /**
   * Loads user rules text from storage
   */


  const getUserRulesText = async function () {
    const rulesText = await rulesStorage.read(utils.filters.USER_FILTER_ID);
    const content = (rulesText || []).join('\n');
    return content;
  };

  const unAllowlistFrame = function (frameInfo) {
    if (frameInfo.frameRule) {
      if (frameInfo.frameRule.filterId === utils.filters.ALLOWLIST_FILTER_ID) {
        allowlist.unAllowlistUrl(frameInfo.url);
      } else {
        removeRule(frameInfo.frameRule.ruleText);
      }
    }
  };
  /**
   * Removes user rules by url
   * @param {string} url
   * @return {Promise<void>}
   */


  const removeRulesByUrl = async url => {
    const userRulesText = await getUserRulesText();
    const userRulesStrings = userRulesText.split('\n');
    const updatedUserRulesText = userRulesStrings.filter(userRuleString => {
      return !es/* RuleSyntaxUtils.isRuleForUrl */.uF.isRuleForUrl(userRuleString, url);
    }).join('\n');
    updateUserRulesText(updatedUserRulesText);
  };
  /**
   * Checks if user rules have rules matching by url
   * @param {string} url
   * @return {Promise<boolean>}
   */


  const hasRulesForUrl = async url => {
    const userRulesText = await getUserRulesText();
    const userRulesStrings = userRulesText.split('\n');
    return userRulesStrings.some(userRuleString => es/* RuleSyntaxUtils.isRuleForUrl */.uF.isRuleForUrl(userRuleString, url));
  };
  /**
   * Map rules conversion result
   * key is a result,
   * value is a source rule
   *
   * @type {Map<String, String>}
   */


  const conversionMap = new Map();
  /**
   * Converts rules text lines with conversion map
   *
   * @param rulesLines
   * @return {[String]}
   */

  const convertRules = rulesLines => {
    conversionMap.clear();
    const result = [];

    for (let i = 0; i < rulesLines.length; i += 1) {
      const line = rulesLines[i];
      let converted = [];

      try {
        converted = es/* RuleConverter.convertRule */.cR.convertRule(line);
      } catch (e) {
        log/* log.info */.c.info(`Error converting rule ${line}, due to: ${e.message}`);
      }

      result.push(...converted);

      if (converted.length > 0) {
        if (converted.length > 1 || converted[0] !== line) {
          // Fill the map only for converted rules
          converted.forEach(x => {
            conversionMap.set(x, line);
          });
        }
      }
    }

    log/* log.debug */.c.debug('Converted {0} rules to {1} for user filter', rulesLines.length, result.length);
    return result;
  };
  /**
   * Returns source rule text if the rule has been converted
   *
   * @param ruleText
   * @return {String}
   */


  const getSourceRule = ruleText => {
    return conversionMap.get(ruleText);
  };

  return {
    addRules,
    clearRules,
    removeRule,
    updateUserRulesText,
    getUserRulesText,
    unAllowlistFrame,
    removeRulesByUrl,
    hasRulesForUrl,
    convertRules,
    getSourceRule
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/filter/filtering-log/filtering-log.browsers.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */











/**
 * Object for log http requests
 */

const browsersFilteringLog = function () {
  const REQUESTS_SIZE_PER_TAB = 1000;
  const backgroundTabId = BACKGROUND_TAB_ID;
  const backgroundTab = {
    tabId: backgroundTabId,
    title: translator/* translator.getMessage */.O.getMessage('background_tab_title')
  };
  const tabsInfoMap = Object.create(null);
  let openedFilteringLogsPage = 0;
  /**
   * Keep preserve log state on background page
   * @type {boolean}
   */

  let preserveLogEnabled = false; // Force to add background tab if it's defined

  if (prefs.features.hasBackgroundTab) {
    tabsInfoMap[backgroundTabId] = backgroundTab;
  }
  /**
   * Checks if filtering log page is open
   * @return {boolean}
   */


  const isOpen = function () {
    return openedFilteringLogsPage > 0;
  };
  /**
   * We collect filtering events if opened at least one page of log
   */


  const onOpenFilteringLogPage = function () {
    openedFilteringLogsPage += 1;
  };
  /**
   * Cleanup when last page of log closes
   */


  const onCloseFilteringLogPage = function () {
    openedFilteringLogsPage = Math.max(openedFilteringLogsPage - 1, 0);

    if (openedFilteringLogsPage === 0) {
      // Clear events
      Object.keys(tabsInfoMap).forEach(tabId => {
        const tabInfo = tabsInfoMap[tabId];
        delete tabInfo.filteringEvents;
      });
    }
  };
  /**
   * Get filtering info for tab
   * @param tabId
   */


  const getFilteringInfoByTabId = tabId => {
    return tabsInfoMap[tabId];
  };
  /**
   * Updates tab info (title and url)
   * @param tab
   */


  const updateTabInfo = tab => {
    const tabInfo = tabsInfoMap[tab.tabId] || Object.create(null);
    tabInfo.tabId = tab.tabId;
    tabInfo.title = tab.title;
    tabInfo.isExtensionTab = tab.url && tab.url.indexOf(backgroundPage.app.getExtensionUrl()) === 0;
    tabsInfoMap[tab.tabId] = tabInfo;
    return tabInfo;
  };
  /**
   * Adds tab
   * @param tab
   */


  const addTab = tab => {
    // Background tab can't be added
    // Synthetic tabs are used to send initial requests from new tab in chrome
    if (tab.tabId === backgroundTabId || tab.synthetic) {
      return;
    }

    const tabInfo = updateTabInfo(tab);

    if (tabInfo) {
      listeners.notifyListeners(listeners.TAB_ADDED, tabInfo);
    }
  };
  /**
   * Removes tab
   * @param tabId
   */


  const removeTabById = tabId => {
    // Background tab can't be removed
    if (tabId === backgroundTabId) {
      return;
    }

    const tabInfo = tabsInfoMap[tabId];

    if (tabInfo) {
      listeners.notifyListeners(listeners.TAB_CLOSE, tabInfo);
    }

    delete tabsInfoMap[tabId];
  };
  /**
   * Updates tab
   * @param tab
   */


  const updateTab = tab => {
    // Background tab can't be updated
    if (tab.tabId === backgroundTabId) {
      return;
    }

    const tabInfo = updateTabInfo(tab);

    if (tabInfo) {
      listeners.notifyListeners(listeners.TAB_UPDATE, tabInfo);
    }
  };
  /**
   * Copy some properties from source rule to destination rule
   * @param destinationRuleDTO
   * @param sourceRule
   */


  const copyRuleProperties = (destinationRuleDTO, sourceRule) => {
    if (!destinationRuleDTO || !sourceRule) {
      return;
    }

    destinationRuleDTO.filterId = sourceRule.getFilterListId();
    destinationRuleDTO.ruleText = sourceRule.getText();

    if (sourceRule instanceof es/* NetworkRule */.nC) {
      if (sourceRule.isOptionEnabled(es/* NetworkRuleOption.Important */.SJ.Important)) {
        destinationRuleDTO.isImportant = true;
      }

      if (sourceRule.isDocumentLevelAllowlistRule()) {
        destinationRuleDTO.documentLevelRule = true;
      }

      if (sourceRule.getFilterListId() === constants/* ANTIBANNER_FILTERS_ID.STEALTH_MODE_FILTER_ID */.gu.STEALTH_MODE_FILTER_ID) {
        destinationRuleDTO.isStealthModeRule = true;
      }

      destinationRuleDTO.allowlistRule = sourceRule.isAllowlist();
      destinationRuleDTO.cspRule = sourceRule.isOptionEnabled(es/* NetworkRuleOption.Csp */.SJ.Csp);
      destinationRuleDTO.modifierValue = sourceRule.getAdvancedModifierValue();
      destinationRuleDTO.cookieRule = sourceRule.isOptionEnabled(es/* NetworkRuleOption.Cookie */.SJ.Cookie);
    } else if (sourceRule instanceof es/* CosmeticRule */.nR) {
      const ruleType = sourceRule.getType();

      if (ruleType === es/* CosmeticRuleType.Html */.Az.Html) {
        destinationRuleDTO.contentRule = true; // eslint-disable-next-line max-len
      } else if (ruleType === es/* CosmeticRuleType.ElementHiding */.Az.ElementHiding || ruleType === es/* CosmeticRuleType.Css */.Az.Css) {
        destinationRuleDTO.cssRule = true;
      } else if (ruleType === es/* CosmeticRuleType.Js */.Az.Js) {
        destinationRuleDTO.scriptRule = true;
      }
    }

    if (sourceRule.getFilterListId() === constants/* ANTIBANNER_FILTERS_ID.USER_FILTER_ID */.gu.USER_FILTER_ID) {
      const originalRule = userrules.getSourceRule(sourceRule.getText());

      if (originalRule) {
        destinationRuleDTO.ruleText = originalRule;
        destinationRuleDTO.appliedRuleText = sourceRule.getText();
      }
    }
  };
  /**
   * Checks if event can be added
   * @param tabId
   */


  const canAddEvent = tabId => {
    if (!isOpen()) {
      return false;
    }

    return !!getFilteringInfoByTabId(tabId);
  };
  /**
   * Writes to filtering event some useful properties from the request rule
   * @param filteringEvent
   * @param rule
   */


  const addRuleToFilteringEvent = (filteringEvent, rule) => {
    if (!rule) {
      return;
    }

    filteringEvent.requestRule = {};
    copyRuleProperties(filteringEvent.requestRule, rule);
  };
  /**
   * Adds filtering event to log
   * @param tabId Tab id
   * @param filteringEvent Event to add
   */


  const pushFilteringEvent = (tabId, filteringEvent) => {
    const tabInfo = getFilteringInfoByTabId(tabId);

    if (!tabInfo) {
      return;
    }

    if (!tabInfo.filteringEvents) {
      tabInfo.filteringEvents = [];
    } // if event doesn't have eventId, generate it manually
    // to manage filtering events on the filtering log page later


    if (!filteringEvent.eventId) {
      filteringEvent.eventId = (0,index_browser/* nanoid */.x0)();
    }

    tabInfo.filteringEvents.push(filteringEvent);

    if (tabInfo.filteringEvents.length > REQUESTS_SIZE_PER_TAB) {
      // don't remove first item, cause it's request to main frame
      tabInfo.filteringEvents.splice(1, 1);
    }

    listeners.notifyListeners(listeners.LOG_EVENT_ADDED, tabInfo, filteringEvent);
  };
  /**
   * Add request to log
   * @param {Object} params - params object
   * @param params.tab
   * @param params.requestUrl
   * @param params.frameUrl
   * @param params.requestType
   * @param params.requestRule
   * @param {number} params.timestamp - Request UTC timestamp
   * @param params.eventId
   */


  const addHttpRequestEvent = function ({
    tab,
    requestUrl,
    frameUrl,
    requestType,
    requestRule,
    timestamp,
    eventId,
    method
  }) {
    if (!canAddEvent(tab.tabId)) {
      return;
    }

    const requestDomain = utils.url.getDomainName(requestUrl);
    const frameDomain = utils.url.getDomainName(frameUrl);
    const filteringEvent = {
      eventId,
      requestUrl,
      requestDomain,
      frameUrl,
      frameDomain,
      requestType,
      timestamp,
      requestThirdParty: es/* isThirdPartyRequest */.ag(requestUrl, frameUrl),
      method
    };
    addRuleToFilteringEvent(filteringEvent, requestRule);
    pushFilteringEvent(tab.tabId, filteringEvent);
  };
  /**
   * Add event to log with the corresponding rule
   * @param {Object} params - params object
   * @param {{tabId: Number}} params.tab - Tab object with one of properties tabId
   * @param {(string|Element)} params.element - String presentation of element or NodeElement
   * @param {String} papams.frameUrl - Frame url
   * @param {String} params.requestType - Request type
   * @param {number} params.timestamp - Request UTC timestamp
   * @param {{ruleText: String, filterId: Number, isInjectRule: Boolean}} params.requestRule - Request rule
   */


  const addCosmeticEvent = function ({
    tab,
    element,
    frameUrl,
    requestType,
    timestamp,
    requestRule
  }) {
    if (!requestRule || !canAddEvent(tab.tabId)) {
      return;
    }

    const frameDomain = utils.url.getDomainName(frameUrl);
    const filteringEvent = {
      element: typeof element === 'string' ? element : utils.strings.elementToString(element),
      frameUrl,
      frameDomain,
      requestType,
      timestamp
    };
    addRuleToFilteringEvent(filteringEvent, requestRule);
    pushFilteringEvent(tab.tabId, filteringEvent);
  };
  /**
   * Add script event to log with the corresponding rule
   * @param {Object} params - params object
   * @param {{tabId: Number}} params.tab - Tab object with one of properties tabId
   * @param {String} params.frameUrl - Frame url
   * @param {String} params.requestType - Request type
   * @param {Object} params.rule - script rule
   * @param {number} params.timestamp - Request UTC timestamp
   */


  const addScriptInjectionEvent = ({
    tab,
    frameUrl,
    requestType,
    rule,
    timestamp
  }) => {
    if (!rule || !canAddEvent(tab.tabId)) {
      return;
    }

    const frameDomain = utils.url.getDomainName(frameUrl);
    const filteringEvent = {
      script: true,
      requestUrl: frameUrl,
      frameUrl,
      frameDomain,
      requestType,
      timestamp
    };
    addRuleToFilteringEvent(filteringEvent, rule);
    pushFilteringEvent(tab.tabId, filteringEvent);
  };
  /**
   * Adds remove query parameters event to log with the corresponding rule
   *
   * @param {Object} params - params object
   * @param {{tabId: Number}} params.tab - Tab object with one of properties tabId
   * @param {String} params.frameUrl - Frame url
   * @param {String} params.requestType - Request type
   * @param {Object} params.rule - removeparam rule
   * @param {number} params.timestamp - Request UTC timestamp
   */


  const addRemoveParamEvent = ({
    tab,
    frameUrl,
    requestType,
    rule,
    timestamp
  }) => {
    if (!rule || !canAddEvent(tab.tabId)) {
      return;
    }

    const frameDomain = utils.url.getDomainName(frameUrl);
    const filteringEvent = {
      removeParam: true,
      requestUrl: frameUrl,
      frameUrl,
      frameDomain,
      requestType,
      timestamp
    };
    addRuleToFilteringEvent(filteringEvent, rule);
    pushFilteringEvent(tab.tabId, filteringEvent);
  };
  /**
   * Adds removed header event
   *
   * @param tabId
   * @param frameUrl
   * @param headerName
   * @param rule
   */


  const addRemoveHeaderEvent = (tabId, frameUrl, headerName, rule) => {
    if (!rule || !canAddEvent(tabId)) {
      return;
    }

    const frameDomain = utils.url.getDomainName(frameUrl);
    const filteringEvent = {
      removeHeader: true,
      headerName,
      requestUrl: frameUrl,
      frameUrl,
      frameDomain,
      requestType: request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT,
      timestamp: Date.now()
    };
    addRuleToFilteringEvent(filteringEvent, rule);
    pushFilteringEvent(tabId, filteringEvent);
  };
  /**
   * Writes to filtering event some useful properties from the replace rules
   * @param filteringEvent
   * @param replaceRules
   */


  const addReplaceRulesToFilteringEvent = (filteringEvent, replaceRules) => {
    // only replace rules can be applied together
    filteringEvent.requestRule = {};
    filteringEvent.requestRule.replaceRule = true;
    filteringEvent.replaceRules = [];
    replaceRules.forEach(replaceRule => {
      const ruleDTO = {};
      copyRuleProperties(ruleDTO, replaceRule);
      filteringEvent.replaceRules.push(ruleDTO);
    });
  };

  const isExistingCookieEvent = ({
    tabId,
    cookieName,
    cookieValue,
    cookieDomain
  }) => {
    const tabInfo = getFilteringInfoByTabId(tabId);
    const filteringEvents = tabInfo === null || tabInfo === void 0 ? void 0 : tabInfo.filteringEvents;

    if (!filteringEvents) {
      return false;
    }

    return filteringEvents.some(event => {
      return event.frameDomain === cookieDomain && event.cookieName === cookieName && event.cookieValue === cookieValue;
    });
  };
  /**
   * Adds cookie rule event
   *
   * @param {Object} params - params object
   * @param {Object} params.tabId
   * @param {string} params.cookieName
   * @param {string} params.cookieValue
   * @param {string} params.cookieDomain
   * @param {object} params.cookieRule
   * @param {boolean} params.isModifyingCookieRule
   * @param {boolean} params.thirdParty
   * @param {number} params.timestamp - Request UTC timestamp
   */


  const addCookieEvent = ({
    tabId,
    cookieName,
    cookieValue,
    cookieDomain,
    cookieRule,
    isModifyingCookieRule,
    thirdParty,
    timestamp
  }) => {
    if (!canAddEvent(tabId)) {
      return;
    }

    if (isExistingCookieEvent({
      tabId,
      cookieName,
      cookieValue,
      cookieDomain
    })) {
      return;
    }

    const filteringEvent = {
      frameDomain: cookieDomain,
      requestType: request_types/* RequestTypes.COOKIE */.l.COOKIE,
      requestThirdParty: thirdParty,
      cookieName,
      cookieValue,
      timestamp
    };

    if (cookieRule) {
      // Copy useful properties
      addRuleToFilteringEvent(filteringEvent, cookieRule);
      filteringEvent.requestRule.isModifyingCookieRule = isModifyingCookieRule;

      if (cookieRule.stealthActions) {
        filteringEvent.stealthActions = cookieRule.stealthActions;
      }
    }

    pushFilteringEvent(tabId, filteringEvent);
  };
  /**
   * Binds rule to HTTP request
   * @param tab Tab
   * @param requestRule Request rule
   * @param eventId Event identifier
   */


  const bindRuleToHttpRequestEvent = function (tab, requestRule, eventId) {
    if (!canAddEvent(tab.tabId)) {
      return;
    }

    const tabInfo = getFilteringInfoByTabId(tab.tabId);
    const events = tabInfo.filteringEvents;

    if (events) {
      for (let i = events.length - 1; i >= 0; i -= 1) {
        const event = events[i];

        if (event.eventId === eventId) {
          addRuleToFilteringEvent(event, requestRule);
          break;
        }
      }
    }
  };
  /**
   * Replace rules are fired after the event was added
   * We should find event for this rule and update in log UI
   * @param tab
   * @param replaceRules
   * @param eventId
   */


  const bindReplaceRulesToHttpRequestEvent = function (tab, replaceRules, eventId) {
    if (!canAddEvent(tab.tabId)) {
      return;
    }

    const tabInfo = getFilteringInfoByTabId(tab.tabId);
    const events = tabInfo.filteringEvents;

    if (events) {
      for (let i = events.length - 1; i >= 0; i -= 1) {
        const event = events[i];

        if (event.eventId === eventId) {
          addReplaceRulesToFilteringEvent(event, replaceRules);
          break;
        }
      }
    }
  };
  /**
   * Binds applied stealth actions to HTTP request
   *
   * @param {object} tab Request tab
   * @param {number} actions Applied actions
   * @param {number} eventId Event identifier
   */


  const bindStealthActionsToHttpRequestEvent = (tab, actions, eventId) => {
    if (!canAddEvent(tab.tabId)) {
      return;
    }

    const tabInfo = getFilteringInfoByTabId(tab.tabId);
    const events = tabInfo.filteringEvents;

    if (events) {
      for (let i = events.length - 1; i >= 0; i -= 1) {
        const event = events[i];

        if (event.eventId === eventId) {
          event.stealthActions = actions;
          break;
        }
      }
    }
  };
  /**
   * Binds applied cspReportBlocked to HTTP request
   *
   * @param {object} tab Request tab
   * @param {boolean} cspReportBlocked is csp report blocked flag
   * @param {number} eventId Event identifier
   */


  const bindCspReportBlockedToHttpRequestEvent = (tab, cspReportBlocked, eventId) => {
    if (!canAddEvent(tab.tabId)) {
      return;
    }

    const tabInfo = getFilteringInfoByTabId(tab.tabId);
    const events = tabInfo.filteringEvents;

    if (events) {
      for (let i = events.length - 1; i >= 0; i -= 1) {
        const event = events[i];

        if (event.eventId === eventId) {
          event.cspReportBlocked = cspReportBlocked;
          break;
        }
      }
    }
  };
  /**
   * Binds response status code to HTTP request
   *
   * @param {object} tab Request tab
   * @param {number} statusCode Response status code
   * @param {number} eventId Event identifier
   */


  const bindResponseDataToHttpRequestEvent = (tab, statusCode, eventId) => {
    if (!canAddEvent(tab.tabId)) {
      return;
    }

    const tabInfo = getFilteringInfoByTabId(tab.tabId);
    const events = tabInfo.filteringEvents;

    if (events) {
      for (let i = events.length - 1; i >= 0; i -= 1) {
        const event = events[i];

        if (event.eventId === eventId) {
          event.statusCode = statusCode;
          break;
        }
      }
    }
  };
  /**
   * Remove log requests for tab
   * @param {number} tabId
   * @param {boolean} [ignorePreserveLog]
   */


  const clearEventsByTabId = function (tabId, ignorePreserveLog) {
    const tabInfo = tabsInfoMap[tabId];
    const preserveLog = ignorePreserveLog ? false : preserveLogEnabled;

    if (tabInfo && !preserveLog) {
      delete tabInfo.filteringEvents;
      listeners.notifyListeners(listeners.TAB_RESET, tabInfo);
    }
  };
  /**
   * Synchronize currently opened tabs with out state
   */


  const synchronizeOpenTabs = async function () {
    const tabs = await tabsApi.getAll(); // As Object.keys() returns strings we convert them to integers,
    // because tabId is integer in extension API

    const tabIdsToRemove = Object.keys(tabsInfoMap).map(id => parseInt(id, 10));

    for (let i = 0; i < tabs.length; i += 1) {
      const openTab = tabs[i];
      const tabInfo = tabsInfoMap[openTab.tabId];

      if (!tabInfo) {
        // add tab
        addTab(openTab);
      } else {
        // update tab
        updateTab(openTab);
      }

      const index = tabIdsToRemove.indexOf(openTab.tabId);

      if (index >= 0) {
        tabIdsToRemove.splice(index, 1);
      }
    }

    for (let j = 0; j < tabIdsToRemove.length; j += 1) {
      removeTabById(tabIdsToRemove[j]);
    }

    const syncTabs = [];
    Object.keys(tabsInfoMap).forEach(tabId => {
      syncTabs.push(tabsInfoMap[tabId]);
    });
    return syncTabs;
  };
  /**
   * Returns info if preserve log is enabled
   * @return {boolean}
   */


  const isPreserveLogEnabled = () => {
    return preserveLogEnabled;
  };
  /**
   * Allows to toggle preserve log state
   * @param enabled
   */


  const setPreserveLogState = enabled => {
    preserveLogEnabled = enabled;
  };
  /**
   * We should synchronize open tabs and add listeners to the tabs after application
   * is initialized. Otherwise updating tabs can return wrong stats values and
   * overwrite them with wrong data
   */


  const init = () => {
    // Initialize filtering log
    synchronizeOpenTabs(); // Bind to tab events

    tabsApi.onCreated.addListener(addTab);
    tabsApi.onUpdated.addListener(updateTab);
    tabsApi.onRemoved.addListener(tab => {
      removeTabById(tab.tabId);
    });
  };

  return {
    synchronizeOpenTabs,
    init,
    getFilteringInfoByTabId,
    addHttpRequestEvent,
    bindRuleToHttpRequestEvent,
    bindReplaceRulesToHttpRequestEvent,
    addCosmeticEvent,
    addCookieEvent,
    addRemoveParamEvent,
    addRemoveHeaderEvent,
    addScriptInjectionEvent,
    bindStealthActionsToHttpRequestEvent,
    bindCspReportBlockedToHttpRequestEvent,
    bindResponseDataToHttpRequestEvent,
    clearEventsByTabId,
    isOpen,
    onOpenFilteringLogPage,
    onCloseFilteringLogPage,
    isPreserveLogEnabled,
    setPreserveLogState
  };
}();

/* harmony default export */ const filtering_log_browsers = (browsersFilteringLog);
;// CONCATENATED MODULE: ./Extension/src/background/filter/filtering-log/index.js
/**
 * !IMPORTANT!
 * './filtering-log.__ABSTRACT_BROWSERS__' is replaced during webpack compilation
 * with NormalModuleReplacementPlugin to proper browser implementation
 * './filtering-log.firefox' or './filtering-log.chrome'
 */


// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.add-all.js
var esnext_set_add_all = __webpack_require__(76063);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.delete-all.js
var esnext_set_delete_all = __webpack_require__(22336);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.difference.js
var esnext_set_difference = __webpack_require__(47226);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.every.js
var esnext_set_every = __webpack_require__(80641);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.filter.js
var esnext_set_filter = __webpack_require__(35299);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.find.js
var esnext_set_find = __webpack_require__(12980);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.intersection.js
var esnext_set_intersection = __webpack_require__(72801);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.is-disjoint-from.js
var esnext_set_is_disjoint_from = __webpack_require__(67396);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.is-subset-of.js
var esnext_set_is_subset_of = __webpack_require__(26600);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.is-superset-of.js
var esnext_set_is_superset_of = __webpack_require__(59503);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.join.js
var esnext_set_join = __webpack_require__(76119);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.map.js
var esnext_set_map = __webpack_require__(10608);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.reduce.js
var esnext_set_reduce = __webpack_require__(44061);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.some.js
var esnext_set_some = __webpack_require__(42229);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.symmetric-difference.js
var esnext_set_symmetric_difference = __webpack_require__(39055);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.set.union.js
var esnext_set_union = __webpack_require__(3286);
;// CONCATENATED MODULE: ./Extension/src/background/filter/engine.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */





/**
 * TSUrlFilter Engine wrapper
 */

const engine = function () {
  const ASYNC_LOAD_CHUNK_SIZE = 5000;
  let engine;
  /**
   * Do not allow match requests until engine didn't load all rules
   * Otherwise engine can cache empty results for match requests
   * @return {*}
   */

  const isReady = () => {
    return Boolean(engine);
  };

  const startEngine = async lists => {
    log/* log.info */.c.info('Starting url filter engine'); // reset engine instance to avoid cached null values,
    // which may occur if try to get match result before all rules are loaded

    engine = null;
    const ruleStorage = new es/* RuleStorage */.qc(lists);
    const config = {
      engine: 'extension',
      version: backgroundPage.app && backgroundPage.app.getVersion(),
      verbose: true,
      compatibility: es/* CompatibilityTypes.extension */.cC.extension
    };
    es/* setConfiguration */.Dg(config);
    const engineInstance = new es/* Engine */.D4(ruleStorage, true);
    /*
     * UI thread becomes blocked on the options page while request filter is created
     * that's why we create filter rules using chunks of the specified length
     * Request filter creation is rather slow operation so we should
     * use setTimeout calls to give UI thread some time.
    */

    await engineInstance.loadRulesAsync(ASYNC_LOAD_CHUNK_SIZE);
    engine = engineInstance;
    log/* log.info */.c.info('Starting url filter engine..ok');
  };
  /**
   * @typedef {object} MatchQuery - Request Match Query
   *
   * @property {string} requestUrl    Request URL
   * @property {string} frameUrl      Document URL
   * @property {any} requestType      Request content type (one of UrlFilterRule.contentTypes)
   * @property {any} frameRule        Frame rule
  */

  /**
   * Gets matching result for request.
   *
   * @param {MatchQuery} matchQuery - {@link MatchQuery}
   * @returns matching result or null
   */


  const matchRequest = matchQuery => {
    const {
      requestUrl,
      frameUrl,
      requestType
    } = matchQuery;
    let {
      frameRule
    } = matchQuery;
    log/* log.debug */.c.debug('Filtering http request for url: {0}, document: {1}, requestType: {2}', requestUrl, frameUrl, requestType);

    if (!isReady()) {
      log/* log.warn */.c.warn('Filtering engine is not ready');
      return null;
    }

    if (!frameRule) {
      frameRule = null;
    }

    const request = new es/* Request */.cf(requestUrl, frameUrl, request_types/* RequestTypes.transformRequestType */.l.transformRequestType(requestType));
    const result = engine.matchRequest(request, frameRule);
    log/* log.debug */.c.debug('Result {0} found for url: {1}, document: {2}, requestType: {3}', result.getBasicResult(), requestUrl, frameUrl, requestType);
    return result;
  };
  /**
   * Matches current frame url and returns document-level rule if found.
   *
   * @param frameUrl    Frame URL
   * @returns matching result or null
   */


  const matchFrame = frameUrl => {
    if (!isReady()) {
      log/* log.warn */.c.warn('Filtering engine is not ready');
      return null;
    }

    return engine.matchFrame(frameUrl);
  };
  /**
   * Gets cosmetic result for the specified hostname and cosmetic options
   *
   * @param url
   * @param option
   * @returns CosmeticResult result
   */


  const getCosmeticResult = (url, option) => {
    if (!isReady()) {
      return new es/* CosmeticResult */.cT();
    }

    const frameUrl = utils.url.getHost(url);
    const request = new es/* Request */.cf(url, frameUrl, es/* RequestType.Document */.xd.Document);
    return engine.getCosmeticResult(request, option);
  };
  /**
   * @return Engine rules count
   */


  const getRulesCount = () => {
    return isReady() ? engine.getRulesCount() : 0;
  };

  return {
    startEngine,
    getRulesCount,
    isReady,
    matchRequest,
    matchFrame,
    getCosmeticResult
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/filter/rules/local-script-rules/local-script-rules.chrome.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Empty module for chrome
 */
const localScriptRulesService = function () {
  const setLocalScriptRules = function () {// Do nothing
  };

  const isLocal = function () {
    // For chrome all rules are 'local'
    return true;
  };

  return {
    setLocalScriptRules,
    isLocal
  };
}();

/* harmony default export */ const local_script_rules_chrome = (localScriptRulesService);
;// CONCATENATED MODULE: ./Extension/src/background/filter/rules/local-script-rules/index.js
/**
 * !IMPORTANT!
 * './local-script-rules.__ABSTRACT_BROWSERS__' is replaced during webpack compilation
 * with NormalModuleReplacementPlugin to proper browser implementation
 * './local-script-rules.firefox' or './local-script-rules.chrome'
 */


;// CONCATENATED MODULE: ./Extension/src/background/filter/services/css-service.js
/**
 * Class to manage css
 */
const cssService = (() => {
  /**
   * Builds stylesheet from rules
   *
   * @param elemhideRules
   * @param injectRules
   * @param groupElemhideSelectors
   * @return {[]}
   */
  const buildStyleSheet = (elemhideRules, injectRules, groupElemhideSelectors) => {
    const CSS_SELECTORS_PER_LINE = 50;
    const ELEMHIDE_CSS_STYLE = ' { display: none!important; }\r\n';
    const elemhides = [];
    let selectorsCount = 0; // eslint-disable-next-line no-restricted-syntax

    for (const selector of elemhideRules) {
      selectorsCount += 1;
      elemhides.push(selector.getContent());

      if (selectorsCount % CSS_SELECTORS_PER_LINE === 0 || !groupElemhideSelectors) {
        elemhides.push(ELEMHIDE_CSS_STYLE);
      } else {
        elemhides.push(', ');
      }
    }

    if (elemhides.length > 0) {
      // Last element should always be a style (it will replace either a comma or the same style)
      elemhides[elemhides.length - 1] = ELEMHIDE_CSS_STYLE;
    }

    const elemHideStyle = elemhides.join('');
    const cssStyle = injectRules.map(x => x.getContent()).join('\r\n');
    const styles = [];

    if (elemHideStyle) {
      styles.push(elemHideStyle);
    }

    if (cssStyle) {
      styles.push(cssStyle);
    }

    return styles;
  };

  const ELEMHIDE_HIT_START = " { display: none!important; content: 'adguard";
  const INJECT_HIT_START = " content: 'adguard";
  const HIT_SEP = encodeURIComponent(';');
  const HIT_END = "' !important;}\r\n";
  /**
   * Urlencodes rule text.
   *
   * @param ruleText
   * @return {string}
   */

  const escapeRule = ruleText => encodeURIComponent(ruleText).replace(/['()]/g, match => ({
    "'": '%27',
    '(': '%28',
    ')': '%29'
  })[match]);
  /**
   * Patch rule selector adding adguard mark rule info in the content attribute
   * Example:
   * .selector -> .selector { content: 'adguard{filterId};{ruleText} !important;}
   * @param rule
   * @returns {String}
   */


  const addMarkerToElemhideRule = rule => {
    const result = [];
    result.push(rule.getContent());
    result.push(ELEMHIDE_HIT_START);
    result.push(rule.getFilterListId());
    result.push(HIT_SEP);
    result.push(escapeRule(rule.getText()));
    result.push(HIT_END);
    return result.join('');
  };
  /**
   * Patch rule selector adding adguard mark and rule info in the content attribute
   * Example:
   * .selector { color: red } -> .selector { color: red, content: 'adguard{filterId};{ruleText} !important;}
   * @param rule
   * @returns {String}
   */


  const addMarkerToInjectRule = rule => {
    const result = [];
    const ruleContent = rule.getContent(); // if rule text has content attribute we don't add rule marker

    const contentAttributeRegex = /[{;"(]\s*content\s*:/gi;

    if (contentAttributeRegex.test(ruleContent)) {
      return ruleContent;
    } // remove closing brace


    const ruleTextWithoutCloseBrace = ruleContent.slice(0, -1).trim(); // check semicolon

    const ruleTextWithSemicolon = ruleTextWithoutCloseBrace.endsWith(';') ? ruleTextWithoutCloseBrace : `${ruleTextWithoutCloseBrace};`;
    result.push(ruleTextWithSemicolon);
    result.push(INJECT_HIT_START);
    result.push(rule.getFilterListId());
    result.push(HIT_SEP);
    result.push(escapeRule(rule.getText()));
    result.push(HIT_END);
    return result.join('');
  };
  /**
   * Builds stylesheet with css-hits marker
   *
   * @param elemhideRules
   * @param injectRules
   * @return {*[]}
   */


  const buildStyleSheetHits = (elemhideRules, injectRules) => {
    const elemhideStyles = elemhideRules.map(x => addMarkerToElemhideRule(x));
    const injectStyles = injectRules.map(x => addMarkerToInjectRule(x));
    return [...elemhideStyles, ...injectStyles];
  };

  return {
    buildStyleSheet,
    buildStyleSheetHits
  };
})();
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.string.replace-all.js
var esnext_string_replace_all = __webpack_require__(81625);
// EXTERNAL MODULE: ./node_modules/@adguard/filters-downloader/src/index.browser.js
var src_index_browser = __webpack_require__(39317);
var index_browser_default = /*#__PURE__*/__webpack_require__.n(src_index_browser);
;// CONCATENATED MODULE: ./Extension/src/background/filter/filters/service-client.js


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */







/**
 * Class for working with our backend server.
 * All requests sent by this class are covered in the privacy policy:
 * http://adguard.com/en/privacy.html#browsers
 */

const backend = function () {
  /**
   * Settings
   */
  const settings = {
    // Base url of our backend server
    get backendUrl() {
      return 'https://chrome.adtidy.org';
    },

    get apiKey() {
      return '4DDBE80A3DA94D819A00523252FB6380';
    },

    // Url for load filters metadata and rules
    get filtersUrl() {
      return lazyGet(this, 'filtersUrl', () => {
        if (browserUtils.isFirefoxBrowser()) {
          return 'https://filters.adtidy.org/extension/firefox';
        }

        if (browserUtils.isEdgeBrowser()) {
          return 'https://filters.adtidy.org/extension/edge';
        }

        if (browserUtils.isOperaBrowser()) {
          return 'https://filters.adtidy.org/extension/opera';
        }

        return 'https://filters.adtidy.org/extension/chromium';
      });
    },

    // URL for downloading AG filters
    get filterRulesUrl() {
      return `${this.filtersUrl}/filters/{filter_id}.txt`;
    },

    // URL for downloading optimized AG filters
    get optimizedFilterRulesUrl() {
      return `${this.filtersUrl}/filters/{filter_id}_optimized.txt`;
    },

    // URL for checking filter updates
    get filtersMetadataUrl() {
      const params = browserUtils.getExtensionParams();
      return `${this.filtersUrl}/filters.js?${params.join('&')}`;
    },

    // URL for downloading i18n localizations
    get filtersI18nMetadataUrl() {
      const params = browserUtils.getExtensionParams();
      return `${this.filtersUrl}/filters_i18n.json?${params.join('&')}`;
    },

    // URL for user complaints on missed ads or malware/phishing websites
    get reportUrl() {
      return `${this.backendUrl}/url-report.html`;
    },

    /**
     * URL for collecting filter rules statistics.
     * We do not collect it by default, unless user is willing to help.
     *
     * Filter rules stats are covered in our privacy policy and on also here:
     * http://adguard.com/en/filter-rules-statistics.html
     */
    get ruleStatsUrl() {
      return `${this.backendUrl}/rulestats.html`;
    },

    /**
     * Browsing Security lookups. In case of Firefox lookups are disabled for HTTPS urls.
     */
    get safebrowsingLookupUrl() {
      return 'https://sb.adtidy.org/safebrowsing-lookup-short-hash.html';
    },

    // Folder that contains filters metadata and files with rules. 'filters' by default
    get localFiltersFolder() {
      return 'filters';
    },

    // Path to the redirect sources
    get redirectSourcesFolder() {
      return 'assets/libs/scriptlets';
    },

    // Array of filter identifiers, that have local file with rules. Range from 1 to 14 by default
    get localFilterIds() {
      return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14];
    }

  };
  /**
   * FiltersDownloader constants
   */

  const FilterCompilerConditionsConstants = {
    adguard: true,
    adguard_ext_chromium: browserUtils.isChromium(),
    adguard_ext_firefox: browserUtils.isFirefoxBrowser(),
    adguard_ext_edge: browserUtils.isEdgeBrowser(),
    adguard_ext_safari: false,
    adguard_ext_opera: browserUtils.isOperaBrowser()
  };
  /**
   * Loading subscriptions map
   */

  const loadingSubscriptions = Object.create(null);
  /**
   * Executes async request
   * @param url Url
   * @param contentType Content type
   */

  function executeRequestAsync(url, contentType) {
    return new Promise((resolve, reject) => {
      const request = new XMLHttpRequest();

      try {
        request.open('GET', url);
        request.setRequestHeader('Content-type', contentType);
        request.setRequestHeader('Pragma', 'no-cache');
        request.overrideMimeType(contentType);
        request.mozBackgroundRequest = true;

        request.onload = function () {
          resolve(request);
        };

        const errorCallbackWrapper = errorMessage => {
          return e => {
            let errorText = errorMessage;

            if (e !== null && e !== void 0 && e.message) {
              errorText = `${errorText}: ${e === null || e === void 0 ? void 0 : e.message}`;
            }

            const error = new Error(`Error: "${errorText}", statusText: ${request.statusText}`);
            reject(error);
          };
        };

        request.onerror = errorCallbackWrapper('An error occurred');
        request.onabort = errorCallbackWrapper('Request was aborted');
        request.ontimeout = errorCallbackWrapper('Request stopped by timeout');
        request.send(null);
      } catch (ex) {
        reject(ex);
      }
    });
  }
  /**
   * URL for downloading AG filter
   *
   * @param filterId Filter identifier
   * @param useOptimizedFilters
   * @private
   */


  function getUrlForDownloadFilterRules(filterId, useOptimizedFilters) {
    const url = useOptimizedFilters ? settings.optimizedFilterRulesUrl : settings.filterRulesUrl;
    return utils.strings.replaceAll(url, '{filter_id}', filterId);
  }
  /**
   * Appends request key to url
   */


  function addKeyParameter(url) {
    return `${url}&key=${settings.apiKey}`;
  }
  /**
   * Safe json parsing
   * @param text
   * @private
   */


  function parseJson(text) {
    try {
      return JSON.parse(text);
    } catch (ex) {
      log/* log.error */.c.error('Error parse json {0}', ex);
      return null;
    }
  }
  /**
   * Downloads metadata from backend
   * @return {Promise<void>}
   */


  const downloadMetadataFromBackend = async () => {
    const response = await executeRequestAsync(settings.filtersMetadataUrl, 'application/json');

    if (!(response !== null && response !== void 0 && response.responseText)) {
      throw new Error(`Empty response: ${response}`);
    }

    const metadata = parseJson(response.responseText);

    if (!metadata) {
      throw new Error(`Invalid response: ${response}`);
    }

    return metadata;
  };
  /**
   * Downloads i18n metadata from backend
   * @return {Promise<void>}
   */


  const downloadI18nMetadataFromBackend = async () => {
    const response = await executeRequestAsync(settings.filtersI18nMetadataUrl, 'application/json');

    if (!(response !== null && response !== void 0 && response.responseText)) {
      throw new Error(`Empty response: ${response}`);
    }

    const metadata = parseJson(response.responseText);

    if (!metadata) {
      throw new Error(`Invalid response: ${response}`);
    }

    return metadata;
  };
  /**
   * Downloads filter rules by filter ID
   *
   * @param filterId              Filter identifier
   * @param forceRemote           Force download filter rules from remote server
   * @param useOptimizedFilters   Download optimized filters flag
   * @returns {Promise<string>}   Downloaded rules
   */


  const downloadFilterRules = (filterId, forceRemote, useOptimizedFilters) => {
    let url;

    if (forceRemote || settings.localFilterIds.indexOf(filterId) < 0) {
      url = getUrlForDownloadFilterRules(filterId, useOptimizedFilters);
    } else {
      url = backgroundPage.getURL(`${settings.localFiltersFolder}/filter_${filterId}.txt`);

      if (useOptimizedFilters) {
        url = backgroundPage.getURL(`${settings.localFiltersFolder}/filter_mobile_${filterId}.txt`);
      }
    }

    return index_browser_default().download(url, FilterCompilerConditionsConstants);
  };
  /**
   * Downloads filter rules by url
   *
   * @param url - Subscription url
   */


  const downloadFilterRulesBySubscriptionUrl = async url => {
    if (url in loadingSubscriptions) {
      return;
    }

    loadingSubscriptions[url] = true;

    try {
      let lines = await index_browser_default().download(url, FilterCompilerConditionsConstants);
      lines = index_browser_default().resolveConditions(lines, FilterCompilerConditionsConstants);
      delete loadingSubscriptions[url];

      if (lines[0].indexOf('[') === 0) {
        // [Adblock Plus 2.0]
        lines.shift();
      }

      return lines;
    } catch (e) {
      delete loadingSubscriptions[url];
      const message = e instanceof Error ? e.message : e;
      throw new Error(message);
    }
  };

  const createError = (message, url, response) => {
    let errorMessage = `
            error:                    ${message}
            requested url:            ${url}`;

    if (response) {
      errorMessage = `
            error:                    ${message}
            requested url:            ${url}
            request status text:      ${response.statusText}`;
    }

    return new Error(errorMessage);
  };
  /**
   * Loads filter groups metadata
   */


  const getLocalFiltersMetadata = async () => {
    var _response;

    const url = backgroundPage.getURL(`${settings.localFiltersFolder}/filters.json`);
    let response;

    try {
      response = await executeRequestAsync(url, 'application/json');
    } catch (e) {
      const exMessage = (e === null || e === void 0 ? void 0 : e.message) || 'couldn\'t load local filters metadata';
      throw createError(exMessage, url);
    }

    if (!((_response = response) !== null && _response !== void 0 && _response.responseText)) {
      throw createError('empty response', url, response);
    }

    const metadata = parseJson(response.responseText);

    if (!metadata) {
      throw createError('invalid response', url, response);
    }

    return metadata;
  };
  /**
   * Loads filter groups metadata from local file
   * @returns {Promise}
   */


  const getLocalFiltersI18Metadata = async () => {
    var _response2;

    const url = backgroundPage.getURL(`${settings.localFiltersFolder}/filters_i18n.json`);
    let response;

    try {
      response = await executeRequestAsync(url, 'application/json');
    } catch (e) {
      const exMessage = (e === null || e === void 0 ? void 0 : e.message) || 'couldn\'t load local filters i18n metadata';
      throw createError(exMessage, url);
    }

    if (!((_response2 = response) !== null && _response2 !== void 0 && _response2.responseText)) {
      throw createError('empty response', url, response);
    }

    const metadata = parseJson(response.responseText);

    if (!metadata) {
      throw createError('invalid response', url, response);
    }

    return metadata;
  };
  /**
   * Loads script rules from local file
   * @returns {Promise}
   */


  const getLocalScriptRules = async () => {
    var _response3;

    const url = backgroundPage.getURL(`${settings.localFiltersFolder}/local_script_rules.json`);
    let response;

    try {
      response = await executeRequestAsync(url, 'application/json');
    } catch (e) {
      const exMessage = (e === null || e === void 0 ? void 0 : e.message) || 'couldn\'t load local script rules';
      throw createError(exMessage, url);
    }

    if (!((_response3 = response) !== null && _response3 !== void 0 && _response3.responseText)) {
      throw createError('empty response', url, response);
    }

    const metadata = parseJson(response.responseText);

    if (!metadata) {
      throw createError('invalid response', url, response);
    }

    return metadata;
  }; // TODO check necessity of this module,
  //  as we already have redirect sources in the webaccessible-resources folder

  /**
   * Loads redirect sources from local file
   * @returns {Promise}
   */


  const getRedirectSources = async () => {
    var _response4;

    const url = `${backgroundPage.getURL(settings.redirectSourcesFolder)}/redirects.yml`;
    let response;

    try {
      response = await executeRequestAsync(url, 'application/x-yaml');
    } catch (e) {
      const exMessage = (e === null || e === void 0 ? void 0 : e.message) || 'couldn\'t load redirect sources';
      throw createError(exMessage, url);
    }

    if (!((_response4 = response) !== null && _response4 !== void 0 && _response4.responseText)) {
      throw createError('empty response', url, response);
    }

    return response.responseText;
  };
  /**
   * Checks specified host hashes with our safebrowsing service
   *
   * @param hashes                Host hashes
   */


  const lookupSafebrowsing = async function (hashes) {
    const url = `${settings.safebrowsingLookupUrl}?prefixes=${encodeURIComponent(hashes.join('/'))}`;
    const response = await executeRequestAsync(url, 'application/json');
    return response;
  };
  /**
   * Sends feedback from the user to our server
   *
   * @param url           URL
   * @param messageType   Message type
   * @param comment       Message text
   */


  const sendUrlReport = function (url, messageType, comment) {
    let params = `url=${encodeURIComponent(url)}`;
    params += `&messageType=${encodeURIComponent(messageType)}`;

    if (comment) {
      params += `&comment=${encodeURIComponent(comment)}`;
    }

    params = addKeyParameter(params);
    const request = new XMLHttpRequest();
    request.open('POST', settings.reportUrl);
    request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    request.send(params);
  };
  /**
   * Sends filter hits stats to backend server.
   * This method is used if user has enabled "Send statistics for ad filters usage".
   * More information about ad filters usage stats:
   * http://adguard.com/en/filter-rules-statistics.html
   *
   * @param stats             Stats
   * @param enabledFilters    List of enabled filters
   */


  const sendHitStats = function (stats, enabledFilters) {
    let params = `stats=${encodeURIComponent(stats)}`;
    params += `&v=${encodeURIComponent(backgroundPage.app.getVersion())}`;
    params += `&b=${encodeURIComponent(prefs.browser)}`;

    if (enabledFilters) {
      for (let i = 0; i < enabledFilters.length; i += 1) {
        const filter = enabledFilters[i];
        params += `&f=${encodeURIComponent(`${filter.filterId},${filter.version}`)}`;
      }
    }

    params = addKeyParameter(params);
    const request = new XMLHttpRequest();
    request.open('POST', settings.ruleStatsUrl);
    request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    request.send(params);
  };
  /**
   * Configures backend's URLs
   * @param configuration Configuration object:
   * {
   *  filtersMetadataUrl: '...',
   *  filterRulesUrl: '...',
   *  localFiltersFolder: '...',
   *  localFilterIds: []
   * }
   */


  const configure = function (configuration) {
    const {
      filtersMetadataUrl
    } = configuration;

    if (filtersMetadataUrl) {
      Object.defineProperty(settings, 'filtersMetadataUrl', {
        get() {
          return filtersMetadataUrl;
        }

      });
    }

    const {
      filterRulesUrl
    } = configuration;

    if (filterRulesUrl) {
      Object.defineProperty(settings, 'filterRulesUrl', {
        get() {
          return filterRulesUrl;
        }

      });
    }

    const {
      localFiltersFolder
    } = configuration;

    if (localFiltersFolder) {
      Object.defineProperty(settings, 'localFiltersFolder', {
        get() {
          return localFiltersFolder;
        }

      });
    }

    const {
      redirectSourcesFolder
    } = configuration;

    if (redirectSourcesFolder) {
      Object.defineProperty(settings, 'redirectSourcesFolder', {
        get() {
          return redirectSourcesFolder;
        }

      });
    }

    const {
      localFilterIds
    } = configuration;

    if (localFilterIds) {
      Object.defineProperty(settings, 'localFilterIds', {
        get() {
          return localFilterIds;
        }

      });
    }
  };

  return {
    downloadFilterRules,
    downloadFilterRulesBySubscriptionUrl,
    getLocalFiltersMetadata,
    getLocalFiltersI18Metadata,
    getLocalScriptRules,
    getRedirectSources,
    downloadMetadataFromBackend,
    downloadI18nMetadataFromBackend,
    lookupSafebrowsing,
    sendUrlReport,
    sendHitStats,
    configure
  };
}();
// EXTERNAL MODULE: ./node_modules/@adguard/scriptlets/dist/umd/scriptlets.umd.js
var scriptlets_umd = __webpack_require__(68782);
// EXTERNAL MODULE: ./node_modules/lru_map/dist/lru.js
var lru = __webpack_require__(87553);
;// CONCATENATED MODULE: ./Extension/src/background/utils/redirects-cache.js

/**
 * Used for new type of redirects, i.e. click2load.html
 */

const redirectsCache = function () {
  const cache = new lru.LRUMap(100);

  const add = url => cache.set(url, true);

  const hasUrl = url => cache.has(url);

  return {
    add,
    hasUrl
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/utils/redirects-tokens-cache.js


/**
 * Used for new type of redirects, i.e. click2load.html
 */

const redirectsTokensCache = function () {
  const cache = new lru.LRUMap(1000);
  /**
   * Generates random unblock token for url and saves it to cache.
   * Used while redirect creating in createRedirectFileUrl()
   * @returns {string} token
   */

  const generateToken = () => {
    const token = (0,index_browser/* nanoid */.x0)();
    cache.set(token, true);
    return token;
  };
  /**
   * Checks whether token exist in cache.
   * Used while redirect checking in getBlockedResponseByRule()
   * @param {string} token
   * @returns {boolean}
   */


  const hasToken = token => cache.has(token);

  return {
    generateToken,
    hasToken
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/utils/resources.js


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */




/**
 * Web accessible resources helper
 */

const resources = function () {
  /**
   * Resources directory
   *
   * @type {string}
   */
  const WEB_ACCESSIBLE_RESOURCES = 'web-accessible-resources';
  /**
   * Foil ability of web pages to identify extension through its web accessible resources.
   *
   * Inspired by:
   * https://github.com/gorhill/uBlock/blob/7f999b7/platform/chromium/vapi-background.js
   */

  const warSecret = (() => {
    const root = extension_api_browser/* browser.runtime.getURL */.X.runtime.getURL('/');
    const secrets = [];
    let lastSecretTime = 0; // eslint-disable-next-line consistent-return

    const guard = function (details) {
      const {
        url
      } = details;
      const pos = secrets.findIndex(secret => url.lastIndexOf(`?secret=${secret}`) !== -1);

      if (pos === -1) {
        return {
          redirectUrl: root
        };
      }

      secrets.splice(pos, 1);
    };

    extension_api_browser/* browser.webRequest.onBeforeRequest.addListener */.X.webRequest.onBeforeRequest.addListener(guard, {
      urls: [`${root}${WEB_ACCESSIBLE_RESOURCES}/*`]
    }, ['blocking']);
    return () => {
      if (secrets.length !== 0) {
        if (Date.now() - lastSecretTime > 5000) {
          secrets.splice(0);
        } else if (secrets.length > 256) {
          secrets.splice(0, secrets.length - 192);
        }
      }

      lastSecretTime = Date.now();
      const secret = (0,index_browser/* nanoid */.x0)();
      secrets.push(secret);
      return `?secret=${secret}`;
    };
  })();
  /**
   * Load resources by path
   *
   * @param path
   * @return {Promise<string>}
   */


  const loadResource = async path => {
    const url = extension_api_browser/* browser.runtime.getURL */.X.runtime.getURL(`/${WEB_ACCESSIBLE_RESOURCES}/${path}${warSecret()}`);
    const response = await fetch(url);
    return response.text();
  };
  /**
   * Create url for redirect file
   *
   * @param {string} redirectFile
   * @param {string} requestUrl
   * @return {*}
   */


  const createRedirectFileUrl = (redirectFile, requestUrl) => {
    const params = new URLSearchParams(warSecret());

    if (redirectService.getBlockingRedirects().includes(redirectFile)) {
      const unblockToken = redirectsTokensCache.generateToken();
      params.set('__unblock', unblockToken);
      params.set('__origin', requestUrl);
    }

    return extension_api_browser/* browser.runtime.getURL */.X.runtime.getURL(`${WEB_ACCESSIBLE_RESOURCES}/redirects/${redirectFile}?${params.toString()}`);
  }; // EXPOSE


  return {
    loadResource,
    createRedirectFileUrl
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/filter/services/redirect-service.js


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */





const {
  Redirects
} = scriptlets_umd.redirects;
/**
 * Redirects service class
 */

const redirectService = function () {
  let redirects = null; // list of blocking type redirects, i.e. for click2load.html

  let blockingRedirects = [];
  /**
   * Initialize service
   */

  const init = rawYaml => {
    redirects = new Redirects(rawYaml);
    const redirectsData = redirects.redirects;
    blockingRedirects = Object.keys(redirectsData).filter(r => redirectsData[r].isBlocking);
  };
  /**
   * Returns blocking redirects titles array
   * @returns {string[]}
   */


  const getBlockingRedirects = () => blockingRedirects;
  /**
   * Check whether redirect creating is needed
   * i.e. for click2load.html it's not needed after button click
   * @param {string} redirectTitle
   * @param {string} requestUrl
   * @returns {boolean}
   */


  const shouldCreateRedirectUrl = (redirectTitle, requestUrl) => {
    if (!blockingRedirects.includes(redirectTitle)) {
      // no further checking is needed for most of redirects
      // except blocking redirects, i.e. click2load.html
      return true;
    } // unblock token passed to redirect by createRedirectFileUrl and returned back.
    // it should be last parameter in url


    const UNBLOCK_TOKEN_PARAM = '__unblock';
    let cleanRequestUrl = requestUrl;
    const url = new URL(requestUrl);
    const params = new URLSearchParams(url.search);
    const unblockToken = params.get(UNBLOCK_TOKEN_PARAM);

    if (unblockToken) {
      // if redirect has returned unblock token back,
      // add url to cache for no further redirecting on button click;
      // save cleaned origin url so unblock token parameter should be cut off
      params.delete(UNBLOCK_TOKEN_PARAM);
      cleanRequestUrl = `${url.origin}${url.pathname}?${params.toString}`;
      redirectsCache.add(cleanRequestUrl);
    }

    return !redirectsCache.hasUrl(cleanRequestUrl) || !redirectsTokensCache.hasToken(unblockToken);
  };
  /**
   * Creates url
   *
   * @param title
   * @param requestUrl
   * @return string|null
   */


  const createRedirectUrl = (title, requestUrl) => {
    if (!title) {
      return null;
    }

    const shouldRedirect = shouldCreateRedirectUrl(title, requestUrl);

    if (!shouldRedirect) {
      return null;
    }

    const redirectSource = redirects.getRedirect(title);

    if (!redirectSource) {
      log/* log.debug */.c.debug(`There is no redirect source with title: "${title}"`);
      return null;
    }

    return resources.createRedirectFileUrl(redirectSource.file, requestUrl);
  };

  const hasRedirect = title => {
    return !!redirects.getRedirect(title);
  };

  return {
    init,
    hasRedirect,
    createRedirectUrl,
    getBlockingRedirects
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/filter/filters/filters-state.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */



/**
 * Helper class for working with filters metadata storage (local storage)
 */

const filtersState = function () {
  const FILTERS_STATE_PROP = 'filters-state';
  const FILTERS_VERSION_PROP = 'filters-version';
  const GROUPS_STATE_PROP = 'groups-state';
  /**
   * Gets filter version from the local storage
   * @returns {*}
   */

  const getFiltersVersion = function () {
    let filters = Object.create(null);

    try {
      const json = storage_localStorage.getItem(FILTERS_VERSION_PROP);

      if (json) {
        filters = JSON.parse(json);
      }
    } catch (ex) {
      log/* log.error */.c.error('Error retrieve filters version info, cause {0}', ex);
    }

    return filters;
  };
  /**
   * Gets filters state from the local storage
   * @returns {*}
   */


  const getFiltersState = function () {
    let filters = Object.create(null);

    try {
      const json = storage_localStorage.getItem(FILTERS_STATE_PROP);

      if (json) {
        filters = JSON.parse(json);
      }
    } catch (ex) {
      log/* log.error */.c.error('Error retrieve filters state info, cause {0}', ex);
    }

    return filters;
  };
  /**
   * Gets groups state from the local storage
   * @returns {any}
   */


  const getGroupsState = function () {
    let groups = Object.create(null);

    try {
      const json = storage_localStorage.getItem(GROUPS_STATE_PROP);

      if (json) {
        groups = JSON.parse(json);
      }
    } catch (e) {
      log/* log.error */.c.error('Error retrieve groups state info, cause {0}', e);
    }

    return groups;
  };
  /**
   * Updates filter version in the local storage
   *
   * @param filter Filter version metadata
   */


  const updateFilterVersion = function (filter) {
    const filters = getFiltersVersion();
    filters[filter.filterId] = {
      version: filter.version,
      lastCheckTime: filter.lastCheckTime,
      lastUpdateTime: filter.lastUpdateTime,
      expires: filter.expires
    };
    storage_localStorage.setItem(FILTERS_VERSION_PROP, JSON.stringify(filters));
  };
  /**
   * Updates filter state in the local storage
   *
   * @param filter Filter state object
   */


  const updateFilterState = function (filter) {
    const filters = getFiltersState();
    filters[filter.filterId] = {
      loaded: filter.loaded,
      enabled: filter.enabled,
      installed: filter.installed
    };
    storage_localStorage.setItem(FILTERS_STATE_PROP, JSON.stringify(filters));
  };

  const removeFilter = filterId => {
    const filters = getFiltersState();
    delete filters[filterId];
    storage_localStorage.setItem(FILTERS_STATE_PROP, JSON.stringify(filters));
  };
  /**
   * Updates group enable state in the local storage
   *
   * @param group - SubscriptionGroup object
   */


  const updateGroupState = function (group) {
    const groups = getGroupsState();

    if (typeof group.enabled === 'undefined') {
      delete groups[group.groupId].enabled;
    } else {
      groups[group.groupId] = {
        enabled: group.enabled
      };
    }

    storage_localStorage.setItem(GROUPS_STATE_PROP, JSON.stringify(groups));
  }; // Add event listener to persist filter metadata to local storage


  listeners.addListener((event, payload) => {
    switch (event) {
      case listeners.SUCCESS_DOWNLOAD_FILTER:
        updateFilterState(payload);
        updateFilterVersion(payload);
        break;

      case listeners.FILTER_ADD_REMOVE:
      case listeners.FILTER_ENABLE_DISABLE:
        updateFilterState(payload);
        break;

      case listeners.FILTER_GROUP_ENABLE_DISABLE:
        updateGroupState(payload);
        break;

      default:
        break;
    }
  });
  return {
    getFiltersVersion,
    getFiltersState,
    getGroupsState,
    // These methods are used only for migrate from old versions
    updateFilterVersion,
    updateFilterState,
    removeFilter
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/filter/filters/metadata.js
/* eslint-disable max-classes-per-file */

/**
 * Filter metadata
 */
class SubscriptionFilter {
  constructor({
    filterId,
    groupId,
    name,
    description,
    homepage,
    version,
    timeUpdated,
    displayNumber = 0,
    languages = [],
    expires,
    subscriptionUrl,
    tags,
    customUrl,
    trusted,
    checksum
  }) {
    this.filterId = filterId;
    this.groupId = groupId;
    this.name = name;
    this.description = description;
    this.homepage = homepage;
    this.version = version;
    this.timeUpdated = timeUpdated;
    this.displayNumber = displayNumber;
    this.languages = languages;
    this.expires = expires;
    this.subscriptionUrl = subscriptionUrl;
    this.tags = tags; // Custom filters data

    if (typeof customUrl !== 'undefined') {
      this.customUrl = customUrl;
    }

    if (typeof trusted !== 'undefined') {
      this.trusted = trusted;
    }

    if (typeof checksum !== 'undefined') {
      this.checksum = checksum;
    }
  }

}
/**
 * Group metadata
 */

class SubscriptionGroup {
  constructor(groupId, groupName, displayNumber) {
    this.groupId = groupId;
    this.groupName = groupName;
    this.displayNumber = displayNumber;
  }

}
/**
 * Tag metadata
 */

class FilterTag {
  constructor(tagId, keyword) {
    this.tagId = tagId;
    this.keyword = keyword;
  }

}
;// CONCATENATED MODULE: ./Extension/src/background/filter/filters/metadata-factory.js

/**
 * Metadata factory
 */

const metadataFactory = (() => {
  /**
   * Parses string to date
   *
   * @param timeUpdatedString String in format 'yyyy-MM-dd'T'HH:mm:ssZ'
   * @returns number from date string
   */
  const parseTimeUpdated = timeUpdatedString => {
    // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1272
    if (Number.isInteger(timeUpdatedString)) {
      return new Date(timeUpdatedString).getTime();
    } // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/parse


    let timeUpdated = Date.parse(timeUpdatedString);

    if (Number.isNaN(timeUpdated)) {
      // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/478
      timeUpdated = Date.parse(timeUpdatedString.replace(/\+(\d{2})(\d{2})$/, '+$1:$2'));
    }

    if (Number.isNaN(timeUpdated)) {
      timeUpdated = new Date().getTime();
    }

    return timeUpdated;
  };
  /**
   * Create tag from object
   *
   * @param tag Object
   * @returns {FilterTag}
   */


  const createFilterTagFromJSON = tag => {
    const tagId = Number.parseInt(tag.tagId, 10);
    const {
      keyword
    } = tag;
    return new FilterTag(tagId, keyword);
  };
  /**
   * Create group from object
   *
   * @param group Object
   * @returns {SubscriptionGroup}
   */


  const createSubscriptionGroupFromJSON = group => {
    const groupId = Number.parseInt(group.groupId, 10);
    const defaultGroupName = group.groupName;
    const displayNumber = Number.parseInt(group.displayNumber, 10);
    return new SubscriptionGroup(groupId, defaultGroupName, displayNumber);
  };
  /**
   * Create filter from object
   *
   * @param filter Object
   */


  const createSubscriptionFilterFromJSON = filter => {
    const filterId = Number.parseInt(filter.filterId, 10);
    const groupId = Number.parseInt(filter.groupId, 10);
    const timeUpdated = parseTimeUpdated(filter.timeUpdated);
    const expires = Number.parseInt(filter.expires, 10);
    const displayNumber = Number.parseInt(filter.displayNumber, 10);
    const {
      name,
      description,
      homepage,
      version,
      subscriptionUrl,
      languages,
      tags,
      customUrl,
      trusted,
      checksum
    } = filter;

    if (tags.length === 0) {
      tags.push(0);
    }

    return new SubscriptionFilter({
      filterId,
      groupId,
      name,
      description,
      homepage,
      version,
      timeUpdated,
      displayNumber,
      languages,
      expires,
      subscriptionUrl,
      tags,
      customUrl,
      trusted,
      checksum
    });
  };

  return {
    createFilterTagFromJSON,
    createSubscriptionGroupFromJSON,
    createSubscriptionFilterFromJSON
  };
})();
;// CONCATENATED MODULE: ./Extension/src/background/filter/filters/metadata-cache.js
/**
 * Cache data for filters, groups and tags
 */
const metadataCache = (() => {
  let tags = [];
  let groups = [];
  let groupsMap = {};
  let filters = [];
  let filtersMap = {};
  /**
   * Returns cache data
   */

  const getData = () => ({
    tags,
    groups,
    groupsMap,
    filters,
    filtersMap
  });
  /**
   * Updates cache data
   */


  const setData = data => {
    tags = data.tags || tags;
    groups = data.groups || groups;
    groupsMap = data.groupsMap || groupsMap;
    filters = data.filters || filters;
    filtersMap = data.filtersMap || filtersMap;
  };
  /**
   * Gets filter metadata by filter identifier
   */


  const getFilter = filterId => filtersMap[filterId];
  /**
   * @returns Array of Filters metadata
   */


  const getFilters = () => filters;
  /**
   * Removes filter metadata by id
   * @param filterId
   */


  const removeFilter = filterId => {
    filters = filters.filter(f => f.filterId !== filterId);
    delete filtersMap[filterId];
  };
  /**
   * Updates filter metadata
   * @param filter
   */


  const updateFilters = filter => {
    removeFilter(filter.filterId);
    filters.push(filter);
    filtersMap[filter.filterId] = filter;
  };
  /**
   * @returns Group metadata
   */


  const getGroup = groupId => groupsMap[groupId];
  /**
   * @returns Array of Groups metadata
   */


  const getGroups = () => groups;
  /**
   * @returns Array of Groups metadata
   */


  const getGroupsMap = () => groupsMap;
  /**
   * @returns Array of Tags metadata
   */


  const getTags = () => tags;

  return {
    getData,
    setData,
    getFilter,
    getFilters,
    removeFilter,
    updateFilters,
    getGroup,
    getGroups,
    getGroupsMap,
    getTags
  };
})();
// EXTERNAL MODULE: ./node_modules/crypto-js/md5.js
var md5 = __webpack_require__(66172);
var md5_default = /*#__PURE__*/__webpack_require__.n(md5);
;// CONCATENATED MODULE: ./Extension/src/background/filter/filters/custom-filters.js









/**
 * Custom filters module
 */

const customFilters = (() => {
  /**
   * Amount of lines to parse metadata from filter's header
   * @type {number}
   */
  const AMOUNT_OF_LINES_TO_PARSE = 50;
  /**
   * Storage key for custom filter's data
   * @type {string}
   */

  const CUSTOM_FILTERS_STORAGE_KEY = 'custom_filters';
  /**
   * Parses expires string in meta
   *
   * @param str
   * @return {number}
   */

  const parseExpiresStr = str => {
    const regexp = /(\d+)\s+(day|hour)/;
    const parseRes = str.match(regexp);

    if (!parseRes) {
      const parsed = Number.parseInt(str, 10);
      return Number.isNaN(parsed) ? 0 : parsed;
    }

    const [, num, period] = parseRes;
    let multiplier = 1;

    switch (period) {
      case 'day':
        {
          multiplier = 24 * 60 * 60;
          break;
        }

      case 'hour':
        {
          multiplier = 60 * 60;
          break;
        }

      default:
        {
          break;
        }
    }

    return num * multiplier;
  };
  /**
   * Parses filter metadata from rules header
   *
   * @param rules
   * @returns object
   */


  const parseFilterDataFromHeader = rules => {
    const parseTag = tagName => {
      let result = ''; // Look up no more than 50 first lines

      const maxLines = Math.min(AMOUNT_OF_LINES_TO_PARSE, rules.length);

      for (let i = 0; i < maxLines; i += 1) {
        const rule = rules[i];
        const search = `! ${tagName}: `;
        const indexOfSearch = rule.indexOf(search);

        if (indexOfSearch >= 0) {
          result = rule.substring(indexOfSearch + search.length);
        }
      }

      if (tagName === 'Expires') {
        result = parseExpiresStr(result);
      }

      return result;
    };

    return {
      name: parseTag('Title'),
      description: parseTag('Description'),
      homepage: parseTag('Homepage'),
      version: parseTag('Version'),
      expires: parseTag('Expires'),
      timeUpdated: parseTag('TimeUpdated')
    };
  };
  /**
   * Gets new filter id for custom filter
   * @return {number}
   */


  const addCustomFilterId = () => {
    let max = 0;
    const filters = metadataCache.getFilters();
    filters.forEach(f => {
      if (f.filterId > max) {
        max = f.filterId;
      }
    });
    return max >= constants/* CUSTOM_FILTERS_START_ID */.ih ? max + 1 : constants/* CUSTOM_FILTERS_START_ID */.ih;
  };
  /**
   * Loads custom filters from storage
   *
   * @returns {Array}
   */


  const loadCustomFilters = () => {
    const customFilters = storage_localStorage.getItem(CUSTOM_FILTERS_STORAGE_KEY);
    return customFilters ? JSON.parse(customFilters) : [];
  };
  /**
   * Saves custom filter to storage or updates it if filter with same id was found
   *
   * @param filter
   */


  const saveCustomFilterInStorage = filter => {
    const customFilters = loadCustomFilters();
    const updatedCustomFilters = customFilters.filter(f => f.filterId !== filter.filterId);
    updatedCustomFilters.push(filter);
    storage_localStorage.setItem(CUSTOM_FILTERS_STORAGE_KEY, JSON.stringify(updatedCustomFilters));
  };
  /**
   * Remove custom filter data from storage
   *
   * @param filter
   */


  const removeCustomFilterFromStorage = filter => {
    const customFilters = loadCustomFilters();
    const updatedCustomFilters = customFilters.filter(f => {
      if (f.filterId === filter.filterId) {
        return filter.installed;
      }

      return true;
    });
    storage_localStorage.setItem(CUSTOM_FILTERS_STORAGE_KEY, JSON.stringify(updatedCustomFilters));
  };
  /**
   * Compares filter version or filter checksum
   * @param newVersion
   * @param newChecksum
   * @param oldFilter
   * @returns Boolean
   */


  const isFilterUpdated = (newVersion, newChecksum, oldFilter) => {
    if (browserUtils.isSemver(oldFilter.version) && browserUtils.isSemver(newVersion)) {
      return !browserUtils.isGreaterOrEqualsVersion(oldFilter.version, newVersion);
    }

    if (!oldFilter.checksum) {
      return true;
    }

    return newChecksum !== oldFilter.checksum;
  };
  /**
   * Count md5 checksum for the filter content
   * @param {Array<String>} rules
   * @returns {String} checksum string
   */


  const getChecksum = rules => {
    const rulesText = rules.join('\n');
    return md5_default()(rulesText).toString();
  };
  /**
   * Updates filter checksum and version in the storage and internal structures
   * @param filter
   * @param {object} info
   */


  const updateCustomFilterInfo = (filter, info) => {
    const {
      checksum,
      version,
      timeUpdated,
      lastCheckTime,
      expires
    } = info;
    filter.checksum = checksum || filter.checksum;
    filter.version = version || filter.version;
    filter.timeUpdated = timeUpdated || filter.timeUpdated;
    filter.lastCheckTime = lastCheckTime || filter.lastCheckTime;
    filter.expires = expires || filter.expires;

    if ('enabled' in info) {
      filter.enabled = info.enabled;
    }

    metadataCache.updateFilters(filter);
    saveCustomFilterInStorage(filter);
  };
  /**
   * Safe download rules from subscription url
   *
   * @param url
   * @return {Promise<null|*>}
   */


  const downloadRules = async url => {
    let rules;

    try {
      rules = await backend.downloadFilterRulesBySubscriptionUrl(url);
      return rules;
    } catch (e) {
      log/* log.error */.c.error(`Error download filter by url ${url}, cause: ${e || ''}`);
      return null;
    }
  };
  /**
   * Limits filter download with timeout
   * @param url
   */


  const downloadRulesWithTimeout = async url => {
    const DOWNLOAD_LIMIT_MS = 3 * 1000;
    return Promise.race([downloadRules(url), new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Fetch timeout is over')), DOWNLOAD_LIMIT_MS);
    })]);
  };
  /**
   * Adds or updates custom filter
   *
   * @param url subscriptionUrl
   * @param options
   */


  const updateCustomFilter = async (url, options) => {
    const {
      title,
      trusted,
      enabled
    } = options;
    const rules = await downloadRulesWithTimeout(url);

    if (!rules) {
      return null;
    }

    const parsedData = parseFilterDataFromHeader(rules);
    const {
      description,
      homepage,
      version,
      expires,
      timeUpdated = new Date().toISOString()
    } = parsedData;
    const checksum = !version || !browserUtils.isSemver(version) ? getChecksum(rules) : null; // Check if filter from this url was added before

    let filter = metadataCache.getFilters().find(f => f.customUrl === url);

    if (filter) {
      if (!isFilterUpdated(version, checksum, filter)) {
        updateCustomFilterInfo(filter, {
          lastCheckTime: Date.now()
        });
        return null;
      }

      updateCustomFilterInfo(filter, {
        version,
        checksum,
        timeUpdated,
        expires,
        lastCheckTime: Date.now()
      });
    } else {
      filter = new SubscriptionFilter({
        filterId: addCustomFilterId(),
        groupId: constants/* ANTIBANNER_GROUPS_ID.CUSTOM_FILTERS_GROUP_ID */.CI.CUSTOM_FILTERS_GROUP_ID,
        name: title,
        description,
        homepage,
        version,
        timeUpdated,
        expires,
        subscriptionUrl: url,
        tags: [0],
        customUrl: url,
        checksum,
        trusted
      });
      filter.lastCheckTime = Date.now();
      filter.loaded = true;
      filter.enabled = enabled === true;
      metadataCache.updateFilters(filter);
      saveCustomFilterInStorage(filter);
    }

    listeners.notifyListeners(listeners.SUCCESS_DOWNLOAD_FILTER, filter);
    listeners.notifyListeners(listeners.UPDATE_FILTER_RULES, filter, rules);
    return filter.filterId;
  };
  /**
   * Retrieves custom filter information
   * @param url
   * @param options
   * @returns {Promise<{filter: SubscriptionFilter}|{}|{error: *}>}
   */


  const getCustomFilterInfo = async (url, options) => {
    // Check if filter from this url was added before
    if (metadataCache.getFilters().find(f => f.customUrl === url)) {
      return {
        errorAlreadyExists: true
      };
    }

    const rules = await downloadRules(url);

    if (!rules) {
      return {};
    }

    const parsedData = parseFilterDataFromHeader(rules);
    const {
      name = options.title,
      description,
      homepage,
      version,
      expires,
      timeUpdated = new Date().toISOString()
    } = parsedData;
    const filter = new SubscriptionFilter({
      groupId: constants/* ANTIBANNER_GROUPS_ID.CUSTOM_FILTERS_GROUP_ID */.CI.CUSTOM_FILTERS_GROUP_ID,
      name,
      description,
      homepage,
      version,
      timeUpdated,
      expires,
      subscriptionUrl: url,
      tags: [0],
      customUrl: url
    });
    filter.loaded = true;
    filter.rulesCount = rules.filter(rule => rule.trim().indexOf('!') !== 0).length;
    return {
      filter
    };
  };
  /**
   * Removes filter
   *
   * @param filter
   */


  const removeCustomFilter = filter => {
    if (filter && filter.filterId) {
      metadataCache.removeFilter(filter.filterId);
    }
  };
  /**
   * Returns custom filters
   *
   * @returns Array
   */


  const getCustomFilters = function () {
    return metadataCache.getFilters().filter(f => f.customUrl);
  }; // Add event listener to persist filter metadata to local storage


  listeners.addListener((event, payload) => {
    if (event === listeners.FILTER_ADD_REMOVE) {
      if (payload && payload.removed) {
        removeCustomFilter(payload);
        removeCustomFilterFromStorage(payload);
      }
    }
  });
  return {
    getCustomFilters,
    loadCustomFilters,
    updateCustomFilter,
    getCustomFilterInfo,
    CUSTOM_FILTERS_START_ID: constants/* CUSTOM_FILTERS_START_ID */.ih,
    CUSTOM_FILTERS_GROUP_DISPLAY_NUMBER: constants/* CUSTOM_FILTERS_GROUP_DISPLAY_NUMBER */.VC
  };
})();
;// CONCATENATED MODULE: ./Extension/src/background/filter/filters/subscription.js

















/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */















/**
 * Service that loads and parses filters metadata from backend server.
 * For now we just store filters metadata in an XML file within the extension.
 * In future we'll add an opportunity to update metadata along with filter rules update.
 */

const subscriptions = (() => {
  /**
   * Storage keys for metadata objects
   * @type {string}
   */
  const METADATA_STORAGE_KEY = 'filters-metadata';
  const I18N_METADATA_STORAGE_KEY = 'filters-i18n-metadata';
  /**
   * Updates filters version and state info.
   * Loads this data from the storage and then updates adguard.subscription.filters property
   *
   * @private
   */

  const loadFiltersVersionAndStateInfo = () => {
    // Load filters metadata from the storage
    const filtersVersionInfo = filtersState.getFiltersVersion(); // Load filters state from the storage

    const filtersStateInfo = filtersState.getFiltersState();
    const filters = metadataCache.getFilters();

    for (let i = 0; i < filters.length; i += 1) {
      const filter = filters[i];
      const {
        filterId
      } = filter;
      const versionInfo = filtersVersionInfo[filterId];
      const stateInfo = filtersStateInfo[filterId];

      if (versionInfo) {
        filter.version = versionInfo.version;
        filter.lastCheckTime = versionInfo.lastCheckTime;
        filter.lastUpdateTime = versionInfo.lastUpdateTime;

        if (versionInfo.expires) {
          filter.expires = versionInfo.expires;
        }
      }

      if (stateInfo) {
        filter.enabled = stateInfo.enabled;
        filter.installed = stateInfo.installed;
        filter.loaded = stateInfo.loaded;
      }

      metadataCache.updateFilters(filter);
    }
  };
  /**
   * Updates groups state info
   * Loads state info from the storage and then updates adguard.subscription.groups properly
   * @private
   */


  const loadGroupsStateInfo = () => {
    // Load filters state from the storage
    const groupsStateInfo = filtersState.getGroupsState();
    const groups = metadataCache.getGroups();

    for (let i = 0; i < groups.length; i += 1) {
      const group = groups[i];
      const {
        groupId
      } = group;
      const stateInfo = groupsStateInfo[groupId];

      if (stateInfo) {
        group.enabled = stateInfo.enabled;
        metadataCache.getGroup(group);
      }
    }
  };
  /**
   * Refreshes subscription's objects with metadata
   * @param metadata
   */


  const saveMetadata = metadata => {
    const tags = [];
    const groups = [];
    const groupsMap = {};
    const filters = [];
    const filtersMap = {};

    for (let i = 0; i < metadata.tags.length; i += 1) {
      tags.push(metadataFactory.createFilterTagFromJSON(metadata.tags[i]));
    }

    for (let j = 0; j < metadata.filters.length; j += 1) {
      const filter = metadataFactory.createSubscriptionFilterFromJSON(metadata.filters[j]);
      filters.push(filter);
      filtersMap[filter.filterId] = filter;
    }

    for (let k = 0; k < metadata.groups.length; k += 1) {
      const group = metadataFactory.createSubscriptionGroupFromJSON(metadata.groups[k]);
      groups.push(group);
      groupsMap[group.groupId] = group;
    }

    const customFiltersGroup = new SubscriptionGroup(constants/* ANTIBANNER_GROUPS_ID.CUSTOM_FILTERS_GROUP_ID */.CI.CUSTOM_FILTERS_GROUP_ID, translator/* translator.getMessage */.O.getMessage('options_antibanner_custom_group'), customFilters.CUSTOM_FILTERS_GROUP_DISPLAY_NUMBER);
    groups.push(customFiltersGroup);
    groupsMap[customFiltersGroup.groupId] = customFiltersGroup; // Load custom filters

    const customFiltersList = customFilters.loadCustomFilters();
    customFiltersList.forEach(f => {
      const customFilter = metadataFactory.createSubscriptionFilterFromJSON(f);
      filters.push(customFilter);
      filtersMap[customFilter.filterId] = customFilter;
    });
    filters.sort((f1, f2) => f1.displayNumber - f2.displayNumber);
    groups.sort((f1, f2) => f1.displayNumber - f2.displayNumber);
    metadataCache.setData({
      tags,
      groups,
      groupsMap,
      filters,
      filtersMap
    });
  };
  /**
   * Load groups and filters metadata
   * @returns {Promise} returns promise
   */


  const loadMetadata = async () => {
    let metadata; // Load from storage first

    const data = storage_localStorage.getItem(METADATA_STORAGE_KEY);

    if (data) {
      metadata = JSON.parse(data);
    } else {
      metadata = await backend.getLocalFiltersMetadata();
    }

    saveMetadata(metadata);
    log/* log.info */.c.info('Filters metadata loaded');
  };
  /**
   * Reloads groups and filters metadata from backend
   * @returns {Promise} returns promise
   */


  const reloadMetadataFromBackend = async () => {
    const metadata = await backend.downloadMetadataFromBackend();
    storage_localStorage.setItem(METADATA_STORAGE_KEY, JSON.stringify(metadata));
    saveMetadata(metadata);
    loadFiltersVersionAndStateInfo();
    loadGroupsStateInfo();
    log/* log.info */.c.info('Filters metadata reloaded from backend');
  };
  /**
   * Load metadata of the specified filters
   *
   * @param filterIds         Filters identifiers
   */


  const getFiltersMetadata = async filterIds => {
    if (!filterIds || filterIds.length === 0) {
      return [];
    }

    const metadata = await backend.downloadMetadataFromBackend();
    const filterMetadataList = [];

    for (let i = 0; i < filterIds.length; i += 1) {
      const filter = utils.collections.find(metadata.filters, 'filterId', filterIds[i]);

      if (filter) {
        filterMetadataList.push(metadataFactory.createSubscriptionFilterFromJSON(filter));
      }
    }

    return filterMetadataList;
  };
  /**
   * Localize tag
   * @param tag
   * @param i18nMetadata
   * @private
   */


  const applyFilterTagLocalization = (tag, i18nMetadata) => {
    const {
      tagId
    } = tag;
    const localizations = i18nMetadata[tagId];

    if (localizations) {
      const locale = utils.i18n.normalize(localizations, backgroundPage.app.getLocale());
      const localization = localizations[locale];

      if (localization) {
        tag.name = localization.name;
        tag.description = localization.description;
      }
    }
  };
  /**
   * Localize filter
   * @param filter
   * @param i18nMetadata
   * @private
   */


  const applyFilterLocalization = (filter, i18nMetadata) => {
    const {
      filterId
    } = filter;
    const localizations = i18nMetadata[filterId];

    if (localizations) {
      const locale = utils.i18n.normalize(localizations, backgroundPage.app.getLocale());
      const localization = localizations[locale];

      if (localization) {
        filter.name = localization.name;
        filter.description = localization.description;
      }
    }
  };
  /**
   * Localize group
   * @param group
   * @param i18nMetadata
   * @private
   */


  const applyGroupLocalization = (group, i18nMetadata) => {
    const {
      groupId
    } = group;
    const localizations = i18nMetadata[groupId];

    if (localizations) {
      const locale = utils.i18n.normalize(localizations, backgroundPage.app.getLocale());
      const localization = localizations[locale];

      if (localization) {
        group.groupName = localization.name;
      }
    }
  };
  /**
   * Refreshes subscription's objects with i18n metadata
   * @param i18nMetadata
   */


  const saveI18nMetadata = i18nMetadata => {
    const tagsI18n = i18nMetadata.tags;
    const filtersI18n = i18nMetadata.filters;
    const groupsI18n = i18nMetadata.groups;
    const {
      tags,
      groups,
      filters
    } = metadataCache.getData();

    for (let i = 0; i < tags.length; i += 1) {
      applyFilterTagLocalization(tags[i], tagsI18n);
    }

    for (let j = 0; j < filters.length; j += 1) {
      applyFilterLocalization(filters[j], filtersI18n);
    }

    for (let k = 0; k < groups.length; k += 1) {
      applyGroupLocalization(groups[k], groupsI18n);
    }

    metadataCache.setData({
      tags,
      groups,
      filters
    });
  };
  /**
   * Loads groups and filters localizations
   * @return {Promise} returns promise
   */


  const loadMetadataI18n = async () => {
    log/* log.info */.c.info('Loading filters i18n metadata..');
    let metadata; // Load from storage first

    const data = storage_localStorage.getItem(I18N_METADATA_STORAGE_KEY);

    if (data) {
      metadata = JSON.parse(data);
    } else {
      metadata = await backend.getLocalFiltersI18Metadata();
    }

    saveI18nMetadata(metadata);
    log/* log.info */.c.info('Filters i18n metadata loaded');
  };
  /**
   * Reloads i18n metadata localizations from backend
   * @returns {Promise} returns promise
   */


  const reloadI18nMetadataFromBackend = async () => {
    const metadata = await backend.downloadI18nMetadataFromBackend();
    storage_localStorage.setItem(I18N_METADATA_STORAGE_KEY, JSON.stringify(metadata));
    saveI18nMetadata(metadata);
    log/* log.info */.c.info('Filters i18n metadata reloaded from backend');
  };
  /**
   * Loads script rules from local file
   * @returns {Promise}
   * @private
   */


  const loadLocalScriptRules = async () => {
    if (browserUtils.isFirefoxBrowser()) {
      const json = await backend.getLocalScriptRules();
      local_script_rules_chrome.setLocalScriptRules(json);
      log/* log.info */.c.info('Filters local script rules loaded');
    }
  };
  /**
   * Loads redirect sources from local file
   * @returns {Promise}
   * @private
   */


  const loadRedirectSources = async () => {
    const txt = await backend.getRedirectSources();
    redirectService.init(txt);
    log/* log.info */.c.info('Filters redirect sources loaded');
  };
  /**
   * Initialize subscription service, loading local filters metadata
   * @return {Promise}
   */


  const init = async function () {
    try {
      await loadMetadata();
      await loadMetadataI18n();
      await loadLocalScriptRules();
      await loadRedirectSources();
    } catch (e) {
      log/* log.error */.c.error(`Error loading metadata, cause: ${e.message}`);
    }
  };
  /**
   * @returns Array of Filters metadata
   */


  const getFilters = function () {
    return metadataCache.getFilters();
  };
  /**
   * Gets filter metadata by filter identifier
   */


  const getFilter = function (filterId) {
    return metadataCache.getFilter(filterId);
  };

  const isTrustedFilter = filterId => {
    if (filterId < customFilters.CUSTOM_FILTERS_START_ID) {
      return true;
    }

    const filter = metadataCache.getFilter(filterId);
    return !!(filter && filter.trusted && filter.trusted === true);
  };
  /**
   * @returns Array of Tags metadata
   */


  const getTags = function () {
    return metadataCache.getTags();
  };
  /**
   * @returns Array of Groups metadata
   */


  const getGroups = () => metadataCache.getGroups();
  /**
   * @returns Group metadata
   */


  const getGroup = groupId => metadataCache.getGroup(groupId);
  /**
   * Checks if group has enabled status true or false
   * @param groupId
   * @returns {boolean}
   */


  const groupHasEnabledStatus = groupId => {
    const group = metadataCache.getGroup(groupId);
    return typeof group.enabled !== 'undefined';
  };
  /**
   * Gets list of filters for the specified languages
   *
   * @param locale Locale to check
   * @returns {Array} List of filters identifiers
   */


  const getFilterIdsForLanguage = function (locale) {
    if (!locale) {
      return [];
    }

    const filters = metadataCache.getFilters();
    const filterIds = [];

    for (let i = 0; i < filters.length; i += 1) {
      const filter = filters[i];
      const {
        languages
      } = filter;

      if (languages && languages.length > 0) {
        const language = utils.i18n.normalize(languages, locale);

        if (language) {
          filterIds.push(filter.filterId);
        }
      }
    }

    return filterIds;
  };
  /**
   * @return list of filters
   */


  const getLangSuitableFilters = () => {
    // Get language-specific filters by user locale
    let filterIds = [];
    let localeFilterIds = getFilterIdsForLanguage(backgroundPage.app.getLocale());
    filterIds = filterIds.concat(localeFilterIds); // Get language-specific filters by navigator languages
    // Get all used languages

    const languages = browserUtils.getNavigatorLanguages();

    for (let i = 0; i < languages.length; i += 1) {
      localeFilterIds = getFilterIdsForLanguage(languages[i]);
      filterIds = filterIds.concat(localeFilterIds);
    }

    return [...new Set(filterIds)];
  };

  return {
    init,
    reloadMetadataFromBackend,
    reloadI18nMetadataFromBackend,
    loadFiltersVersionAndStateInfo,
    loadGroupsStateInfo,
    getFiltersMetadata,
    getFilterIdsForLanguage,
    getLangSuitableFilters,
    getTags,
    getGroups,
    getGroup,
    getFilters,
    getFilter,
    isTrustedFilter,
    groupHasEnabledStatus
  };
})();
;// CONCATENATED MODULE: ./Extension/src/background/filter/page-stats.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */







/**
 * Global stats
 */

const pageStats = function () {
  const MAX_HOURS_HISTORY = 24;
  const MAX_DAYS_HISTORY = 30;
  const MAX_MONTHS_HISTORY = 3;
  const TOTAL_GROUP = {
    groupId: 'total',
    groupName: translator/* translator.getMessage */.O.getMessage('popup_statistics_total')
  };
  const pageStatisticProperty = 'page-statistic';
  const pageStatsHolder = {
    /**
     * Getter for total page stats (gets it from local storage)
     *
     * @returns {*}
     * @private
     */
    get stats() {
      return lazyGet(pageStatsHolder, 'stats', () => {
        let stats;

        try {
          const json = storage_localStorage.getItem(pageStatisticProperty);

          if (json) {
            stats = JSON.parse(json);
          }
        } catch (ex) {
          log/* log.error */.c.error('Error retrieve page statistic from storage, cause {0}', ex);
        }

        return stats || Object.create(null);
      });
    },

    save: utils.concurrent.throttle(function () {
      storage_localStorage.setItem(pageStatisticProperty, JSON.stringify(this.stats));
    }, prefs.statsSaveInterval),

    clear() {
      storage_localStorage.removeItem(pageStatisticProperty);
      lazyGetClear(pageStatsHolder, 'stats');
    }

  };
  /**
   * Total count of blocked requests
   *
   * @returns {Number} Count of blocked requests
   */

  const getTotalBlocked = function () {
    const {
      stats
    } = pageStatsHolder;

    if (!stats) {
      return 0;
    }

    return stats.totalBlocked || 0;
  };
  /**
   * Updates total count of blocked requests
   *
   * @param blocked Count of blocked requests
   */


  const updateTotalBlocked = function (blocked) {
    const {
      stats
    } = pageStatsHolder;
    stats.totalBlocked = (stats.totalBlocked || 0) + blocked;
    pageStatsHolder.save();
  };
  /**
   * Resets tab stats
   */


  const resetStats = function () {
    pageStatsHolder.clear();
  };
  /**
   * Object used to cache bindings between filters and groups
   * @type {{filterId: {groupId: Number, groupName: String, displayNumber: Number}}}
   */


  const blockedGroupsFilters = {}; // TODO check why not all filter stats appear here, for example cosmetic filters

  /**
   * Returns blocked group by filter id
   *
   * @param {number} filterId
   * @returns
   */

  const getBlockedGroupByFilterId = function (filterId) {
    let blockedGroup = blockedGroupsFilters[filterId];

    if (blockedGroup !== undefined) {
      return blockedGroup;
    }

    const filter = subscriptions.getFilter(filterId);

    if (!filter) {
      return undefined;
    }

    const group = subscriptions.getGroup(filter.groupId);

    if (!group) {
      return undefined;
    }

    const {
      groupId,
      groupName,
      displayNumber
    } = group;
    blockedGroup = {
      groupId,
      groupName,
      displayNumber
    };
    blockedGroupsFilters[filter.filterId] = blockedGroup;
    return blockedGroup;
  };

  const createStatsDataItem = function (type, blocked) {
    const result = {};

    if (type) {
      result[type] = blocked;
    }

    result[TOTAL_GROUP.groupId] = blocked;
    return result;
  };
  /**
   * Blocked types to filters relation dictionary
   */


  const createStatsData = function (now, type, blocked) {
    const result = Object.create(null);
    result.hours = [];
    result.days = [];
    result.months = [];

    for (let i = 1; i < MAX_HOURS_HISTORY; i += 1) {
      result.hours.push(createStatsDataItem(null, 0));
    }

    result.hours.push(createStatsDataItem(type, blocked));

    for (let j = 1; j < MAX_DAYS_HISTORY; j += 1) {
      result.days.push(createStatsDataItem(null, 0));
    }

    result.days.push(createStatsDataItem(type, blocked));

    for (let k = 1; k < MAX_MONTHS_HISTORY; k += 1) {
      result.months.push(createStatsDataItem(null, 0));
    }

    result.months.push(createStatsDataItem(type, blocked));
    result.updated = now.getTime();
    return result;
  };

  const updateStatsDataItem = function (type, blocked, current) {
    current[type] = (current[type] || 0) + blocked;
    current[TOTAL_GROUP.groupId] = (current[TOTAL_GROUP.groupId] || 0) + blocked;
    return current;
  };

  const updateStatsData = function (now, type, blocked, current) {
    const currentDate = new Date(current.updated);
    const result = current;

    if (utils.dates.isSameHour(now, currentDate) && result.hours.length > 0) {
      result.hours[result.hours.length - 1] = updateStatsDataItem(type, blocked, result.hours[result.hours.length - 1]);
    } else {
      let diffHours = utils.dates.getDifferenceInHours(now, currentDate);

      while (diffHours >= 2) {
        result.hours.push(createStatsDataItem(null, 0));
        diffHours -= 1;
      }

      result.hours.push(createStatsDataItem(type, blocked));

      if (result.hours.length > MAX_HOURS_HISTORY) {
        result.hours = result.hours.slice(-MAX_HOURS_HISTORY);
      }
    }

    if (utils.dates.isSameDay(now, currentDate) && result.days.length > 0) {
      result.days[result.days.length - 1] = updateStatsDataItem(type, blocked, result.days[result.days.length - 1]);
    } else {
      let diffDays = utils.dates.getDifferenceInDays(now, currentDate);

      while (diffDays >= 2) {
        result.days.push(createStatsDataItem(null, 0));
        diffDays -= 1;
      }

      result.days.push(createStatsDataItem(type, blocked));

      if (result.days.length > MAX_DAYS_HISTORY) {
        result.days = result.days.slice(-MAX_DAYS_HISTORY);
      }
    }

    if (utils.dates.isSameMonth(now, currentDate) && result.months.length > 0) {
      result.months[result.months.length - 1] = updateStatsDataItem(type, blocked, result.months[result.months.length - 1]);
    } else {
      let diffMonths = utils.dates.getDifferenceInMonths(now, currentDate);

      while (diffMonths >= 2) {
        result.months.push(createStatsDataItem(null, 0));
        diffMonths -= 1;
      }

      result.months.push(createStatsDataItem(type, blocked));
    }

    result.updated = now.getTime();
    return result;
  };
  /**
   * Updates stats data
   *
   * For every hour/day/month we have an object:
   * {
   *      blockedType: count,
   *      ..,
   *
   *      total: count
   * }
   *
   * We store last 24 hours, 30 days and all past months stats
   *
   * var data = {
   *              hours: [],
   *              days: [],
   *              months: [],
   *              updated: Date };
   *
   * @param filterId
   * @param blocked count
   * @param now date
   */


  const updateStats = function (filterId, blocked, now) {
    const blockedGroup = getBlockedGroupByFilterId(filterId);

    if (blockedGroup === undefined) {
      return;
    }

    const {
      groupId
    } = blockedGroup;
    const {
      stats
    } = pageStatsHolder;
    let updated;

    if (!stats.data) {
      updated = createStatsData(now, groupId, blocked);
    } else {
      updated = updateStatsData(now, groupId, blocked, stats.data);
    }

    pageStatsHolder.stats.data = updated;
    pageStatsHolder.save();
  };

  const getBlockedGroups = () => {
    const groups = subscriptions.getGroups().map(group => {
      return {
        groupId: group.groupId,
        groupName: group.groupName,
        displayNumber: group.displayNumber
      };
    });
    return [TOTAL_GROUP, ...groups.sort((prevGroup, nextGroup) => {
      return prevGroup.displayNumber - nextGroup.displayNumber;
    })];
  };
  /**
   * Returns statistics data object
   * @param {Date} [date] - used in the tests to provide time of stats object creation
   */


  const getStatisticsData = (date = new Date()) => {
    let {
      stats
    } = pageStatsHolder;

    if (!stats) {
      stats = {};
    }

    if (!stats.data) {
      stats.data = createStatsData(date, null, 0);
      pageStatsHolder.stats.data = stats.data;
      pageStatsHolder.save();
    }

    return {
      today: stats.data.hours,
      lastWeek: stats.data.days.slice(-7),
      lastMonth: stats.data.days,
      lastYear: stats.data.months.slice(-12),
      overall: stats.data.months,
      blockedGroups: getBlockedGroups()
    };
  };

  return {
    resetStats,
    updateTotalBlocked,
    updateStats,
    getTotalBlocked,
    getStatisticsData
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/filter/filtering-api.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * Api for filtering and elements hiding.
 *
 * TODO: Delete this service
 */

const filteringApi = function () {
  function getRequestFilter() {
    return antiBannerService.getRequestFilter();
  }
  /**
   * @returns boolean true when request filter was initialized first time
   */


  const isReady = function () {
    return engine.isReady();
  };
  /**
   * When browser just started we need some time on request filter initialization.
   * This could be a problem in case when browser has a homepage and it is just started.
   * In this case request filter is not yet initalized so we don't block requests and inject css.
   * To fix this, content script will repeat requests for selectors until request filter is ready
   * and it will also collapse all elements which should have been blocked.
   *
   * @returns boolean true if we should collapse elements with content script
   */


  const shouldCollapseAllElements = function () {
    // We assume that if content script is requesting CSS in first 5 seconds after request filter init,
    // then it is possible, that we've missed some elements and now we should collapse these elements
    const requestFilterInitTime = antiBannerService.getRequestFilterInitTime();
    return requestFilterInitTime > 0 && requestFilterInitTime + 5000 > new Date().getTime();
  };
  /**
   * @param {MatchQuery} matchQuery - {@link MatchQuery}
   */


  const findRuleForRequest = function (matchQuery) {
    return getRequestFilter().findRuleForRequest(matchQuery);
  };
  /**
   * @param {MatchQuery} matchQuery - {@link MatchQuery}
   */


  const findAllowlistRule = function (matchQuery) {
    return getRequestFilter().findAllowlistRule(matchQuery);
  };

  const findDocumentRule = function (documentUrl) {
    return getRequestFilter().findDocumentRule(documentUrl);
  };
  /**
   * @param {MatchQuery} matchQuery - {@link MatchQuery}
   */


  const findStealthAllowlistRule = function (matchQuery) {
    return getRequestFilter().findStealthAllowlistRule(matchQuery);
  };

  const getSelectorsForUrl = function (documentUrl, cosmeticOptions, traditionalCss, extCss) {
    return getRequestFilter().getSelectorsForUrl(documentUrl, cosmeticOptions, !traditionalCss, !extCss);
  };

  const getScriptsStringForUrl = function (documentUrl, tab, cosmeticOptions) {
    return getRequestFilter().getScriptsStringForUrl(documentUrl, tab, cosmeticOptions);
  };

  const getContentRulesForUrl = function (documentUrl) {
    return getRequestFilter().getContentRulesForUrl(documentUrl);
  };
  /**
   * @param {MatchQuery} matchQuery - {@link MatchQuery}
   */


  const getCspRules = function (matchQuery) {
    return getRequestFilter().findCspRules(matchQuery);
  };
  /**
   * @param {MatchQuery} matchQuery - {@link MatchQuery}
   */


  const getCookieRules = function (matchQuery) {
    return getRequestFilter().findCookieRules(matchQuery);
  };
  /**
   * @param {MatchQuery} matchQuery - {@link MatchQuery}
   */


  const getReplaceRules = function (matchQuery) {
    return getRequestFilter().findReplaceRules(matchQuery);
  };
  /**
   * @param {MatchQuery} matchQuery - {@link MatchQuery}
   */


  const getCosmeticOption = function (matchQuery) {
    return getRequestFilter().getMatchingResult(matchQuery).getCosmeticOption();
  };
  /**
   * @param {MatchQuery} matchQuery - {@link MatchQuery}
   */


  const getRemoveParamRules = function (matchQuery) {
    return getRequestFilter().getMatchingResult(matchQuery).getRemoveParamRules();
  };
  /**
   * @param {MatchQuery} matchQuery - {@link MatchQuery}
   */


  const getRemoveHeaderRules = function (matchQuery) {
    return getRequestFilter().getMatchingResult(matchQuery).getRemoveHeaderRules();
  };

  const getRequestFilterInfo = function () {
    return antiBannerService.getRequestFilterInfo();
  };

  return {
    isReady,
    shouldCollapseAllElements,
    findRuleForRequest,
    findAllowlistRule,
    findDocumentRule,
    getSelectorsForUrl,
    getScriptsStringForUrl,
    getContentRulesForUrl,
    getCspRules,
    getCookieRules,
    getReplaceRules,
    getRemoveParamRules,
    getRemoveHeaderRules,
    findStealthAllowlistRule,
    getCosmeticOption,
    getRequestFilterInfo
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/tabs/frames.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */









/**
 * Object that contains info about every browser tab.
 */

const frames_frames = function () {
  /**
   * Adds frame to map. This method is called on first document request.
   * If this is a main frame - saves this info in frame data.
   *
   * @param tab       Tab object
   * @param frameId   Frame ID
   * @param url       Page URL
   * @param type      Request content type (UrlFilterRule.contentTypes)
   * @returns Frame data
   */
  const recordFrame = function (tab, frameId, url, type) {
    const frame = tabsApi.getTabFrame(tab.tabId, frameId);
    let previousUrl = '';

    if (type === request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT) {
      tabsApi.clearTabFrames(tab.tabId);
      tabsApi.clearTabMetadata(tab.tabId);

      if (frame) {
        previousUrl = frame.url;
      }
    }

    tabsApi.recordTabFrame(tab.tabId, frameId, url, utils.url.getDomainName(url));

    if (type === request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT) {
      tabsApi.updateTabMetadata(tab.tabId, {
        previousUrl
      });
      reloadFrameData(tab);
    }
  };
  /**
   * This method reloads frame data and updates previous url if necessary
   * We use it in the webRequest.onCommit event because when website uses service worker
   * main_frame request can not fire in the webRequest events
   * @param tab
   * @param frameId
   * @param url
   * @param type
   */


  const checkAndRecordMainFrame = (tab, frameId, url, type) => {
    if (type !== request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT) {
      return;
    }

    const {
      tabId
    } = tab;
    const frame = tabsApi.getTabFrame(tabId, frameId); // If no main_frame in tab, than we consider this as a new page load

    if (!frame) {
      tabsApi.recordTabFrame(tabId, frameId, url, utils.url.getDomainName(url));
      reloadFrameData(tab);
      return;
    } // if frame has different rule, then we consider this as a new page load


    let previousUrl = '';

    if (frame && frame.url !== url) {
      previousUrl = frame.url;
      tabsApi.clearTabFrames(tabId);
      tabsApi.clearTabMetadata(tabId);
      tabsApi.recordTabFrame(tabId, frameId, url, utils.url.getDomainName(url));
      tabsApi.updateTabMetadata(tabId, {
        previousUrl
      });
      reloadFrameData(tab);
    }
  };
  /**
   * Gets frame URL
   *
   * @param tab       Tab
   * @param frameId   Frame ID
   * @returns Frame URL
   */


  const getFrameUrl = function (tab, frameId) {
    const frame = tabsApi.getTabFrame(tab.tabId, frameId);
    return frame ? frame.url : null;
  };
  /**
   * Gets main frame URL
   *
   * @param tab    Tab
   * @returns Frame URL
   */


  const getMainFrameUrl = function (tab) {
    return getFrameUrl(tab, MAIN_FRAME_ID);
  };
  /**
   * Gets frame Domain
   *
   * @param tab       Tab
   * @returns Frame Domain
   */


  const getFrameDomain = function (tab) {
    const frame = tabsApi.getTabFrame(tab.tabId, 0);
    return frame ? frame.domainName : null;
  };
  /**
   * @param tab Tab
   * @returns true if Tab have allowlist rule
   */


  const isTabAllowlisted = function (tab) {
    const frameRule = tabsApi.getTabMetadata(tab.tabId, 'frameRule');
    return frameRule && frameRule.isDocumentAllowlistRule();
  };
  /**
   * @param tab Tab
   * @returns true if Tab have allowlist rule and allowlist isn't invert
   */


  const isTabAllowlistedForSafebrowsing = function (tab) {
    return isTabAllowlisted(tab) && allowlist.isDefaultMode();
  };
  /**
   * @param tab Tab
   * @returns true if protection is paused
   */


  const isTabProtectionDisabled = function (tab) {
    return tabsApi.getTabMetadata(tab.tabId, 'applicationFilteringDisabled');
  };
  /**
   * Returns true if tab is in allowlist
   *
   * @param tab Tab
   * @returns true if Adguard for Windows/Android/Mac is detected and tab in allowlist
   */


  const isTabAdguardAllowlisted = function (tab) {
    return tabsApi.getTabMetadata(tab.tabId, 'adguardDocumentAllowlisted');
  };
  /**
   * @param tab   Tab
   * @returns Adguard allowlist rule in user filter associated with this tab
   */


  const getTabAdguardUserAllowlistRule = function (tab) {
    const adguardUserAllowlisted = tabsApi.getTabMetadata(tab.tabId, 'adguardUserAllowlisted');

    if (adguardUserAllowlisted) {
      return tabsApi.getTabMetadata(tab.tabId, 'adguardAllowlistRule');
    }

    return null;
  };
  /**
   * Gets allowlist rule for the specified tab
   * @param tab Tab to check
   * @returns allowlist rule applied to that tab (if any)
   */


  const getFrameRule = function (tab) {
    return tabsApi.getTabMetadata(tab.tabId, 'frameRule');
  };
  /**
   * Reloads tab data (checks allowlist and filtering status)
   *
   * @param tab Tab to reload
   */


  const reloadFrameData = function (tab) {
    const frame = tabsApi.getTabFrame(tab.tabId, 0);

    if (frame) {
      const applicationFilteringDisabled = settings.isFilteringDisabled();
      let frameRule = null;

      if (!applicationFilteringDisabled) {
        const {
          url
        } = frame;
        frameRule = allowlist.findAllowlistRule(url);

        if (!frameRule) {
          frameRule = filteringApi.findDocumentRule(url);
        }
      }

      tabsApi.updateTabMetadata(tab.tabId, {
        frameRule,
        applicationFilteringDisabled
      });
    }
  };
  /**
   * Attach referrer url to the tab's main frame object.
   * This referrer is then used on safebrowsing "Access Denied" for proper "Go Back" behavior.
   *
   * @param tab Tab
   * @param referrerUrl Referrer to record
   */


  const recordFrameReferrerHeader = function (tab, referrerUrl) {
    tabsApi.updateTabMetadata(tab.tabId, {
      referrerUrl
    });
  };
  /**
   * Gets main frame data
   *
   * @param tab Tab
   * @returns {*} frame data
   */


  const getFrameInfo = function (tab) {
    const {
      tabId
    } = tab;
    const frame = tabsApi.getTabFrame(tabId);
    let {
      url
    } = tab;

    if (!url && frame) {
      url = frame.url;
    }

    const localStorageInitialized = storage_localStorage.isInitialized();
    const urlFilteringDisabled = !utils.url.isHttpRequest(url); // application is available for tabs where url is with http schema
    // and when localstorage is initialized

    const applicationAvailable = localStorageInitialized && !urlFilteringDisabled;
    let documentAllowlisted = false;
    let userAllowlisted = false;
    let canAddRemoveRule = false;
    let frameRule;
    const adguardProductName = '';
    const totalBlocked = pageStats.getTotalBlocked() || 0;
    const totalBlockedTab = tabsApi.getTabMetadata(tabId, 'blocked') || 0;
    const applicationFilteringDisabled = settings.isFilteringDisabled();

    if (applicationAvailable) {
      documentAllowlisted = isTabAllowlisted(tab);

      if (documentAllowlisted) {
        const rule = getFrameRule(tab);
        userAllowlisted = utils.filters.isAllowlistFilterRule(rule) || utils.filters.isUserFilterRule(rule);
        frameRule = {
          filterId: rule.getFilterListId(),
          ruleText: rule.getText()
        };
      } // It means site in exception


      canAddRemoveRule = !(documentAllowlisted && !userAllowlisted);
    }

    const domainName = getFrameDomain(tab);
    return {
      url,
      applicationAvailable,
      domainName,
      applicationFilteringDisabled,
      urlFilteringDisabled,
      documentAllowlisted,
      userAllowlisted,
      canAddRemoveRule,
      frameRule,
      adguardProductName,
      totalBlockedTab,
      totalBlocked
    };
  };
  /**
   * Update count of blocked requests
   *
   * @param tab - Tab
   * @param blocked - count of blocked requests
   * @returns  updated count of blocked requests
   */


  const updateBlockedAdsCount = function (tab, blocked) {
    pageStats.updateTotalBlocked(blocked);
    blocked = (tabsApi.getTabMetadata(tab.tabId, 'blocked') || 0) + blocked;
    tabsApi.updateTabMetadata(tab.tabId, {
      blocked
    });
    return blocked;
  };
  /**
   * Reset count of blocked requests for tab or overall stats
   * @param tab - Tab (optional)
   */


  const resetBlockedAdsCount = function (tab) {
    if (tab) {
      tabsApi.updateTabMetadata(tab.tabId, {
        blocked: 0
      });
    } else {
      pageStats.resetStats();
    }
  };
  /**
   * Is tab in incognito mode?
   * @param tab Tab
   */


  const isIncognitoTab = function (tab) {
    return tabsApi.isIncognito(tab.tabId);
  };
  /**
   * Checks if we should process request further
   * @param {object} tab
   * @returns {boolean}
   */


  const shouldStopRequestProcess = tab => isTabProtectionDisabled(tab) || isTabAllowlisted(tab); // Records frames on application initialization


  listeners.addListener(event => {
    if (event === listeners.APPLICATION_INITIALIZED) {
      tabsApi.forEach(tab => {
        recordFrame(tab, 0, tab.url, request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT);
      });
    }
  });
  return {
    recordFrame,
    getFrameUrl,
    getMainFrameUrl,
    getFrameDomain,
    isTabAllowlisted,
    isTabAllowlistedForSafebrowsing,
    isTabProtectionDisabled,
    isTabAdguardAllowlisted,
    getTabAdguardUserAllowlistRule,
    getFrameRule,
    reloadFrameData,
    recordFrameReferrerHeader,
    getFrameInfo,
    updateBlockedAdsCount,
    resetBlockedAdsCount,
    isIncognitoTab,
    shouldStopRequestProcess,
    checkAndRecordMainFrame
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/filter/rules/hit-stats/hit-stats.browsers.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */







/**
 * This module is used to store and track ad filters usage stats.
 * It is used if user has enabled "Send statistics for ad filters usage" option.
 * More info about ad filters stats: http://adguard.com/en/filter-rules-statistics.html
 */

const browsersHitStats = function () {
  const MAX_PAGE_VIEWS_COUNT = 20;
  const HITS_COUNT_PROP = 'filters-hit-count';
  const HITS_PROP = 'h';
  let throttleTimeoutId;
  /**
   * Reads hit stats from local storage
   * @returns {null}
   */

  function getHitCountStats() {
    const json = storage_localStorage.getItem(HITS_COUNT_PROP);
    let stats = Object.create(null);

    try {
      if (json) {
        stats = JSON.parse(json);
      }
    } catch (ex) {
      log/* log.error */.c.error('Error retrieve hit count statistic, cause {0}', ex);
    }

    return stats;
  }
  /**
   * Object for aggregation hit stats (Lazy initialized)
   */


  const hitStatsHolder = {
    get hitStats() {
      return lazyGet(hitStatsHolder, 'hitStats', getHitCountStats);
    }

  };
  /**
   * Cleanup stats
   */

  function cleanup() {
    storage_localStorage.removeItem(HITS_COUNT_PROP);
    lazyGetClear(hitStatsHolder, 'hitStats');
  }
  /**
   * Sends hit stats to backend server
   */


  function sendStats() {
    const overallViews = hitStatsHolder.hitStats.views || 0;

    if (overallViews < MAX_PAGE_VIEWS_COUNT) {
      return;
    }

    const enabledFilters = application.getEnabledFilters();
    backend.sendHitStats(JSON.stringify(hitStatsHolder.hitStats), enabledFilters);
    cleanup();
  }
  /**
   * Save hit stats to local storage and invoke sendStats
   * Throttled with 2 seconds delay
   * @param stats
   */


  function saveHitsCountStats(stats) {
    if (throttleTimeoutId) {
      clearTimeout(throttleTimeoutId);
    }

    throttleTimeoutId = setTimeout(() => {
      try {
        storage_localStorage.setItem(HITS_COUNT_PROP, JSON.stringify(stats));
      } catch (ex) {
        log/* log.error */.c.error('Error save hit count statistic to storage, cause {0}', ex);
      }

      sendStats();
    }, 2000);
  }
  /**
   * Add 1 domain view to stats
   * @param domain
   */


  const addDomainView = function (domain) {
    if (!domain) {
      return;
    }

    let {
      domains
    } = hitStatsHolder.hitStats;

    if (!domains) {
      domains = Object.create(null);
      hitStatsHolder.hitStats.domains = domains;
    }

    let domainInfo = domains[domain];

    if (!domainInfo) {
      domainInfo = Object.create(null);
      domains[domain] = domainInfo;
      domainInfo.views = 0;
    }

    domainInfo.views += 1;
    hitStatsHolder.hitStats.views = (hitStatsHolder.hitStats.views || 0) + 1;
    saveHitsCountStats(hitStatsHolder.hitStats);
  };
  /**
   * Add 1 rule hit to stats
   * @param domain Domain of site where rule was applied
   * @param ruleText
   * @param filterId
   * @param requestUrl Url to which rule was applied
   */


  const addRuleHit = function (domain, ruleText, filterId, requestUrl) {
    if (!domain || !ruleText || !filterId) {
      return;
    }

    const domainInfo = hitStatsHolder.hitStats.domains ? hitStatsHolder.hitStats.domains[domain] : null;

    if (!domainInfo) {
      return;
    }

    let {
      rules
    } = domainInfo;

    if (!rules) {
      rules = Object.create(null);
      domainInfo.rules = rules;
    }

    let filterRules = rules[filterId];

    if (!filterRules) {
      filterRules = Object.create(null);
      rules[filterId] = filterRules;
    }

    if (!(ruleText in filterRules)) {
      filterRules[ruleText] = null;
    }

    let ruleInfo = filterRules[ruleText];

    if (!ruleInfo) {
      ruleInfo = Object.create(null);
      filterRules[ruleText] = ruleInfo;
    }

    if (requestUrl) {
      const requestDomain = utils.url.getDomainName(requestUrl); // Domain hits

      const domainHits = ruleInfo[requestDomain] || 0;
      ruleInfo[requestDomain] = domainHits + 1;
    } else {
      // Css hits
      const hits = ruleInfo[HITS_PROP] || 0;
      ruleInfo[HITS_PROP] = hits + 1;
    }

    saveHitsCountStats(hitStatsHolder.hitStats);
  };
  /**
   * Hit stats getter
   */


  const getStats = function () {
    return hitStatsHolder.hitStats;
  };
  /**
   * Cleanup stats on property disabled
   */


  settings.onUpdated.addListener(setting => {
    if (setting === settings.DISABLE_COLLECT_HITS && !settings.collectHitsCount()) {
      cleanup();
    }
  });
  return {
    addRuleHit,
    addDomainView,
    cleanup,
    getStats
  };
}();

/* harmony default export */ const hit_stats_browsers = (browsersHitStats);
;// CONCATENATED MODULE: ./Extension/src/background/filter/rules/hit-stats/index.js
/**
 * !IMPORTANT!
 * './hit-stats.__ABSTRACT_API__.js' is replaced during webpack compilation
 * with NormalModuleReplacementPlugin to proper browser implementation
 * './hit-stats.adguard-api.js' or './hit-stats.browsers.js'
 */


;// CONCATENATED MODULE: ./Extension/src/background/filter/request-context-storage.js














/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */

/* eslint-disable max-len */



/**
 * Module for managing requests context.
 *
 * Each request has a context with unique key: requestId
 * Context contains information about this request: id, url, referrer, type, applied rules, original and modified headers
 *
 * This API is exposed via requestContextStorage:
 *
 * - get - Get context by key
 * - record - Initialize context for request (uses in onBeforeRequest)
 * - update - Updates context properties (rules)
 * - bindContentRule - Binds content rule and removed element to the context
 * - onContentModificationStarted - Must be called to point that content modification is started
 *   Following 2 methods have same logic (push rules to log, record rule hits and perform cleanup), but called in different cases:
 * - onRequestCompleted - Finishes request processing on request complete/error event.
 * - onContentModificationFinished - After content modification and applying all rules (replace and content)
 */

const requestContextStorage = function () {
  /**
   * @typedef {object} RequestContext
   * @property {string} requestId - Request identifier
   * @property {string} requestUrl - Request url
   * @property {string} referrerUrl - Request referrer url
   * @property {string} requestType - Request type
   * @property {number} engineRequestType - TsUrlFilter Request type
   * @property {{tabId: Number}} tab - Request tab
   * @property {Array} requestHeaders - Original request headers
   * @property {Array} modifiedRequestHeaders - Modified request headers
   * @property {Array} responseHeaders - Original response headers
   * @property {Array} modifiedResponseHeaders - Modified response headers
   * @property {object} requestRule - Request rule
   * @property {Array} replaceRules - Applied replace rules
   * @property {Array} contentRules - Content rules
   * @property {Array} cspRules CSP - rules
   * @property {number} eventId - Internal counter for log events
   * @property {number} requestState - Is request between onBeforeRequest and onCompleted/onErrorOccurred events
   * @property {number} contentModifyingState - Is content modification started
   * @property {Map<object, string[]>} elements - Content rules attached elements
   * @property {number} stealthActions - Applied stealth actions
   * @property {boolean} cspReportBlocked - Blocked because is csp report request
   * @property {number} statusCode Response status code
   * @property {number} timestamp Request UTC timestamp
   */

  /**
   * @typedef {object} States
   * @property {number} NONE - Ready for cleanup (not started or already finished and processed)
   * @property {number} PROCESSING - In progress
   * @property {number} DONE - Finished, ready for processing. Next transition to NONE and cleanup
   */
  const States = {
    NONE: 1,
    PROCESSING: 2,
    DONE: 3
  };
  /**
   * Collects context
   * @type {Map<string, RequestContext>}
   */

  const contexts = new Map();
  /**
   * Event counter for pushing rules to the filtering log on request complete/error
   * Don't use requestId, because redirected requests have the same request identifier
   * @type {number}
   */

  let nextEventId = 0;
  /**
   * Append rules to the current rules
   * @param {Array} original - Original value
   * @param {Array} toAppend - Value to append
   * @returns {Array} concatenated value
   */

  const appendRules = (original, toAppend) => {
    if (toAppend) {
      original = (original || []).concat(toAppend);
    }

    return original;
  };
  /**
   * Creates copy of headers array
   * @param headers Headers to copy
   * @return {{name: *, value: *}[]}
   */


  const copyHeaders = headers => (headers || []).map(h => ({
    name: h.name,
    value: h.value
  }));
  /**
   * Generates next event identifier
   * @returns {number}
   */


  const getNextEventId = () => {
    nextEventId += 1;
    return nextEventId;
  };
  /**
   * Gets request context
   * @param {string} requestId Request identifier
   */


  const get = requestId => {
    return contexts.get(String(requestId));
  };
  /**
   * Records request context
   * @param {Object} params params object
   * @param {string} params.requestId Request identifier
   * @param {string} params.requestUrl Request url
   * @param {string} params.referrerUrl Request referrer url
   * @param {string} params.originUrl Request origin url (initiator)
   * @param {string} params.requestType Request type
   * @param {string} params.engineRequestType TsUrlFilter Request type
   * @param {Object} params.tab Request tab
   * @param {string} params.method Request HTTP method
   */


  const record = ({
    requestId,
    requestUrl,
    referrerUrl,
    originUrl,
    requestType,
    engineRequestType,
    tab,
    method
  }) => {
    const eventId = getNextEventId(); // Clears filtering log. If contexts map already contains this requests that means that we caught redirect

    if (requestType === request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT && !contexts.has(String(requestId))) {
      filtering_log_browsers.clearEventsByTabId(tab.tabId);
    }

    const timestamp = Date.now();
    const context = {
      requestId,
      requestUrl,
      referrerUrl,
      originUrl,
      requestType,
      engineRequestType,
      tab,
      eventId,
      requestState: States.PROCESSING,
      contentModifyingState: States.NONE,
      timestamp,
      method
    };
    contexts.set(String(requestId), context);
    filtering_log_browsers.addHttpRequestEvent({
      tab,
      requestUrl,
      frameUrl: referrerUrl,
      requestType,
      timestamp,
      eventId,
      method
    });
    return context;
  };
  /**
   * Some "requests" can't be intercepted by webRequest API: WS and WebRTC, popups.
   * So them don't have usual request identifier and must be processing in the other way.
   * @param {Object} params params object
   * @param {string} params.requestUrl  Request URL
   * @param {string} params.referrerUrl  Referrer
   * @param {string} params.requestType  Request type
   * @param {Object} params.tab  Tab
   * @param {Object} params.requestRule  Request rule
   */


  const recordEmulated = ({
    requestUrl,
    referrerUrl,
    requestType,
    tab,
    requestRule
  }) => {
    filtering_log_browsers.addHttpRequestEvent({
      tab,
      requestUrl,
      frameUrl: referrerUrl,
      requestType,
      requestRule,
      timestamp: Date.now()
    });
    webRequestService.recordRuleHit(tab, requestRule, requestUrl);
  };
  /**
   * Updates request context
   * @param {string} requestId Request identifier
   * @param {RequestContext} update
   */


  const update = (requestId, update) => {
    const context = contexts.get(String(requestId));

    if (!context) {
      return;
    } // Updates request lifecycle


    if ('requestState' in update) {
      context.requestState = update.requestState;
    }

    if ('contentModifyingState' in update) {
      context.contentModifyingState = update.contentModifyingState;
    } // Updates rules for request


    if ('requestRule' in update) {
      context.requestRule = update.requestRule; // Some requests may execute for a long time, that's why we update filtering log when
      // we get a request rule

      filtering_log_browsers.bindRuleToHttpRequestEvent(context.tab, context.requestRule, context.eventId);
    }

    if ('replaceRules' in update) {
      context.replaceRules = update.replaceRules;
    }

    if ('cspRules' in update) {
      context.cspRules = appendRules(context.cspRules, update.cspRules);
    }

    if ('stealthActions' in update) {
      context.stealthActions = update.stealthActions;
    }

    if ('requestHeaders' in update) {
      context.requestHeaders = copyHeaders(update.requestHeaders);
    }

    if ('responseHeaders' in update) {
      context.responseHeaders = copyHeaders(update.responseHeaders);
    }

    if ('modifiedRequestHeaders' in update) {
      context.modifiedRequestHeaders = copyHeaders(update.modifiedRequestHeaders);
    }

    if ('modifiedResponseHeaders' in update) {
      context.modifiedResponseHeaders = copyHeaders(update.modifiedResponseHeaders);
    }

    if ('cspReportBlocked' in update) {
      context.cspReportBlocked = update.cspReportBlocked;
    }

    if ('statusCode' in update) {
      context.statusCode = update.statusCode;
      filtering_log_browsers.bindResponseDataToHttpRequestEvent(context.tab, context.statusCode, context.eventId);
    }

    if ('contentType' in update) {
      context.contentType = update.contentType;
    }
  };
  /**
   * Binds content rule with serialized element to the request
   *
   * @param {string} requestId Request identifier
   * @param {object} rule Content rule
   * @param {object} elementHtml Serialized HTML element
   */


  const bindContentRule = (requestId, rule, elementHtml) => {
    const context = contexts.get(String(requestId));

    if (!context) {
      return;
    }

    context.contentRules = appendRules(context.contentRules, [rule]);

    if (!context.elements) {
      context.elements = new Map();
    }

    let ruleElements = context.elements.get(rule);

    if (!ruleElements) {
      ruleElements = [];
      context.elements.set(rule, ruleElements);
    }

    ruleElements.push(elementHtml);
  };
  /**
   * Finishes request processing
   *
   * Invoked in the following cases:
   * 1) on complete/error event for request
   * 2) on content modification finished
   *
   * In case of content modification don't forget to call onContentModificationStarted method
   * to prevent removing context for complete/error event for request
   *
   * @param {string} requestId Request identifier
   */


  const remove = requestId => {
    const context = contexts.get(String(requestId));

    if (!context) {
      return;
    }

    const {
      tab,
      requestUrl,
      referrerUrl
    } = context;
    let ruleHitsRecords = [];

    if (context.requestState === States.DONE) {
      context.requestState = States.NONE;
      const {
        requestRule,
        cspRules,
        stealthActions,
        cspReportBlocked
      } = context;

      if (requestRule) {
        filtering_log_browsers.bindRuleToHttpRequestEvent(tab, requestRule, context.eventId);
        ruleHitsRecords.push(requestRule);
      }

      if (cspRules) {
        cspRules.forEach(cspRule => {
          filtering_log_browsers.addHttpRequestEvent({
            tab,
            requestUrl,
            frameUrl: referrerUrl,
            requestType: request_types/* RequestTypes.CSP */.l.CSP,
            requestRule: cspRule,
            timestamp: Date.now()
          });
        });
        ruleHitsRecords = ruleHitsRecords.concat(cspRules);
      }

      if (stealthActions) {
        filtering_log_browsers.bindStealthActionsToHttpRequestEvent(tab, stealthActions, context.eventId);
      }

      if (cspReportBlocked) {
        filtering_log_browsers.bindCspReportBlockedToHttpRequestEvent(tab, cspReportBlocked, context.eventId);
      }
    }

    if (context.contentModifyingState === States.DONE) {
      context.contentModifyingState = States.NONE;
      const {
        replaceRules
      } = context;
      const {
        contentRules
      } = context;

      if (replaceRules) {
        filtering_log_browsers.bindReplaceRulesToHttpRequestEvent(tab, replaceRules, context.eventId);
        ruleHitsRecords = ruleHitsRecords.concat(replaceRules);
      }

      if (contentRules) {
        contentRules.forEach(contentRule => {
          const elements = context.elements.get(contentRule) || [];
          elements.forEach(element => {
            filtering_log_browsers.addCosmeticEvent({
              tab,
              element,
              frameUrl: requestUrl,
              requestType: context.requestType,
              requestRule: contentRule,
              timestamp: Date.now()
            });
          });
          context.elements.delete(contentRule);
        });
        ruleHitsRecords = ruleHitsRecords.concat(contentRules);
      }
    }

    for (let i = 0; i < ruleHitsRecords.length; i += 1) {
      webRequestService.recordRuleHit(tab, ruleHitsRecords[i], requestUrl);
    } // All processes finished


    if (context.requestState === States.NONE && context.contentModifyingState === States.NONE) {
      contexts.delete(String(requestId));
    }
  };
  /**
   * Called on request complete/error event
   *
   * @param {string} requestId Request identifier
   * @param {number} statusCode Response status code
   */


  const onRequestCompleted = (requestId, statusCode) => {
    update(requestId, {
      requestState: States.DONE,
      statusCode
    });
    remove(requestId);
  };
  /**
   * Indicates that content modification in progress
   *
   * @param {string} requestId Request identifier
   */


  const onContentModificationStarted = requestId => {
    update(requestId, {
      contentModifyingState: States.PROCESSING
    });
  };
  /**
   * Indicates that content modification finished
   *
   * @param {string} requestId Request identifier
   */


  const onContentModificationFinished = requestId => {
    update(requestId, {
      contentModifyingState: States.DONE
    });
    remove(requestId);
  }; // Expose


  return {
    get,
    record,
    recordEmulated,
    update,
    bindContentRule,
    onRequestCompleted,
    onContentModificationStarted,
    onContentModificationFinished
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/utils/expiring-cache.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */


const ExpiringCache = (() => {
  /**
   * Cache with maxCacheSize stored in local storage, which automatically clears expired values
   *
   * @param {string} storagePropertyName      Name of the local storage property.
   * @param {number} size                     Max cache size
   */
  function ExpiringCache(storagePropertyName, size) {
    const CACHE_SIZE = 1000;
    const maxCacheSize = size || CACHE_SIZE;
    let cache;
    let cacheSize;

    function getCacheFromLocalStorage() {
      let data = Object.create(null);

      try {
        const json = storage_localStorage.getItem(storagePropertyName);

        if (json) {
          data = JSON.parse(json);
        }
      } catch (ex) {
        // ignore
        log/* log.error */.c.error('Error read from {0} cache, cause: {1}', storagePropertyName, ex);
        storage_localStorage.removeItem(storagePropertyName);
      }

      return data;
    }

    function saveCacheToLocalStorage() {
      try {
        storage_localStorage.setItem(storagePropertyName, JSON.stringify(cache));
      } catch (ex) {
        log/* log.error */.c.error('Error save to {0} cache, cause: {1}', storagePropertyName, ex);
      }
    }
    /**
     * Retrieves value from cache and checks if saved data is not expired yet.
     * @param {string} key
     * @returns {null|object} saved data
     */


    function getValue(key) {
      const value = cache[key];

      if (value !== undefined) {
        const expires = value.expires - 0;

        if (Date.now() >= expires) {
          return null;
        }

        return value.data;
      }

      return null;
    }

    function cleanup() {
      const keys = Object.keys(cache);

      for (let i = 0; i < keys.length; i += 1) {
        const key = keys[i];
        const foundItem = getValue(key);

        if (!foundItem) {
          delete cache[key];
          cacheSize -= 1;
        }
      }

      if (cacheSize > maxCacheSize / 2) {
        const keys = Object.keys(cache);

        for (let i = 0; i < keys.length; i += 1) {
          const key = keys[i];
          delete cache[key];
          cacheSize -= 1;

          if (cacheSize <= maxCacheSize / 2) {
            break;
          }
        }
      }

      saveCacheToLocalStorage();
    }

    const saveValue = function (key, data, expires) {
      if (!key) {
        return;
      }

      if (cacheSize > maxCacheSize) {
        cleanup();
      }

      cache[key] = {
        data,
        expires
      };
      cacheSize += 1;

      if (cacheSize % 20 === 0) {
        saveCacheToLocalStorage();
      }
    }; // Load cache


    cache = getCacheFromLocalStorage();
    cacheSize = Object.keys(cache).length;
    cleanup();
    return {
      getValue,
      saveValue
    };
  }
  /**
   * Expose
   */


  return ExpiringCache;
})();
;// CONCATENATED MODULE: ./Extension/src/background/filter/services/document-filter.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */








const documentFilterService = function () {
  const trustedCache = {
    get cache() {
      return lazyGet(trustedCache, 'cache', () => new ExpiringCache('document-block-cache'));
    }

  };

  function documentFilterService() {
    const TRUSTED_TTL_MS = 1000 * 60 * 40; // 40 minutes

    const DOCUMENT_BLOCKED_URL = 'pages/ad-blocked.html';
    /**
     * Checks if url is trusted
     * @param url
     * @returns {boolean}
     */

    const isTrusted = url => {
      const host = utils.url.getHost(url);

      if (!host) {
        return false;
      }

      const value = trustedCache.cache.getValue(host);
      return !!value;
    };
    /**
     * Return url of the document block page and ads there parameters with rule and url
     * @param url
     * @param ruleText
     * @returns {null|string}
     */


    const getDocumentBlockPageUrl = (url, ruleText) => {
      if (isTrusted(url)) {
        return null;
      }

      let blockingUrl = backgroundPage.getURL(DOCUMENT_BLOCKED_URL);
      blockingUrl += `?url=${encodeURIComponent(url)}`;
      blockingUrl += `&rule=${encodeURIComponent(ruleText)}`;
      return blockingUrl;
    };
    /**
     * Gets url host and adds it to the cache of trusted domains
     * @param url
     */


    const addToTrusted = async url => {
      const host = utils.url.getHost(url);

      if (!host) {
        return;
      }

      trustedCache.cache.saveValue(host, {
        host
      }, Date.now() + TRUSTED_TTL_MS); // Reloads ad-blocked page with trusted url

      const tab = await tabsApi.getActive();

      if (tab) {
        tabsApi.reload(tab.tabId, url);
      }
    };
    /**
     * Shows document block page
     * @param tabId
     * @param url
     */


    const showDocumentBlockPage = (tabId, url) => {
      const incognitoTab = frames_frames.isIncognitoTab({
        tabId
      }); // Chrome doesn't allow to show extension pages in incognito mode

      if (incognitoTab && browserUtils.isChromium()) {
        // Closing tab before opening a new one may lead to browser crash (Chromium)
        uiService.openTab(url).then(() => {
          tabsApi.remove(tabId);
        });
      } else {
        tabsApi.updateUrl(tabId, url);
      }
    };

    return {
      getDocumentBlockPageUrl,
      addToTrusted,
      showDocumentBlockPage
    };
  }

  return documentFilterService();
}();
;// CONCATENATED MODULE: ./node_modules/@adguard/tsurlfilter/dist/es/headers-89035da7.js
/**
 * Finds header object by header name (case insensitive)
 *
 * @param headers Headers collection
 * @param headerName Header name
 * @returns header value
 */
function findHeaderByName(headers, headerName) {
    for (var i = 0; i < headers.length; i += 1) {
        var header = headers[i];
        if (header.name.toLowerCase() === headerName.toLowerCase()) {
            return header;
        }
    }
    return null;
}
/**
 * Removes header from headers by name
 *
 * @param {Array} headers
 * @param {String} headerName
 * @return {boolean} True if header were removed
 */
function removeHeader(headers, headerName) {
    var removed = false;
    if (headers) {
        for (var i = headers.length - 1; i >= 0; i -= 1) {
            var header = headers[i];
            if (header.name.toLowerCase() === headerName.toLowerCase()) {
                headers.splice(i, 1);
                removed = true;
            }
        }
    }
    return removed;
}



// EXTERNAL MODULE: ./node_modules/@adguard/tsurlfilter/dist/es/url-94de2ee3.js
var url_94de2ee3 = __webpack_require__(54523);
// EXTERNAL MODULE: ./node_modules/@adguard/tsurlfilter/dist/es/request-type.js
var request_type = __webpack_require__(68261);
;// CONCATENATED MODULE: ./node_modules/@adguard/tsurlfilter/dist/es/stealth-service.js




/**
 * This module applies stealth actions in page context
 */
var StealthHelper = /** @class */ (function () {
    function StealthHelper() {
    }
    /**
     * Sends a Global Privacy Control DOM signal
     */
    StealthHelper.setDomSignal = function () {
        try {
            if ('globalPrivacyControl' in Navigator.prototype) {
                return;
            }
            Object.defineProperty(Navigator.prototype, 'globalPrivacyControl', {
                get: function () { return true; },
                configurable: true,
                enumerable: true,
            });
        }
        catch (ex) {
            // Ignore
        }
    };
    return StealthHelper;
}());

/**
 * Stealth action bitwise masks
 */
var StealthActions;
(function (StealthActions) {
    StealthActions[StealthActions["HIDE_REFERRER"] = 1] = "HIDE_REFERRER";
    StealthActions[StealthActions["HIDE_SEARCH_QUERIES"] = 2] = "HIDE_SEARCH_QUERIES";
    StealthActions[StealthActions["BLOCK_CHROME_CLIENT_DATA"] = 4] = "BLOCK_CHROME_CLIENT_DATA";
    StealthActions[StealthActions["SEND_DO_NOT_TRACK"] = 8] = "SEND_DO_NOT_TRACK";
    StealthActions[StealthActions["FIRST_PARTY_COOKIES"] = 16] = "FIRST_PARTY_COOKIES";
    StealthActions[StealthActions["THIRD_PARTY_COOKIES"] = 32] = "THIRD_PARTY_COOKIES";
})(StealthActions || (StealthActions = {}));
/**
 * Stealth service module
 */
var StealthService = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param config
     */
    function StealthService(config) {
        this.config = config;
    }
    /**
     * Returns synthetic set of rules matching the specified request
     */
    StealthService.prototype.getCookieRulesTexts = function () {
        var result = [];
        if (this.config.selfDestructFirstPartyCookies) {
            result.push(StealthService.generateCookieRuleText(this.config.selfDestructFirstPartyCookiesTime));
        }
        if (this.config.selfDestructThirdPartyCookies) {
            result.push(StealthService.generateCookieRuleText(this.config.selfDestructThirdPartyCookiesTime, true));
        }
        return result;
    };
    /**
     * Applies stealth actions to request headers
     *
     * @param requestUrl
     * @param requestType
     * @param requestHeaders
     */
    StealthService.prototype.processRequestHeaders = function (requestUrl, requestType, requestHeaders) {
        var stealthActions = 0;
        // Remove referrer for third-party requests
        if (this.config.hideReferrer) {
            var refHeader = findHeaderByName(requestHeaders, StealthService.HEADERS.REFERRER);
            if (refHeader
                && refHeader.value
                && (0,url_94de2ee3.b)(requestUrl, refHeader.value)) {
                refHeader.value = StealthService.createMockRefHeaderUrl(requestUrl);
                stealthActions |= StealthActions.HIDE_REFERRER;
            }
        }
        // Hide referrer in case of search engine is referrer
        var isMainFrame = requestType === request_type/* RequestType.Document */.x.Document;
        if (this.config.hideSearchQueries && isMainFrame) {
            var refHeader = findHeaderByName(requestHeaders, StealthService.HEADERS.REFERRER);
            if (refHeader
                && refHeader.value
                && StealthService.isSearchEngine(refHeader.value)
                && (0,url_94de2ee3.b)(requestUrl, refHeader.value)) {
                refHeader.value = StealthService.createMockRefHeaderUrl(requestUrl);
                stealthActions |= StealthActions.HIDE_SEARCH_QUERIES;
            }
        }
        // Remove X-Client-Data header
        if (this.config.blockChromeClientData) {
            if (removeHeader(requestHeaders, StealthService.HEADERS.X_CLIENT_DATA)) {
                stealthActions |= StealthActions.BLOCK_CHROME_CLIENT_DATA;
            }
        }
        // Adding Do-Not-Track (DNT) header
        if (this.config.sendDoNotTrack) {
            requestHeaders.push(StealthService.HEADER_VALUES.DO_NOT_TRACK);
            requestHeaders.push(StealthService.HEADER_VALUES.GLOBAL_PRIVACY_CONTROL);
            stealthActions |= StealthActions.SEND_DO_NOT_TRACK;
        }
        return stealthActions;
    };
    /**
     * Returns set dom signal script if sendDoNotTrack enabled, otherwise empty string
     */
    StealthService.prototype.getSetDomSignalScript = function () {
        if (this.config.sendDoNotTrack) {
            return "(".concat(StealthHelper.setDomSignal.toString(), ")()");
        }
        return '';
    };
    /**
     * Generates rule removing cookies
     *
     * @param maxAgeMinutes Cookie maxAge in minutes
     * @param isThirdParty Flag for generating third-party rule texts
     */
    StealthService.generateCookieRuleText = function (maxAgeMinutes, isThirdParty) {
        if (isThirdParty === void 0) { isThirdParty = false; }
        var maxAgeOption = maxAgeMinutes > 0 ? ";maxAge=".concat(maxAgeMinutes * 60) : '';
        var thirdPartyOption = isThirdParty ? ',third-party' : '';
        var ruleText = "$cookie=/.+/".concat(maxAgeOption).concat(thirdPartyOption);
        return ruleText;
    };
    /**
     * Crops url path
     *
     * @param url URL
     * @return URL without path
     */
    StealthService.createMockRefHeaderUrl = function (url) {
        var host = (0,url_94de2ee3.d)(url);
        return "".concat((url.indexOf('https') === 0 ? 'https://' : 'http://') + host, "/");
    };
    /**
     * Is url search engine
     *
     * @param url
     */
    StealthService.isSearchEngine = function (url) {
        return StealthService.SEARCH_ENGINES.some(function (searchEngineRegex) { return searchEngineRegex.test(url); });
    };
    /**
     * Headers
     */
    StealthService.HEADERS = {
        REFERRER: 'Referer',
        X_CLIENT_DATA: 'X-Client-Data',
        DO_NOT_TRACK: 'DNT',
    };
    /**
     * Header values
     */
    StealthService.HEADER_VALUES = {
        DO_NOT_TRACK: {
            name: 'DNT',
            value: '1',
        },
        GLOBAL_PRIVACY_CONTROL: {
            name: 'Sec-GPC',
            value: '1',
        },
    };
    /**
     * Search engines regexps
     *
     * @type {Array.<string>}
     */
    StealthService.SEARCH_ENGINES = [
        /https?:\/\/(www\.)?google\./i,
        /https?:\/\/(www\.)?yandex\./i,
        /https?:\/\/(www\.)?bing\./i,
        /https?:\/\/(www\.)?yahoo\./i,
        /https?:\/\/(www\.)?go\.mail\.ru/i,
        /https?:\/\/(www\.)?ask\.com/i,
        /https?:\/\/(www\.)?aol\.com/i,
        /https?:\/\/(www\.)?baidu\.com/i,
        /https?:\/\/(www\.)?seznam\.cz/i,
    ];
    return StealthService;
}());



;// CONCATENATED MODULE: ./Extension/src/background/filter/services/stealth-service.js


/* eslint-disable no-use-before-define */

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */













/**
 * Class to apply stealth settings
 * - Cookie
 * - Headers
 * - WebRTC
 */

const stealthService = (() => {
  /**
   * Privacy permission for block webrtc stealth setting
   */
  const PRIVACY_PERMISSIONS = {
    permissions: ['privacy']
  };
  /**
   * Processes request headers
   *
   * @param {string} requestId Request identifier
   * @param {Array} requestHeaders Request headers
   * @return {boolean} True if headers were modified
   */

  const processRequestHeaders = function (requestId, requestHeaders) {
    const context = requestContextStorage.get(requestId);

    if (!context) {
      return false;
    }

    const {
      requestUrl,
      requestType
    } = context;
    log/* log.debug */.c.debug('Stealth service processing request headers for {0}', requestUrl);

    if (!canApplyStealthActionsToContext(context)) {
      return false;
    }

    const stealthActions = engine.processRequestHeaders(requestUrl, request_types/* RequestTypes.transformRequestType */.l.transformRequestType(requestType), requestHeaders);

    if (stealthActions > 0) {
      requestContextStorage.update(requestId, {
        stealthActions
      });
    }

    log/* log.debug */.c.debug('Stealth service processed request headers for {0}', requestUrl);
    return stealthActions > 0;
  };
  /**
   * Returns rule list with stealth mode rules
   * @return {StringRuleList}
   */


  const getStealthModeRuleList = () => {
    const rulesTexts = engine.getCookieRulesTexts().join('\n');
    return new es/* StringRuleList */.eq(utils.filters.STEALTH_MODE_FILTER_ID, rulesTexts, false, false);
  };
  /**
   * Checks is engine has stealth mode rules
   * @return {boolean}
   */


  const hasFilterRules = () => {
    return engine.getCookieRulesTexts().length > 0;
  };
  /**
   * Checks if stealth actions are available for provided request context
   *
   * @param context
   * @return {boolean}
   */


  const canApplyStealthActionsToContext = context => {
    const {
      requestUrl,
      requestType,
      tab
    } = context;

    if (frames_frames.shouldStopRequestProcess(tab)) {
      log/* log.debug */.c.debug('Tab allowlisted or protection disabled');
      return false;
    }

    const mainFrameUrl = frames_frames.getMainFrameUrl(tab);

    if (!mainFrameUrl) {
      // frame wasn't recorded in onBeforeRequest event
      log/* log.debug */.c.debug('Frame was not recorded in onBeforeRequest event');
      return false;
    }

    return canApplyStealthActions(tab, requestUrl, mainFrameUrl, requestType);
  };
  /**
   * Checks if stealth actions are available for provided request with parameters
   *
   * @param tab
   * @param requestUrl
   * @param referrerUrl
   * @param requestType
   * @return {boolean}
   */


  const canApplyStealthActions = (tab, requestUrl, referrerUrl, requestType) => {
    // if stealth mode is disabled
    if (isStealthModeDisabled()) {
      return false;
    }

    const allowlistRule = filteringApi.findAllowlistRule({
      requestUrl,
      frameUrl: referrerUrl,
      requestType,
      frameRule: frames_frames.getFrameRule(tab)
    });

    if (allowlistRule && allowlistRule.isDocumentAllowlistRule()) {
      log/* log.debug */.c.debug(`Allowlist rule found: ${allowlistRule.getText()}`);
      return false;
    } // If stealth is allowlisted


    const stealthAllowlistRule = findStealthAllowlistRule(requestUrl, referrerUrl, requestType);

    if (stealthAllowlistRule) {
      log/* log.debug */.c.debug(`Allowlist stealth rule found: ${stealthAllowlistRule.getText()}`);
      return false;
    }

    return true;
  };
  /**
   * Checks if tab is allowlisted for stealth
   *
   * @param requestUrl
   * @param referrerUrl
   * @param requestType
   * @returns allowlist rule if found
   */


  const findStealthAllowlistRule = function (requestUrl, referrerUrl, requestType) {
    if (referrerUrl) {
      const stealthDocumentAllowlistRule = filteringApi.findStealthAllowlistRule({
        requestUrl: referrerUrl,
        frameUrl: referrerUrl,
        requestType
      });

      if (stealthDocumentAllowlistRule && stealthDocumentAllowlistRule.isDocumentAllowlistRule()) {
        log/* log.debug */.c.debug('Stealth document allowlist rule found.');
        return stealthDocumentAllowlistRule;
      }
    }

    const stealthAllowlistRule = filteringApi.findStealthAllowlistRule({
      requestUrl,
      frameUrl: referrerUrl,
      requestType
    });

    if (stealthAllowlistRule) {
      log/* log.debug */.c.debug('Stealth allowlist rule found.');
      return stealthAllowlistRule;
    }

    return null;
  };
  /**
   * Checks if stealth mode is disabled
   * @returns {boolean}
   */


  const isStealthModeDisabled = () => {
    return settings.getProperty(settings.DISABLE_STEALTH_MODE) || settings.isFilteringDisabled();
  };
  /**
   * Returns stealth setting current value, considering if global stealth setting is enabled
   * @param stealthSettingName
   * @returns {boolean}
   */


  const getStealthSettingValue = stealthSettingName => {
    if (isStealthModeDisabled()) {
      return false;
    }

    return settings.getProperty(stealthSettingName);
  };
  /**
   * Updates browser privacy.network settings depending on blocking WebRTC or not
   *
   * @param {boolean} blockWebRTC
   */


  const setBlockWebRTC = async blockWebRTC => {
    // Edge doesn't support privacy api
    // https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/privacy
    if (!extension_api_browser/* browser.privacy */.X.privacy) {
      return;
    }

    const logError = e => {
      log/* log.error */.c.error('Error updating privacy.network settings: {0}', e);
    }; // Deprecated since Chrome 48


    if (typeof extension_api_browser/* browser.privacy.network.webRTCMultipleRoutesEnabled */.X.privacy.network.webRTCMultipleRoutesEnabled === 'object') {
      try {
        if (blockWebRTC) {
          await extension_api_browser/* browser.privacy.network.webRTCMultipleRoutesEnabled.set */.X.privacy.network.webRTCMultipleRoutesEnabled.set({
            value: false,
            scope: 'regular'
          });
        } else {
          await extension_api_browser/* browser.privacy.network.webRTCMultipleRoutesEnabled.clear */.X.privacy.network.webRTCMultipleRoutesEnabled.clear({
            scope: 'regular'
          });
        }
      } catch (e) {
        logError(e);
      }
    } // Since chromium 48


    if (typeof extension_api_browser/* browser.privacy.network.webRTCIPHandlingPolicy */.X.privacy.network.webRTCIPHandlingPolicy === 'object') {
      try {
        if (blockWebRTC) {
          await extension_api_browser/* browser.privacy.network.webRTCIPHandlingPolicy.set */.X.privacy.network.webRTCIPHandlingPolicy.set({
            value: 'disable_non_proxied_udp',
            scope: 'regular'
          });
        } else {
          await extension_api_browser/* browser.privacy.network.webRTCIPHandlingPolicy.clear */.X.privacy.network.webRTCIPHandlingPolicy.clear({
            scope: 'regular'
          });
        }
      } catch (e) {
        logError(e);
      }
    }

    if (typeof extension_api_browser/* browser.privacy.network.peerConnectionEnabled */.X.privacy.network.peerConnectionEnabled === 'object') {
      try {
        if (blockWebRTC) {
          extension_api_browser/* browser.privacy.network.peerConnectionEnabled.set */.X.privacy.network.peerConnectionEnabled.set({
            value: false,
            scope: 'regular'
          });
        } else {
          extension_api_browser/* browser.privacy.network.peerConnectionEnabled.clear */.X.privacy.network.peerConnectionEnabled.clear({
            scope: 'regular'
          });
        }
      } catch (e) {
        logError(e);
      }
    }
  };
  /**
   * Handle WebRTC blocking feature for Chromium browsers
   *
   * @param {boolean} shouldBlock
   */


  const handlePrivacyPermissions = async shouldBlock => {
    try {
      if (!shouldBlock) {
        // Unblocking WebRTC doesn't require any permissions
        await setBlockWebRTC(shouldBlock);
        return;
      }

      let isPermissionsGranted = await browserUtils.containsPermissions(PRIVACY_PERMISSIONS);

      if (!isPermissionsGranted) {
        // If there is no permission already, request one
        isPermissionsGranted = await browserUtils.requestPermissions(PRIVACY_PERMISSIONS);
      }

      if (isPermissionsGranted) {
        await setBlockWebRTC(true);
      } else {
        // If privacy permission is not granted set BLOCK_WEBRTC setting to false
        settings.setProperty(settings.BLOCK_WEBRTC, false);
      }
    } catch (e) {
      log/* log.error */.c.error(e);
    }
  };
  /**
   * Browsers api doesn't allow to get optional permissions
   * via chrome.permissions.getAll and we can't check privacy
   * availability via `browser.privacy !== undefined` till permission
   * isn't enabled by the user
   *
   * That's why use edge browser detection
   * Privacy methods are not working at all in the Edge
   * @returns {boolean}
   */


  const canBlockWebRTC = () => {
    return !browserUtils.isEdgeBrowser();
  };
  /**
   * Initializes service
   */


  const init = () => {
    engine = new StealthService(getConfig());
  };
  /**
   * We handle privacy permission only for chromium browsers
   * In the Firefox privacy permission is available by default
   * because they can't be optional there
   * @returns {boolean}
   */


  const shouldHandlePrivacyPermission = () => {
    return browserUtils.isChromium();
  };
  /**
   * Returns stealth service configuration object
   */


  const getConfig = () => {
    return {
      blockChromeClientData: getStealthSettingValue(settings.BLOCK_CHROME_CLIENT_DATA),
      hideReferrer: getStealthSettingValue(settings.HIDE_REFERRER),
      hideSearchQueries: getStealthSettingValue(settings.HIDE_SEARCH_QUERIES),
      sendDoNotTrack: getStealthSettingValue(settings.SEND_DO_NOT_TRACK),
      selfDestructThirdPartyCookies: getStealthSettingValue(settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES),
      selfDestructThirdPartyCookiesTime: settings.getProperty(settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES_TIME),
      selfDestructFirstPartyCookies: getStealthSettingValue(settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES),
      selfDestructFirstPartyCookiesTime: settings.getProperty(settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES_TIME)
    };
  };

  const STEALTH_SETTINGS = [settings.DISABLE_STEALTH_MODE, settings.BLOCK_CHROME_CLIENT_DATA, settings.HIDE_REFERRER, settings.HIDE_SEARCH_QUERIES, settings.SEND_DO_NOT_TRACK, settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES, settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES_TIME, settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES, settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES_TIME, settings.BLOCK_WEBRTC];
  let engine = new StealthService(getConfig());
  settings.onUpdated.addListener(setting => {
    if (STEALTH_SETTINGS.includes(setting)) {
      // Rebuild engine on settings update
      engine = new StealthService(getConfig());
      listeners.notifyListeners(listeners.UPDATE_FILTER_RULES);
    }
  });

  if (canBlockWebRTC()) {
    settings.onUpdated.addListener(async (settingName, settingValue) => {
      if (settingName === settings.BLOCK_WEBRTC || settingName === settings.DISABLE_STEALTH_MODE) {
        let shouldBlock;

        if (settingName === settings.BLOCK_WEBRTC) {
          if (!isStealthModeDisabled()) {
            shouldBlock = settingValue;
          }
        } else if (settingName === settings.DISABLE_STEALTH_MODE) {
          if (settings.getProperty(settings.BLOCK_WEBRTC)) {
            // Enable webRTC if stealth mode is disabled
            shouldBlock = !settingValue;
          }
        }

        if (typeof shouldBlock === 'undefined') {
          // Nothing to change indeed
          return;
        }

        if (shouldHandlePrivacyPermission()) {
          // Block or unblock WebRTC while handling privacy permission
          await handlePrivacyPermissions(shouldBlock);
        } else {
          // Set WebRTC blocking as is for everything else
          await setBlockWebRTC(shouldBlock);
        }
      }
    });
    listeners.addListener(async event => {
      let isPermissionsGranted;

      switch (event) {
        case listeners.APPLICATION_INITIALIZED:
          try {
            isPermissionsGranted = await browserUtils.containsPermissions(PRIVACY_PERMISSIONS);
          } catch (e) {
            log/* log.error */.c.error(e);
          }

          if (isPermissionsGranted) {
            await setBlockWebRTC(getStealthSettingValue(settings.BLOCK_WEBRTC));
          }

          break;

        default:
          break;
      }
    });
  }
  /**
   * Returns either script which will send dom signal, or empty string
   * @returns {*}
   */


  const getSetDomSignalScript = () => {
    return engine.getSetDomSignalScript();
  };

  return {
    init,
    processRequestHeaders,
    getStealthModeRuleList,
    hasFilterRules,
    canBlockWebRTC,
    getSetDomSignalScript,
    STEALTH_ACTIONS: constants/* STEALTH_ACTIONS */.Jn
  };
})();
;// CONCATENATED MODULE: ./Extension/src/background/filter/request-blocking.js


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */
















const webRequestService = function () {
  const onRequestBlockedChannel = utils.channels.newChannel();
  /**
   * Checks if we can collect hit stats for this tab:
   * Option "Send ad filters usage" is enabled and tab isn't incognito
   * @param {object} tab
   * @returns {boolean}
   */

  const canCollectHitStatsForTab = function (tab) {
    if (!tab) {
      return settings.collectHitsCount();
    }

    return tab && settings.collectHitsCount() && !frames_frames.isIncognitoTab(tab);
  };
  /**
   * Records filtering rule hit
   *
   * @param tab            Tab object
   * @param requestRule    Rule to record
   * @param requestUrl     Request URL
   */


  const recordRuleHit = function (tab, requestRule, requestUrl) {
    if (requestRule && !utils.filters.isUserFilterRule(requestRule) && !utils.filters.isAllowlistFilterRule(requestRule) && canCollectHitStatsForTab(tab)) {
      const domain = frames_frames.getFrameDomain(tab);
      hit_stats_browsers.addRuleHit(domain, requestRule.getText(), requestRule.getFilterListId(), requestUrl);
    }
  };
  /**
   * An object with the selectors and scripts to be injected into the page
   * @typedef {Object} SelectorsAndScripts
   * @property {SelectorsData} selectors An object with the CSS styles that needs to be applied
   * @property {string} scripts Javascript to be injected into the page
   * @property {boolean} collapseAllElements If true, content script must force
   * the collapse check of the page elements
   */

  /**
   * Prepares CSS and JS which should be injected to the page.
   *
   * @param tab                       Tab data
   * @param documentUrl               Document URL
   * @param {boolean} force           Indicates whether to retrieve JS and Css selectors, used in 'webrequest' call
   *
   * When cssFilterOptions and force are undefined, we handle it in a special way
   * that depends on whether the browser supports inserting CSS and scripts from the background page
   *
   * @returns {SelectorsAndScripts} an object with the selectors and scripts to be injected into the page
   */


  const processGetSelectorsAndScripts = function (tab, documentUrl, force) {
    const result = Object.create(null);

    if (!tab) {
      return result;
    }

    if (!filteringApi.isReady()) {
      result.requestFilterReady = false;
      return result;
    }

    if (frames_frames.isTabProtectionDisabled(tab)) {
      return result;
    }

    if (frames_frames.isTabAllowlisted(tab)) {
      return result;
    }

    const cosmeticOptions = filteringApi.getCosmeticOption({
      requestUrl: documentUrl,
      frameUrl: documentUrl,
      requestType: request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT,
      frameRule: frames_frames.getFrameRule(tab)
    });

    if (force || !prefs.features.canUseInsertCSSAndExecuteScript) {
      // Retrieve ExtendedCss selectors only if canUseInsertCSSAndExecuteScript is unavailable
      result.selectors = filteringApi.getSelectorsForUrl(documentUrl, cosmeticOptions, true, !prefs.features.canUseInsertCSSAndExecuteScript); // grep "localScriptRulesService" for details about script source

      result.scripts = filteringApi.getScriptsStringForUrl(documentUrl, tab, cosmeticOptions); // add stealth dom signal script

      result.scripts += stealthService.getSetDomSignalScript();
    } else {
      // In preload content script only ExtendedCss selectors are necessary.
      // Traditional css selectors would be injected via tabs.injectCss.
      // Except when browser starts with open tabs
      result.selectors = filteringApi.getSelectorsForUrl(documentUrl, cosmeticOptions, false, true);
    } // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1337


    result.collectRulesHits = isCollectingCosmeticRulesHits(tab);
    result.collapseAllElements = filteringApi.shouldCollapseAllElements();
    return result;
  };
  /**
   * Checks if request that is wrapped in page script should be blocked.
   * We do this because browser API doesn't have full support for intercepting all requests, e.g. WebSocket or WebRTC.
   *
   * @param tab           Tab
   * @param requestUrl    request url
   * @param referrerUrl   referrer url
   * @param requestType   Request type (WEBSOCKET or WEBRTC)
   * @returns {boolean}   true if request is blocked
   */


  const checkPageScriptWrapperRequest = function (tab, requestUrl, referrerUrl, requestType) {
    if (!tab) {
      return false;
    }

    let requestRule = getRuleForRequest(tab, requestUrl, referrerUrl, requestType);
    requestRule = postProcessRequest(tab, requestUrl, referrerUrl, requestType, requestRule);
    requestContextStorage.recordEmulated({
      requestUrl,
      referrerUrl,
      requestType,
      tab,
      requestRule
    });
    return isRequestBlockedByRule(requestRule);
  };
  /**
   * Checks if request is blocked
   *
   * @param tab           Tab
   * @param requestUrl    request url
   * @param referrerUrl   referrer url
   * @param requestType   one of RequestType
   * @returns {boolean}   true if request is blocked
   */


  const processShouldCollapse = function (tab, requestUrl, referrerUrl, requestType) {
    if (!tab) {
      return false;
    }

    const requestRule = getRuleForRequest(tab, requestUrl, referrerUrl, requestType);
    return isRequestBlockedByRule(requestRule);
  };
  /**
   * Checks if requests are blocked
   *
   * @param tab               Tab
   * @param referrerUrl       referrer url
   * @param collapseRequests  requests array
   * @returns {*}             requests array
   */


  const processShouldCollapseMany = function (tab, referrerUrl, collapseRequests) {
    if (!tab) {
      return collapseRequests;
    }

    for (let i = 0; i < collapseRequests.length; i += 1) {
      const request = collapseRequests[i];
      const requestRule = getRuleForRequest(tab, request.elementUrl, referrerUrl, request.requestType);
      request.collapse = isRequestBlockedByRule(requestRule);
    }

    return collapseRequests;
  };
  /**
   * Checks if request is blocked by rule
   * Do not allow redirect rules because they can't be used in collapse check functions
   *
   * @param requestRule
   * @returns {*|boolean}
   */


  const isRequestBlockedByRule = requestRule => {
    return requestRule && !requestRule.isAllowlist() && !requestRule.isOptionEnabled(es/* NetworkRuleOption.Replace */.SJ.Replace) && !requestRule.isOptionEnabled(es/* NetworkRuleOption.Redirect */.SJ.Redirect);
  };
  /**
   * Checks if popup is blocked by rule
   * @param requestRule
   * @returns {boolean}
   */


  const isPopupBlockedByRule = requestRule => {
    return requestRule && !requestRule.isAllowlist() && requestRule.isOptionEnabled(es/* NetworkRuleOption.Popup */.SJ.Popup);
  };
  /**
   * Check if document is blocked by rule
   * @param requestRule
   * @return {boolean}
   */


  const isDocumentBlockingRule = requestRule => {
    return requestRule && !requestRule.isAllowlist() && requestRule.isOptionEnabled(es/* NetworkRuleOption.Document */.SJ.Document);
  };
  /**
   * Gets blocked response by rule
   * For details see https://developer.chrome.com/extensions/webRequest#type-BlockingResponse
   * or https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/webRequest/BlockingResponse
   * @param requestRule   Request rule or null
   * @param requestType   Request type
   * @param requestUrl    Request url
   * @returns {*} Blocked response or null
   */


  const getBlockedResponseByRule = function (requestRule, requestType, requestUrl) {
    if (isRequestBlockedByRule(requestRule)) {
      const isDocumentLevel = requestType === request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT || requestType === request_types/* RequestTypes.SUBDOCUMENT */.l.SUBDOCUMENT;

      if (isDocumentLevel && isDocumentBlockingRule(requestRule)) {
        const documentBlockedPage = documentFilterService.getDocumentBlockPageUrl(requestUrl, requestRule.getText());

        if (documentBlockedPage) {
          return {
            documentBlockedPage
          };
        }

        return null;
      } // Don't block main_frame request


      if (requestType !== request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT) {
        return {
          cancel: true
        };
      } // check if request rule is blocked by rule and is redirect rule

    } else if (requestRule && !requestRule.isAllowlist()) {
      if (requestRule.isOptionEnabled(es/* NetworkRuleOption.Redirect */.SJ.Redirect)) {
        const redirectUrl = redirectService.createRedirectUrl(requestRule.getAdvancedModifierValue(), requestUrl);

        if (redirectUrl) {
          return {
            redirectUrl
          };
        }
      }
    }

    return null;
  };
  /**
   * Finds rule for request
   *
   * @param tab           Tab
   * @param requestUrl    request url
   * @param referrerUrl   referrer url
   * @param requestType   one of RequestType
   * @returns {*}         rule or null
   */


  const getRuleForRequest = function (tab, requestUrl, referrerUrl, requestType) {
    if (frames_frames.isTabProtectionDisabled(tab)) {
      // don't process request
      return null;
    }

    let allowlistRule;
    /**
     * Background requests will be allowlisted if their referrer
     * url will match with user allowlist rule
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1032
     */

    if (tab.tabId === BACKGROUND_TAB_ID) {
      allowlistRule = allowlist.findAllowlistRule(referrerUrl);
    } else {
      allowlistRule = frames_frames.getFrameRule(tab);
    }

    if (allowlistRule && allowlistRule.isDocumentAllowlistRule()) {
      // Frame is allowlisted by the main frame's $document rule
      // We do nothing more in this case - return the rule.
      return allowlistRule;
    }

    if (!allowlistRule) {
      // If allowlist rule is not found for the main frame, we check it for referrer
      allowlistRule = filteringApi.findAllowlistRule({
        requestUrl,
        frameUrl: referrerUrl,
        requestType: request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT
      });
    }

    return filteringApi.findRuleForRequest({
      requestUrl,
      frameUrl: referrerUrl,
      requestType,
      frameRule: allowlistRule
    });
  };
  /**
   * Finds all content rules for the url
   * @param tab Tab
   * @param documentUrl Document URL
   * @returns collection of content rules or null
   */


  const getContentRules = function (tab, documentUrl) {
    if (frames_frames.shouldStopRequestProcess(tab)) {
      // don't process request
      return null;
    }

    const allowlistRule = filteringApi.findAllowlistRule({
      requestUrl: documentUrl,
      frameUrl: documentUrl,
      requestType: request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT,
      frameRule: frames_frames.getFrameRule(tab)
    });

    if (allowlistRule && allowlistRule.isOptionEnabled(es/* NetworkRuleOption.Content */.SJ.Content)) {
      return null;
    }

    return filteringApi.getContentRulesForUrl(documentUrl);
  };
  /**
   * Find CSP rules for request
   * @param tab           Tab
   * @param requestUrl    Request URL
   * @param referrerUrl   Referrer URL
   * @param requestType   Request type (DOCUMENT or SUBDOCUMENT)
   * @returns {Array}     Collection of rules or null
   */


  const getCspRules = function (tab, requestUrl, referrerUrl, requestType) {
    if (frames_frames.shouldStopRequestProcess(tab)) {
      // don't process request
      return null;
    }

    const frameRule = frames_frames.getFrameRule(tab); // @@||example.org^$document or @@||example.org^$urlblock 
    // disables all the $csp rules on all the pages matching the rule pattern.
    // eslint-disable-next-line max-len

    const allowlistRule = filteringApi.findAllowlistRule({
      requestUrl,
      frameUrl: referrerUrl,
      requestType: request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT,
      frameRule
    });

    if (allowlistRule && allowlistRule.isOptionEnabled(es/* NetworkRuleOption.Urlblock */.SJ.Urlblock)) {
      return null;
    }

    return filteringApi.getCspRules({
      requestUrl,
      frameUrl: referrerUrl,
      requestType,
      frameRule
    });
  };
  /**
   * Find cookie rules for request
   * @param tab           Tab
   * @param requestUrl    Request URL
   * @param referrerUrl   Referrer URL
   * @param requestType   Request type
   * @returns {Array}     Collection of rules or null
   */


  const getCookieRules = (tab, requestUrl, referrerUrl, requestType) => {
    if (frames_frames.shouldStopRequestProcess(tab)) {
      // Don't process request
      return null;
    }

    const frameRule = frames_frames.getFrameRule(tab);
    const allowlistRule = filteringApi.findAllowlistRule({
      requestUrl,
      frameUrl: referrerUrl,
      requestType: request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT,
      frameRule
    });

    if (allowlistRule && allowlistRule.isDocumentAllowlistRule()) {
      // $cookie rules are not affected by regular exception rules (@@) unless it's a $document exception.
      return null;
    } // Get all $cookie rules matching the specified request


    return filteringApi.getCookieRules({
      requestUrl,
      frameUrl: referrerUrl,
      requestType,
      frameRule
    });
  };
  /**
   * Find replace rules for request
   * @param tab
   * @param requestUrl
   * @param referrerUrl
   * @param requestType
   * @returns {*} Collection of rules or null
   */


  const getReplaceRules = (tab, requestUrl, referrerUrl, requestType) => {
    if (frames_frames.shouldStopRequestProcess(tab)) {
      // don't process request
      return null;
    }

    const frameRule = frames_frames.getFrameRule(tab);
    const allowlistRule = filteringApi.findAllowlistRule({
      requestUrl,
      frameUrl: referrerUrl,
      requestType: request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT,
      frameRule
    });

    if (allowlistRule && allowlistRule.isOptionEnabled(es/* NetworkRuleOption.Content */.SJ.Content)) {
      return null;
    }

    return filteringApi.getReplaceRules({
      requestUrl,
      frameUrl: referrerUrl,
      requestType,
      frameRule
    });
  };
  /**
   * Remove query parameters by rules for request
   * @param tab
   * @param requestUrl
   * @param referrerUrl
   * @param requestType
   * @param method
   * @returns {*} Collection of rules or null
   */


  const removeParamFromUrl = (tab, requestUrl, referrerUrl, requestType, method) => {
    if (frames_frames.shouldStopRequestProcess(tab)) {
      // don't process request
      return null;
    } // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#removeparam-modifier


    const canByAppliedToMethod = method && ['GET', 'OPTIONS', 'HEAD'].includes(method.toUpperCase());

    if (!canByAppliedToMethod) {
      return null;
    }

    const frameRule = frames_frames.getFrameRule(tab);
    const allowlistRule = filteringApi.findAllowlistRule({
      requestUrl,
      frameUrl: referrerUrl,
      requestType: request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT,
      frameRule
    });

    if (allowlistRule && allowlistRule.isOptionEnabled(es/* NetworkRuleOption.RemoveParam */.SJ.RemoveParam)) {
      return null;
    }

    const rules = filteringApi.getRemoveParamRules({
      requestUrl,
      frameUrl: referrerUrl,
      requestType,
      frameRule
    });
    let result = requestUrl;
    rules.forEach(r => {
      if (!r.isAllowlist()) {
        const ruleResult = r.getAdvancedModifier().removeParameters(result);

        if (ruleResult !== result) {
          filtering_log_browsers.addRemoveParamEvent({
            tab,
            frameUrl: requestUrl,
            requestType,
            rule: r,
            timestamp: Date.now()
          });
        }

        result = ruleResult;
      }
    });

    if (result !== requestUrl) {
      return result;
    }

    return null;
  };
  /**
   * Processes HTTP response.
   * It could do the following:
   * 1. Add event to the filtering log (for DOCUMENT requests)
   * 2. Record page stats (if it's enabled)
   *
   * @param tab Tab object
   * @param requestUrl Request URL
   * @param referrerUrl Referrer URL
   * @param requestType Request type
   * @return {void}
   */


  const processRequestResponse = function (tab, requestUrl, referrerUrl, requestType) {
    // add page view to stats
    if (requestType === request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT) {
      const domain = frames_frames.getFrameDomain(tab);

      if (canCollectHitStatsForTab(tab)) {
        hit_stats_browsers.addDomainView(domain);
      }
    }
  };
  /**
   * Request post processing, firing events, add log records etc.
   *
   * @param tab           Tab
   * @param requestUrl    request url
   * @param referrerUrl   referrer url
   * @param requestType   one of RequestType
   * @param requestRule   rule
   * @return {object} Request rule if suitable by its own type and request type or null
   */


  const postProcessRequest = function (tab, requestUrl, referrerUrl, requestType, requestRule) {
    if (requestRule && !requestRule.isAllowlist()) {
      const isRequestBlockingRule = isRequestBlockedByRule(requestRule);
      const isReplaceRule = requestRule.isOptionEnabled(es/* NetworkRuleOption.Replace */.SJ.Replace); // Url blocking rules are not applicable to the main_frame

      if (isRequestBlockingRule && requestType === request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT) {
        // except rules with $document and $popup modifiers
        const isDocumentRule = requestRule.isOptionEnabled(es/* NetworkRuleOption.Document */.SJ.Document);
        const isPopupBlockingRule = isPopupBlockedByRule(requestRule);

        if (!isDocumentRule && !isPopupBlockingRule) {
          requestRule = null;
        }
      } // Replace rules are processed in content-filtering


      if (isReplaceRule) {
        requestRule = null;
      }

      if (requestRule) {
        listeners.notifyListenersAsync(listeners.ADS_BLOCKED, requestRule, tab, 1);
        const details = {
          tabId: tab.tabId,
          requestUrl,
          referrerUrl,
          requestType
        };
        details.rule = requestRule.getText();
        details.filterId = requestRule.getFilterListId();
        onRequestBlockedChannel.notify(details);
      }
    }

    return requestRule;
  };

  const isCollectingCosmeticRulesHits = tab => {
    /**
     * Edge Legacy browser doesn't support css content attribute for node elements except
     * :before and :after
     * Due to this we can't use cssHitsCounter for edge browser
     */
    if (browserUtils.isEdgeBrowser()) {
      return false;
    }

    return canCollectHitStatsForTab(tab) || filtering_log_browsers.isOpen();
  }; // EXPOSE


  return {
    processGetSelectorsAndScripts,
    checkPageScriptWrapperRequest,
    processShouldCollapse,
    processShouldCollapseMany,
    isRequestBlockedByRule,
    isPopupBlockedByRule,
    getBlockedResponseByRule,
    getRuleForRequest,
    getCspRules,
    getCookieRules,
    getContentRules,
    getReplaceRules,
    removeParamFromUrl,
    processRequestResponse,
    postProcessRequest,
    recordRuleHit,
    onRequestBlocked: onRequestBlockedChannel,
    isCollectingCosmeticRulesHits
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/filter/request-filter.js

















/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */









const RequestFilter = (() => {
  /**
   * Request filter is main class which applies filter rules.
   *
   * @type {Function}
   */
  const RequestFilter = function () {};

  RequestFilter.prototype = {
    getRulesCount() {
      return engine.getRulesCount();
    },

    /**
     * An object with the information on the CSS and ExtendedCss stylesheets which
     * need to be injected into a web page.
     *
     * @typedef {Object} SelectorsData
     * @property {Array.<string>} css Regular CSS stylesheets
     * @property {Array.<string>} extendedCss ExtendedCSS stylesheets
     * @property {boolean} cssHitsCounterEnabled If true - collecting CSS rules hits stats
     * is enabled
     */

    /**
     * Builds CSS for the specified web page.
     * http://adguard.com/en/filterrules.html#hideRules
     *
     * @param {string} url Page URL
     * @param {number} options bitmask
     * @param {boolean} ignoreTraditionalCss flag
     * @param {boolean} ignoreExtCss flag
     * @returns {*} CSS and ExtCss data for the webpage
     */
    getSelectorsForUrl(url, options, ignoreTraditionalCss, ignoreExtCss) {
      const cosmeticResult = engine.getCosmeticResult(url, options);
      const elemhideCss = [...cosmeticResult.elementHiding.generic, ...cosmeticResult.elementHiding.specific];
      const injectCss = [...cosmeticResult.CSS.generic, ...cosmeticResult.CSS.specific];
      const elemhideExtCss = [...cosmeticResult.elementHiding.genericExtCss, ...cosmeticResult.elementHiding.specificExtCss];
      const injectExtCss = [...cosmeticResult.CSS.genericExtCss, ...cosmeticResult.CSS.specificExtCss];
      const collectingCosmeticRulesHits = webRequestService.isCollectingCosmeticRulesHits();

      if (collectingCosmeticRulesHits) {
        const styles = !ignoreTraditionalCss ? cssService.buildStyleSheetHits(elemhideCss, injectCss) : [];
        const extStyles = !ignoreExtCss ? cssService.buildStyleSheetHits(elemhideExtCss, injectExtCss) : [];
        return {
          css: styles,
          extendedCss: extStyles
        };
      }

      const styles = !ignoreTraditionalCss ? cssService.buildStyleSheet(elemhideCss, injectCss, true) : [];
      const extStyles = !ignoreExtCss ? cssService.buildStyleSheet(elemhideExtCss, injectExtCss, false) : [];
      return {
        css: styles,
        extendedCss: extStyles
      };
    },

    /**
     * Builds domain-specific JS injection for the specified page.
     * http://adguard.com/en/filterrules.html#javascriptInjection
     *
     * @param url Page URL
     * @param cosmeticOptions bitmask
     * @returns {CosmeticRule[]} Javascript for the specified URL
     */
    getScriptsForUrl(url, cosmeticOptions) {
      const cosmeticResult = engine.getCosmeticResult(url, cosmeticOptions);
      return cosmeticResult.getScriptRules();
    },

    /**
     * Builds the final output string for the specified page.
     * Depending on the browser we either allow or forbid the new remote rules
     * grep "localScriptRulesService" for details about script source
     *
     * @param {string} url Page URL
     * @param {Object} tab tab
     * @param cosmeticOptions bitmask
     * @returns {string} Script to be applied
     */
    getScriptsStringForUrl(url, tab, cosmeticOptions) {
      const debug = filtering_log_browsers && filtering_log_browsers.isOpen();
      const scriptRules = this.getScriptsForUrl(url, cosmeticOptions);
      const isFirefox = browserUtils.isFirefoxBrowser();
      const selectedScriptRules = scriptRules.filter(scriptRule => {
        // Scriptlets should not be excluded for remote filters
        if (scriptRule.isScriptlet) {
          return true;
        } // User rules should not be excluded from remote filters


        if (scriptRule.filterListId === utils.filters.USER_FILTER_ID) {
          return true;
        }

        const isLocal = local_script_rules_chrome.isLocal(scriptRule.getText());

        if (isLocal) {
          return true;
        }


        return true;
      });

      if (debug) {
        selectedScriptRules.forEach(scriptRule => {
          if (!scriptRule.isGeneric()) {
            filtering_log_browsers.addScriptInjectionEvent({
              tab,
              frameUrl: url,
              requestType: request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT,
              rule: scriptRule,
              timestamp: Date.now()
            });
          }
        });
      }

      const scripts = selectedScriptRules.map(scriptRule => scriptRule.getScript({
        debug,
        request: {
          domain: url
        }
      })); // remove repeating scripts

      const scriptsCode = [...new Set(scripts)].join('\r\n');
      return `
            (function () {
                try {
                    ${scriptsCode}
                } catch (ex) {
                    console.error('Error executing AG js: ' + ex);
                }
            })();
            `;
    },

    /**
     * Gets or creates matching result
     *
     * @param {MatchQuery} matchQuery - {@link MatchQuery}
     */
    getMatchingResult(matchQuery) {
      const result = engine.matchRequest(matchQuery);

      if (!result) {
        return new es/* MatchingResult */.N2([], null);
      }

      return result;
    },

    /**
     * Searches for the allowlist rule for the specified pair (url/referrer)
     *
     * @param {MatchQuery} matchQuery - {@link MatchQuery}
     *
     * @returns NetworkRule found or null
     */
    findAllowlistRule(matchQuery) {
      const result = this.getMatchingResult(matchQuery);
      const basicResult = result.getBasicResult();

      if (basicResult && basicResult.isAllowlist()) {
        return basicResult;
      }

      return null;
    },

    findDocumentRule(documentUrl) {
      return engine.matchFrame(documentUrl);
    },

    /**
     * Searches for stealth allowlist rule for the specified pair (url/referrer)
     *
     * @param {MatchQuery} matchQuery - {@link MatchQuery}
     *
     * @returns NetworkRule found or null
     */
    findStealthAllowlistRule(matchQuery) {
      const result = this.getMatchingResult(matchQuery);
      return result.stealthRule;
    },

    /**
     * Searches for the filter rule for the specified request.
     *
     * @param {MatchQuery} matchQuery - {@link MatchQuery}
     * @returns NetworkRule found or null
     */
    findRuleForRequest(matchQuery) {
      const result = this.getMatchingResult(matchQuery);
      return result.getBasicResult();
    },

    /**
     * Searches for content rules for the specified domain
     *
     * @param documentUrl Document URL
     * @returns CosmeticRule[] of content rules
     */
    getContentRulesForUrl(documentUrl) {
      // eslint-disable-next-line max-len
      const cosmeticResult = engine.getCosmeticResult(documentUrl, es/* CosmeticOption.CosmeticOptionHtml */.zT.CosmeticOptionHtml);
      return cosmeticResult.Html.getRules();
    },

    /**
     * Searches for CSP rules for the specified request
     *
     * @param {MatchQuery} matchQuery - {@link MatchQuery}
     * @returns NetworkRule[] of CSP rules for applying to the request or null
     */
    findCspRules(matchQuery) {
      const result = this.getMatchingResult(matchQuery);
      return result.getCspRules();
    },

    /**
     * Searches for replace modifier rules
     *
     * @param {MatchQuery} matchQuery - {@link MatchQuery}
     * @returns NetworkRule[] matching
     */
    findReplaceRules(matchQuery) {
      const result = this.getMatchingResult(matchQuery);
      return result.getReplaceRules();
    },

    /**
     * Searches for cookie rules matching specified request.
     *
     * @param {MatchQuery} matchQuery - {@link MatchQuery}
     * @returns NetworkRule[] matching
     */
    findCookieRules(matchQuery) {
      const result = this.getMatchingResult(matchQuery);
      return result.getCookieRules();
    }

  };
  return RequestFilter;
})();
// EXTERNAL MODULE: ./node_modules/crypto-js/sha256.js
var sha256 = __webpack_require__(28975);
var sha256_default = /*#__PURE__*/__webpack_require__.n(sha256);
;// CONCATENATED MODULE: ./Extension/src/background/utils/lru-cache.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */



/**
 * Cache with maxCacheSize stored in local storage, which automatically clears less recently used entries
 *
 * @param {string} storagePropertyName      Name of the local storage property.
 * @param {number} size                     Max cache size
 */

function LruCache(storagePropertyName, size) {
  const CACHE_SIZE = 1000;
  const maxCacheSize = size || CACHE_SIZE;
  let cache;
  let cacheSize;

  function getCacheFromLocalStorage() {
    let entries = null;

    try {
      const json = storage_localStorage.getItem(storagePropertyName);

      if (json) {
        const data = JSON.parse(json);
        entries = data.map(x => [x.key, x.value]);
      }
    } catch (ex) {
      // ignore
      log/* log.error */.c.error('Error read from {0} cache, cause: {1}', storagePropertyName, ex);
      storage_localStorage.removeItem(storagePropertyName);
    }

    return new lru.LRUMap(maxCacheSize, entries);
  }

  function saveCacheToLocalStorage() {
    try {
      storage_localStorage.setItem(storagePropertyName, JSON.stringify(cache.toJSON()));
    } catch (ex) {
      log/* log.error */.c.error('Error save to {0} cache, cause: {1}', storagePropertyName, ex);
    }
  }
  /**
   * Retrieves value from cache and checks if saved data is not expired yet.
   * @param {string} key
   * @returns {null|object} saved data
   */


  function getValue(key) {
    return cache.get(key);
  }

  const saveValue = function (key, data) {
    if (!key) {
      return;
    }

    cache.set(key, data);
    cacheSize += 1;

    if (cacheSize % 20 === 0) {
      saveCacheToLocalStorage();
    }
  };
  /**
   * Clears cache
   */


  const clear = () => {
    cache = new lru.LRUMap(maxCacheSize, null);
    cacheSize = cache.size;
    saveCacheToLocalStorage();
  }; // Load cache


  cache = getCacheFromLocalStorage();
  cacheSize = cache.size;
  return {
    getValue,
    saveValue,
    clear
  };
}
;// CONCATENATED MODULE: ./Extension/src/background/filter/services/safebrowsing/safebrowsing.browsers.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */











/**
 * Initializing SafebrowsingFilter.
 *
 * http://adguard.com/en/how-malware-blocked.html#extension
 */

const safebrowsing = function () {
  // Lazy initialized safebrowsing cache
  const safebrowsingCache = {
    get cache() {
      return lazyGet(safebrowsingCache, 'cache', () => new LruCache('sb-lru-cache'));
    }

  };
  /**
   * Backend requests cache
   */

  const safebrowsingRequestsCache = new lru.LRUMap(1000);
  const suspendedFromProperty = 'safebrowsing-suspended-from';
  /**
   * If we've got an error response from the backend, suspend requests for
   * this time: 40 minutes
   */

  const SUSPEND_TTL = 40 * 60 * 1000;
  const SB_ALLOW_LIST = 'allowlist';
  /**
   * Domain hash length
   */

  const DOMAIN_HASH_LENGTH = 4;

  function isMalwareList(listName) {
    return utils.strings.contains(listName, 'malware');
  }

  function isPhishingList(listName) {
    return utils.strings.contains(listName, 'phishing');
  }
  /**
   * Parses safebrowsing service response
   *
   * @param responseText  Response text
   * @param hashesMap  Hashes hosts map
   * @returns Safebrowsing list or null
   * @private
   */


  function processSbResponse(responseText, hashesMap) {
    if (!responseText || responseText.length > 10 * 1024) {
      return null;
    }

    try {
      let result;
      const lines = responseText.split('\n');

      for (let i = 0; i < lines.length; i += 1) {
        const r = lines[i].split(':');
        const hash = r[2];
        const list = r[0];
        safebrowsingCache.cache.saveValue(hash, list);

        if (!result) {
          const host = hashesMap[hash];

          if (host) {
            result = list;
          }
        }
      }

      return result;
    } catch (ex) {
      log/* log.error */.c.error('Error parse safebrowsing response, cause {0}', ex);
    }

    return null;
  }
  /**
   * Creates lookup callback parameter
   * @param sbList    Safebrowsing list we've detected or null
   * @returns Safebrowsing list or null if this list is SB_ALLOW_LIST (means that site was allowlisted).
   * @private
   */


  function createResponse(sbList) {
    if (isMalwareList(sbList) || isPhishingList(sbList)) {
      return sbList;
    }

    return null;
  }
  /**
   * Resumes previously suspended work of SafebrowsingFilter
   * @private
   */


  function resumeSafebrowsing() {
    storage_localStorage.removeItem(suspendedFromProperty);
  }
  /**
   * Suspend work of SafebrowsingFilter (in case of backend error)
   * @private
   */


  function suspendSafebrowsing() {
    storage_localStorage.setItem(suspendedFromProperty, Date.now());
  }
  /**
   * Calculates hash for host string
   *
   * @param host
   * @return {string}
   */


  function createHash(host) {
    return sha256_default()(`${host}/`).toString().toUpperCase();
  }
  /**
   * Calculates SHA256 hashes for strings in hosts and then
   * gets prefixes for calculated hashes
   *
   * @param hosts
   * @returns Map object of prefixes
   * @private
   */


  function createHashesMap(hosts) {
    const result = Object.create(null);

    for (let i = 0; i < hosts.length; i += 1) {
      const host = hosts[i];
      const hash = createHash(host);
      result[hash] = host;
    }

    return result;
  }
  /**
   * Checks safebrowsing cache
   *
   * @param hosts List of hosts
   * @returns Safebrowsing list (for blacklisted request) or null
   * @private
   */


  function checkHostsInSbCache(hosts) {
    for (let i = 0; i < hosts.length; i += 1) {
      const sbList = safebrowsingCache.cache.getValue(createHash(hosts[i]));

      if (sbList) {
        return sbList;
      }
    }

    return null;
  }
  /**
   * Extracts hosts from one host.
   * This method returns all sub-domains and IP address of the specified host.
   *
   * @param host Host
   * @returns Array of extracted host names
   * @private
   */


  function extractHosts(host) {
    const hosts = [];

    if (utils.url.isIpv4(host) || utils.url.isIpv6(host)) {
      hosts.push(host);
      return hosts;
    }

    const parts = host.split('.');

    if (parts.length <= 2) {
      hosts.push(host);
    } else {
      for (let i = 0; i <= parts.length - 2; i += 1) {
        hosts.push(utils.strings.join(parts, '.', i, parts.length));
      }
    }

    return hosts;
  }
  /**
   * Access Denied page URL
   *
   * @param requestUrl    Request URL
   * @param referrerUrl   Referrer URL
   * @param sbList        Safebrowsing list
   * @returns page URL
   */


  const getErrorPageURL = function (requestUrl, referrerUrl, sbList) {
    const listName = sbList || 'malware';
    let url = 'pages/safebrowsing.html';
    url += `?malware=${isMalwareList(listName)}`;
    url += `&host=${encodeURIComponent(utils.url.getHost(requestUrl))}`;
    url += `&url=${encodeURIComponent(requestUrl)}`;
    url += `&ref=${encodeURIComponent(referrerUrl)}`;
    return backgroundPage.getURL(url);
  };
  /**
   * Performs lookup to safebrowsing service
   *
   * @param requestUrl        Request URL
   */


  const lookupUrl = async function (requestUrl) {
    const host = utils.url.getHost(requestUrl);

    if (!host) {
      return;
    }

    const hosts = extractHosts(host);

    if (!hosts || hosts.length === 0) {
      return;
    } // try find request url in cache


    let sbList = checkHostsInSbCache(hosts);

    if (sbList) {
      return createResponse(sbList);
    } // check safebrowsing is active


    const now = Date.now();
    const suspendedFrom = storage_localStorage.getItem(suspendedFromProperty) - 0;

    if (suspendedFrom && now - suspendedFrom < SUSPEND_TTL) {
      return;
    }

    const hashesMap = createHashesMap(hosts);
    const hashes = Object.keys(hashesMap);
    let shortHashes = [];

    for (let i = 0; i < hashes.length; i += 1) {
      shortHashes.push(hashes[i].substring(0, DOMAIN_HASH_LENGTH));
    } // Filter already checked hashes


    shortHashes = shortHashes.filter(x => !safebrowsingRequestsCache.get(x));

    if (shortHashes.length === 0) {
      // In case we have not found anything in safebrowsingCache and all short hashes have been checked in
      // safebrowsingRequestsCache - means that there is no need to request backend again
      safebrowsingCache.cache.saveValue(createHash(host), SB_ALLOW_LIST);
      return createResponse(SB_ALLOW_LIST);
    }

    let response;

    try {
      response = await backend.lookupSafebrowsing(shortHashes);
    } catch (e) {
      log/* log.error */.c.error('Error response from safebrowsing lookup server for {0}', host);
      suspendSafebrowsing();
      return;
    }

    if (response && response.status >= 500) {
      // Error on server side, suspend request
      // eslint-disable-next-line max-len
      log/* log.error */.c.error('Error response status {0} received from safebrowsing lookup server.', response.status);
      suspendSafebrowsing();
      return;
    }

    if (!response) {
      log/* log.error */.c.error('Can`t read response from the server');
      return;
    }

    resumeSafebrowsing();
    shortHashes.forEach(x => {
      safebrowsingRequestsCache.set(x, true);
    });
    sbList = SB_ALLOW_LIST;

    if (response.status !== 204) {
      sbList = processSbResponse(response.responseText, hashesMap) || SB_ALLOW_LIST;
    }

    safebrowsingCache.cache.saveValue(createHash(host), sbList);
    return createResponse(sbList);
  };
  /**
   * Checks URL with safebrowsing filter.
   * http://adguard.com/en/how-malware-blocked.html#extension
   *
   * @param requestUrl Request URL
   * @param referrerUrl Referrer URL
   */


  const checkSafebrowsingFilter = async function (requestUrl, referrerUrl) {
    if (!settings.safebrowsingInfoEnabled()) {
      return;
    }

    log/* log.debug */.c.debug('Checking safebrowsing filter for {0}', requestUrl);
    const sbList = await lookupUrl(requestUrl);

    if (!sbList) {
      log/* log.debug */.c.debug('No safebrowsing rule found');
      return;
    }

    log/* log.debug */.c.debug('Following safebrowsing filter has been fired: {0}', sbList);
    return getErrorPageURL(requestUrl, referrerUrl, sbList);
  };
  /**
   * Temporarily allowlist URL
   * Adds URL to trusted sites (this URL will be ignored by safebrowsing filter)
   *
   * @param url URL
   */


  const addToSafebrowsingTrusted = function (url) {
    const host = utils.url.getHost(url);

    if (!host) {
      return;
    }

    safebrowsingCache.cache.saveValue(createHash(host), SB_ALLOW_LIST);
  };
  /**
   * Clears safebrowsing cache
   */


  const clearCache = () => {
    safebrowsingCache.cache.clear();
  };
  /**
   * Subscribes to safebrowsing setting change and clears cache when setting changes
   */


  const init = () => {
    listeners.addSpecifiedListener(listeners.SETTING_UPDATED, (_, {
      propertyName
    }) => {
      if (propertyName === settings.DISABLE_SAFEBROWSING) {
        clearCache();
      }
    });
  }; // Init


  init();
  return {
    checkSafebrowsingFilter,
    lookupUrl,
    addToSafebrowsingTrusted,
    getErrorPageURL,
    extractHosts,
    createHashesMap,
    processSbResponse,
    clearCache
  };
}();

/* harmony default export */ const safebrowsing_browsers = (safebrowsing);
;// CONCATENATED MODULE: ./Extension/src/background/filter/services/safebrowsing/index.js
/**
 * !IMPORTANT!
 * `./safebrowsing.__ABSTRACT_API__` should be replaced during bundling with webpack with proper module
 *  - safebrowsing.adguard-api.js - for adguard-api
 *  - safebrowsing.browsers.js - for other browsers
 */


;// CONCATENATED MODULE: ./Extension/src/background/filter/filters/filters-tags.js


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * Filter tags service
 */

const tags = (() => {
  const RECOMMENDED_TAG_ID = 10;
  const PURPOSE_ADS_TAG_ID = 1;
  const PURPOSE_PRIVACY_TAG_ID = 2;
  const PURPOSE_SOCIAL_TAG_ID = 3;
  const PURPOSE_SECURITY_TAG_ID = 4;
  const PURPOSE_ANNOYANCES_TAG_ID = 5;
  const PURPOSE_COOKIES_TAG_ID = 6;
  const PURPOSE_MOBILE_TAG_ID = 19;

  const getTags = function () {
    return subscriptions.getTags();
  };

  const getFilters = function () {
    return subscriptions.getFilters().filter(f => f.filterId !== utils.filters.SEARCH_AND_SELF_PROMO_FILTER_ID);
  };

  const getFiltersByTagId = function (tagId, filters) {
    return filters.filter(f => f.tags.indexOf(tagId) >= 0);
  };

  const getRecommendedFilters = function (filters) {
    return getFiltersByTagId(RECOMMENDED_TAG_ID, filters);
  };

  const isRecommendedFilter = filter => filter.tags.includes(RECOMMENDED_TAG_ID);

  const isMobileFilter = filter => filter.tags.includes(PURPOSE_MOBILE_TAG_ID);

  const getPurposeGroupedFilters = function () {
    const filters = getFilters();
    const adsFilters = getFiltersByTagId(PURPOSE_ADS_TAG_ID, filters);
    const socialFilters = getFiltersByTagId(PURPOSE_SOCIAL_TAG_ID, filters);
    const privacyFilters = getFiltersByTagId(PURPOSE_PRIVACY_TAG_ID, filters);
    const annoyancesFilters = getFiltersByTagId(PURPOSE_ANNOYANCES_TAG_ID, filters);
    const cookiesFilters = getFiltersByTagId(PURPOSE_COOKIES_TAG_ID, filters);
    const securityFilters = getFiltersByTagId(PURPOSE_SECURITY_TAG_ID, filters);
    return {
      ads: adsFilters,
      social: socialFilters,
      privacy: privacyFilters,
      security: securityFilters,
      annoyances: annoyancesFilters,
      cookies: cookiesFilters
    };
  };

  return {
    getTags,
    getPurposeGroupedFilters,
    isRecommendedFilter,
    isMobileFilter,
    getFiltersByTagId,
    getRecommendedFilters
  };
})();
;// CONCATENATED MODULE: ./Extension/src/background/filter/filters/filters-categories.js


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */




/**
 * Filter categories service
 */

const categories = (() => {
  /**
   * @returns {Array.<*>} filters
   */
  const getFilters = function () {
    const result = subscriptions.getFilters().filter(f => {
      return !f.removed;
    });
    const filterTags = tags.getTags();
    result.forEach(f => {
      f.tagsDetails = [];
      f.tags.forEach(tagId => {
        const tagDetails = filterTags.find(tag => {
          return tag.tagId === tagId;
        });

        if (tagDetails) {
          if (tagDetails.keyword.startsWith('reference:')) {
            // Hide 'reference:' tags
            return;
          }

          if (!tagDetails.keyword.startsWith('lang:')) {
            // Hide prefixes except of 'lang:'
            tagDetails.keyword = tagDetails.keyword.substring(tagDetails.keyword.indexOf(':') + 1);
          }

          f.tagsDetails.push(tagDetails);
        }
      });
    });
    return result;
  };
  /**
   * Selects filters by groupId
   *
   * @param groupId
   * @param filters
   * @returns {Array.<SubscriptionFilter>}
   */


  const selectFiltersByGroupId = function (groupId, filters) {
    return filters.filter(filter => filter.groupId === groupId);
  };
  /**
   * Constructs filters metadata for options.html page
   */


  const getFiltersMetadata = function () {
    const groupsMeta = subscriptions.getGroups();
    const filters = getFilters();
    const categories = [];

    for (let i = 0; i < groupsMeta.length; i += 1) {
      const category = groupsMeta[i];
      category.filters = selectFiltersByGroupId(category.groupId, filters);
      categories.push(category);
    }

    return {
      filters,
      categories
    };
  };
  /**
   * If filter has mobile tag we check if platform is mobile, in other cases we do not check
   * @param filter
   * @returns {boolean}
   */


  const doesFilterMatchPlatform = filter => {
    if (tags.isMobileFilter(filter)) {
      return !!prefs.mobile;
    }

    return true;
  };
  /**
   * Returns recommended filters, which meet next requirements
   * 1. filter has recommended tag
   * 2. if filter has language tag, tag should match with user locale
   * 3. filter should correspond to platform mobile or desktop
   * @param groupId
   * @returns {Array} recommended filters by groupId
   */


  const getRecommendedFilterIdsByGroupId = function (groupId) {
    const metadata = getFiltersMetadata();
    const result = [];
    const langSuitableFilters = subscriptions.getLangSuitableFilters();

    for (let i = 0; i < metadata.categories.length; i += 1) {
      const category = metadata.categories[i];

      if (category.groupId === groupId) {
        category.filters.forEach(filter => {
          if (tags.isRecommendedFilter(filter) && doesFilterMatchPlatform(filter)) {
            // get ids intersection to enable recommended filters matching the lang tag
            // only if filter has language
            if (filter.languages && filter.languages.length > 0) {
              if (langSuitableFilters.includes(filter.filterId)) {
                result.push(filter.filterId);
              }
            } else {
              result.push(filter.filterId);
            }
          }
        });
        return result;
      }
    }

    return result;
  };
  /**
   * If group doesn't have enabled property we consider that group is enabled for the first time
   * On first group enable we add and enable recommended filters by groupId
   * On the next calls we just enable group
   * @param {number} groupId
   */


  const enableFiltersGroup = async function (groupId) {
    const group = subscriptions.getGroup(groupId);

    if (group && typeof group.enabled === 'undefined') {
      const recommendedFiltersIds = getRecommendedFilterIdsByGroupId(groupId);
      await application.addAndEnableFilters(recommendedFiltersIds);
    }

    application.enableGroup(groupId);
  };
  /**
   * Disables group
   * @param {number} groupId
   * @param {boolean} drop
   */


  const disableFiltersGroup = function (groupId, drop) {
    application.disableGroup(groupId, drop);
  };

  return {
    getFiltersMetadata,
    enableFiltersGroup,
    disableFiltersGroup
  };
})();
;// CONCATENATED MODULE: ./Extension/src/background/settings/default-settings.js

/**
 * Default settings set
 */

const defaultSettings = {
  'general-settings': {
    'allow-acceptable-ads': true,
    'show-blocked-ads-count': !settings.defaultProperties[settings.DISABLE_SHOW_PAGE_STATS],
    'autodetect-filters': !settings.defaultProperties[settings.DISABLE_DETECT_FILTERS],
    'safebrowsing-enabled': !settings.defaultProperties[settings.DISABLE_SAFEBROWSING],
    'filters-update-period': settings.DEFAULT_FILTERS_UPDATE_PERIOD,
    'appearance-theme': settings.defaultProperties[settings.APPEARANCE_THEME]
  },
  'extension-specific-settings': {
    'use-optimized-filters': settings.defaultProperties[settings.USE_OPTIMIZED_FILTERS],
    'collect-hits-count': !settings.defaultProperties[settings.DISABLE_COLLECT_HITS],
    'show-context-menu': !settings.defaultProperties[settings.DISABLE_SHOW_CONTEXT_MENU],
    'show-info-about-adguard': !settings.defaultProperties[settings.DISABLE_SHOW_ADGUARD_PROMO_INFO],
    'show-app-updated-info': !settings.defaultProperties[settings.DISABLE_SHOW_APP_UPDATED_NOTIFICATION],
    'hide-rate-adguard': settings.defaultProperties[settings.HIDE_RATE_BLOCK],
    'user-rules-editor-wrap': settings.defaultProperties[settings.USER_RULES_EDITOR_WRAP]
  },
  'filters': {
    'enabled-groups': [1, 6, 7],
    'enabled-filters': [2, 10],
    'custom-filters': [],
    'user-filter': {
      'rules': '',
      'disabled-rules': '',
      'enabled': true
    },
    'whitelist': {
      'inverted': false,
      'domains': [],
      'inverted-domains': [],
      'enabled': true
    }
  },
  'stealth': {
    'stealth_disable_stealth_mode': settings.defaultProperties[settings.DISABLE_STEALTH_MODE],
    'stealth-hide-referrer': settings.defaultProperties[settings.HIDE_REFERRER],
    'stealth-hide-search-queries': settings.defaultProperties[settings.HIDE_SEARCH_QUERIES],
    'stealth-send-do-not-track': settings.defaultProperties[settings.SEND_DO_NOT_TRACK],
    'stealth-block-webrtc': settings.defaultProperties[settings.BLOCK_WEBRTC],
    'stealth-remove-x-client': settings.defaultProperties[settings.BLOCK_CHROME_CLIENT_DATA],
    'stealth-block-third-party-cookies': settings.defaultProperties[settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES],
    'stealth-block-third-party-cookies-time': settings.defaultProperties[settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES_TIME],
    'stealth-block-first-party-cookies': settings.defaultProperties[settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES],
    'stealth-block-first-party-cookies-time': settings.defaultProperties[settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES_TIME],
    'block-known-trackers': false,
    'strip-tracking-parameters': false
  }
};
// EXTERNAL MODULE: ./Extension/src/background/settings/validator.js
var validator = __webpack_require__(80352);
var validator_default = /*#__PURE__*/__webpack_require__.n(validator);
;// CONCATENATED MODULE: ./Extension/src/background/settings/settings-provider.js


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */












/**
 * This is standalone validator module precompiled by ajv
 * We use this module for prevent ajv run cached validator function code from string
 */


/**
 * Application settings provider.
 */

const settingsProvider = function () {
  const BACKUP_PROTOCOL_VERSION = '1.0';
  /**
   * Collect enabled filters ids without custom filters
   * @returns {Array}
   */

  const collectEnabledFilterIds = () => {
    const enabledFilters = application.getEnabledFilters();
    return enabledFilters.filter(filter => !filter.customUrl).map(filter => filter.filterId);
  };
  /**
   * Collects data about added custom filters to the extension
   * @returns {CustomFilterInitial} - returns data enough to import custom filter
   */


  const collectCustomFiltersData = () => {
    const customFiltersList = customFilters.getCustomFilters();
    return customFiltersList.map(filter => ({
      customUrl: filter.customUrl,
      enabled: filter.enabled,
      title: filter.name || '',
      trusted: filter.trusted
    }));
  };

  const collectEnabledGroupIds = () => {
    const groups = subscriptions.getGroups();
    return groups.filter(group => group.enabled).map(group => group.groupId);
  };
  /**
   * Loads filters settings section
   */


  const loadFiltersSection = async () => {
    const enabledFilterIds = collectEnabledFilterIds();
    const enabledGroupIds = collectEnabledGroupIds();
    const customFiltersData = collectCustomFiltersData(); // Collect allowlist/blacklist domains, allowlist inverted mode and allowlist enabled state

    const allowlistDomains = allowlist.getAllowlistedDomains() || [];
    const blockListDomains = allowlist.getBlocklistedDomains() || [];
    const defaultAllowlistMode = !!allowlist.isDefaultMode();
    const allowlistEnabled = settings.getAllowlistEnabledState(); // Collect user rules

    const content = await userrules.getUserRulesText();
    const userFilterEnabled = settings.getUserFilterEnabled();
    const section = {
      'filters': {
        'enabled-groups': enabledGroupIds,
        'enabled-filters': enabledFilterIds,
        'custom-filters': customFiltersData,
        'user-filter': {
          'rules': content,
          'disabled-rules': '',
          enabled: userFilterEnabled
        },
        'whitelist': {
          'inverted': !defaultAllowlistMode,
          'domains': allowlistDomains,
          'inverted-domains': blockListDomains,
          'enabled': allowlistEnabled
        }
      }
    };
    return section;
  };
  /**
   * Loads stealth mode settings section
   */


  const loadStealthModeSection = () => {
    const enabledFilterIds = collectEnabledFilterIds();
    const blockKnownTrackers = enabledFilterIds.indexOf(utils.filters.ids.TRACKING_FILTER_ID) >= 0;
    const stripTrackingParameters = enabledFilterIds.indexOf(utils.filters.ids.URL_TRACKING_FILTER_ID) >= 0;
    const section = {
      stealth: {
        'stealth_disable_stealth_mode': settings.getDisableStealthMode(),
        'stealth-hide-referrer': settings.getHideReferrer(),
        'stealth-hide-search-queries': settings.getHideSearchQueries(),
        'stealth-send-do-not-track': settings.getSendDoNotTrack(),
        'stealth-block-webrtc': settings.isWebRTCDisabled(),
        'stealth-remove-x-client': settings.isRemoveXClientData(),
        'stealth-block-third-party-cookies': settings.getSelfDestructThirdPartyCookies(),
        'stealth-block-third-party-cookies-time': settings.getSelfDestructThirdPartyCookiesTime(),
        'stealth-block-first-party-cookies': settings.getSelfDestructFirstPartyCookies(),
        'stealth-block-first-party-cookies-time': settings.getSelfDestructFirstPartyCookiesTime(),
        'block-known-trackers': blockKnownTrackers,
        'strip-tracking-parameters': stripTrackingParameters
      }
    };
    return section;
  };
  /**
   * Loads general settings section
   */


  const loadGeneralSettingsSection = function () {
    const enabledFilterIds = collectEnabledFilterIds(); // TODO update self search settings on filter status change

    const allowAcceptableAds = enabledFilterIds.indexOf(utils.filters.ids.SEARCH_AND_SELF_PROMO_FILTER_ID) >= 0;
    const section = {
      'general-settings': {
        'app-language': backgroundPage.app.getLocale(),
        'allow-acceptable-ads': allowAcceptableAds,
        'show-blocked-ads-count': settings.showPageStatistic(),
        'autodetect-filters': settings.isAutodetectFilters(),
        'safebrowsing-enabled': settings.safebrowsingInfoEnabled(),
        'filters-update-period': settings.getFiltersUpdatePeriod(),
        'appearance-theme': settings.getAppearanceTheme()
      }
    };
    return section;
  };
  /**
   * Loads extension specific settings section
   */


  const loadExtensionSpecificSettingsSection = function () {
    const section = {
      'extension-specific-settings': {
        'use-optimized-filters': settings.isUseOptimizedFiltersEnabled(),
        'collect-hits-count': settings.collectHitsCount(),
        'show-context-menu': settings.showContextMenu(),
        'show-info-about-adguard': settings.isShowInfoAboutAdguardFullVersion(),
        'show-app-updated-info': settings.isShowAppUpdatedNotification(),
        'hide-rate-adguard': settings.isHideRateBlock(),
        'user-rules-editor-wrap': settings.isUserRulesEditorWrap()
      }
    };
    return section;
  };
  /**
   * Applies general section settings to application
   * @param section Section
   */


  const applyGeneralSettingsSection = async function (section) {
    const set = section['general-settings'];
    settings.changeShowPageStatistic(!!set['show-blocked-ads-count']);
    settings.changeAutodetectFilters(!!set['autodetect-filters']);
    settings.changeEnableSafebrowsing(!!set['safebrowsing-enabled']);
    settings.setFiltersUpdatePeriod(set['filters-update-period']);
    settings.setAppearanceTheme(set['appearance-theme']);

    if (set['allow-acceptable-ads']) {
      await application.addAndEnableFilters([utils.filters.ids.SEARCH_AND_SELF_PROMO_FILTER_ID]);
    } else {
      application.disableFilters([utils.filters.ids.SEARCH_AND_SELF_PROMO_FILTER_ID]);
    }
  };
  /**
   * Applies extension specific section settings to application
   * @param section
   */


  const applyExtensionSpecificSettingsSection = function (section) {
    const set = section['extension-specific-settings'];
    settings.changeUseOptimizedFiltersEnabled(!!set['use-optimized-filters']);
    settings.changeCollectHitsCount(!!set['collect-hits-count']);
    settings.changeShowContextMenu(!!set['show-context-menu']);
    settings.changeShowInfoAboutAdguardFullVersion(!!set['show-info-about-adguard']);
    settings.changeShowAppUpdatedNotification(!!set['show-app-updated-info']);
    settings.changeHideRateBlock(!!set['hide-rate-adguard']);
    settings.changeUserRulesEditorWrap(!!set['user-rules-editor-wrap']);
  };
  /**
   * Applies stealth mode section settings to application
   * @param section
   */


  const applyStealthModeSection = async section => {
    const set = section['stealth'];

    if (!set) {
      // use default settings
      return;
    } // set "block webrtc" setting as soon as possible. AG-9980
    // don't set the actual value to avoid requesting permissions


    if (settings.isWebRTCDisabled() !== !!set['stealth-block-webrtc']) {
      settings.setWebRTCDisabled(!!set['stealth-block-webrtc']);
    }

    settings.setDisableStealthMode(!!set['stealth_disable_stealth_mode']);
    settings.setHideReferrer(!!set['stealth-hide-referrer']);
    settings.setHideSearchQueries(!!set['stealth-hide-search-queries']);
    settings.setSendDoNotTrack(!!set['stealth-send-do-not-track']);
    settings.setRemoveXClientData(!!set['stealth-remove-x-client']);
    settings.setSelfDestructThirdPartyCookies(!!set['stealth-block-third-party-cookies']);
    settings.setSelfDestructThirdPartyCookiesTime(set['stealth-block-third-party-cookies-time']);
    settings.setSelfDestructFirstPartyCookies(!!set['stealth-block-first-party-cookies']);
    settings.setSelfDestructFirstPartyCookiesTime(set['stealth-block-first-party-cookies-time']);

    if (set['strip-tracking-parameters']) {
      await application.addAndEnableFilters([utils.filters.ids.URL_TRACKING_FILTER_ID]);
    } else {
      application.disableFilters([utils.filters.ids.URL_TRACKING_FILTER_ID]);
    }
  };
  /**
   * Initial data needed to add custom filter from the scratch
   * @typedef {Object} CustomFilterInitial
   * @property {string} customUrl - url of the custom filter
   * @property {boolean} enabled - state of custom filter
   * @property {number} [filterId] - identifier of the filter
   * @property {boolean} [trusted] - trusted flag of the filter
   * @property {string} [title] - title of the filter
   */

  /**
   * Add a custom filter
   * @param {CustomFilterInitial} customFilterData - initial data of imported custom filter
   * @returns {Promise<any>} SubscriptionFilter
   */


  const addCustomFilter = async customFilterData => {
    const {
      customUrl,
      title,
      trusted,
      enabled
    } = customFilterData;
    const options = {
      title,
      trusted,
      enabled
    };
    const filter = await application.loadCustomFilter(customUrl, options);
    return filter;
  };

  const addCustomFilters = async absentCustomFiltersInitials => {
    const result = []; // eslint-disable-next-line no-restricted-syntax

    for (const customFilterInitial of absentCustomFiltersInitials) {
      try {
        // eslint-disable-next-line no-await-in-loop
        const customFilter = await addCustomFilter(customFilterInitial);
        log/* log.info */.c.info(`Settings sync: Custom filter was added: ${customFilter.customUrl}`);
        result.push({
          error: null,
          filter: customFilter
        });
      } catch (e) {
        const {
          customUrl
        } = customFilterInitial;
        const message = `Settings sync: Error occurred while downloading: ${customUrl} - ${e.message}`;
        log/* log.info */.c.info(message);
        result.push({
          error: message
        });
      }
    }

    return result;
  };
  /**
   * Remove existing custom filters before adding new custom filters
   */


  const removeCustomFilters = filterIds => {
    filterIds.forEach(filterId => {
      application.removeFilter(filterId);
    });
    log/* log.info */.c.info(`Settings sync: Next filters were removed: ${filterIds}`);
  };
  /**
   * Returns filterId which not listed in the filtersToAdd list, but listed in the existingFilters
   * @param existingFilters
   * @param filtersToAdd
   * @returns {array<number>}
   */


  const getCustomFiltersToRemove = (existingFilters, filtersToAdd) => {
    const customUrlsToAdd = filtersToAdd.map(f => f.customUrl);
    const filtersToRemove = existingFilters.filter(f => !customUrlsToAdd.includes(f.customUrl));
    return filtersToRemove.map(f => f.filterId);
  };
  /**
   * Adds custom filters if there were not added one by one to the subscriptions list
   * @param {Array<CustomFilterInitial>} customFiltersInitials
   * @returns {Promise<any>} Promise object which represents array with filters
   */


  const syncCustomFilters = async customFiltersInitials => {
    const presentCustomFilters = customFilters.getCustomFilters();
    const enrichedFiltersInitials = customFiltersInitials.map(filterToAdd => {
      presentCustomFilters.forEach(existingFilter => {
        if (existingFilter.customUrl === filterToAdd.customUrl) {
          filterToAdd.filterId = existingFilter.filterId;
        }
      });
      return filterToAdd;
    });
    const customFiltersToAdd = enrichedFiltersInitials.filter(f => !f.filterId);
    const existingCustomFilters = enrichedFiltersInitials.filter(f => f.filterId);
    const redundantExistingCustomFiltersIds = getCustomFiltersToRemove(presentCustomFilters, customFiltersInitials);

    if (redundantExistingCustomFiltersIds.length > 0) {
      removeCustomFilters(redundantExistingCustomFiltersIds);
    }

    if (customFiltersToAdd.length === 0) {
      return enrichedFiltersInitials;
    }

    const customFiltersAddResult = await addCustomFilters(customFiltersToAdd); // get results without errors, in order to do not enable filters with errors

    const addedCustomFiltersWithoutError = customFiltersAddResult.filter(f => f.error === null).map(f => f.filter);
    const addedCustomFiltersIds = addedCustomFiltersWithoutError.map(f => f.filterId);
    log/* log.info */.c.info(`Settings sync: Were added custom filters: ${addedCustomFiltersIds}`);
    return [...existingCustomFilters, ...addedCustomFiltersWithoutError];
  };
  /**
   * Enables filters by filterId and disables those filters which were not in the list of enabled filters
   * @param {array<number>} filterIds - ids to enable
   * @returns {Promise<any>}
   */


  const syncEnabledFilters = async filterIds => {
    await application.addAndEnableFilters(filterIds, {
      forceRemote: true
    });
    const enabledFilters = application.getEnabledFilters();
    const filtersToDisable = enabledFilters.filter(enabledFilter => !filterIds.includes(enabledFilter.filterId)).map(filter => filter.filterId);
    application.disableFilters(filtersToDisable);
  };
  /**
   * Enables groups by groupId and disable those groups which were not in the list
   * @param {array<number>} enabledGroups
   * @param {boolean} drop enabled flag
   */


  const syncEnabledGroups = (enabledGroups, drop) => {
    enabledGroups.forEach(groupId => {
      categories.enableFiltersGroup(groupId);
    });
    log/* log.info */.c.info(`Settings sync: Next groups were enabled: ${enabledGroups}`); // disable groups not listed in the imported list

    const groups = subscriptions.getGroups();
    const groupIdsToDisable = groups.map(group => group.groupId).filter(groupId => !enabledGroups.includes(groupId));
    groupIdsToDisable.forEach(groupId => {
      categories.disableFiltersGroup(groupId, drop);
    });
  };
  /**
   * Applies filters section settings to application
   * @param section Section
   * @param dropGroupsEnabled
   */


  const applyFiltersSection = async function (section, dropGroupsEnabled) {
    const allowlistSection = section.filters['whitelist'] || {};
    const allowlistDomains = allowlistSection.domains || [];
    const blacklistDomains = allowlistSection['inverted-domains'] || []; // Apply allowlist/blacklist domains, allowlist mode and allowlist enabled state

    allowlist.configure({
      allowlist: allowlistDomains,
      blocklist: blacklistDomains,
      mode: !allowlistSection.inverted,
      enabled: typeof allowlistSection.enabled === 'undefined' ? true : !!allowlistSection.enabled
    });
    const userFilterSection = section.filters['user-filter'] || {};
    const userRules = userFilterSection.rules || '';
    const userFilterEnabled = typeof userFilterSection.enabled === 'undefined' ? true : userFilterSection.enabled; // Apply user rules

    settings.setUserFilterEnabled(userFilterEnabled);
    userrules.updateUserRulesText(userRules); // Apply custom filters

    const customFiltersData = section.filters['custom-filters'] || []; // STEP 1 sync custom filters

    const availableCustomFilters = await syncCustomFilters(customFiltersData); // STEP 2 get filters with enabled flag from export data

    const customFilterIdsToEnable = availableCustomFilters.filter(availableCustomFilter => {
      const filterData = customFiltersData.find(filter => {
        if (!filter.customUrl) {
          // eslint-disable-next-line max-len
          throw new Error(`Custom filter should always have custom URL: ${JSON.stringify(filter)}`);
        }

        return filter.customUrl === availableCustomFilter.customUrl;
      });
      return filterData && filterData.enabled;
    }).map(filter => filter.filterId); // STEP 3 sync enabled filters

    const enabledFilterIds = section.filters['enabled-filters'] || [];
    await syncEnabledFilters([...enabledFilterIds, ...customFilterIdsToEnable]); // STEP 4 sync enabled groups

    const enabledGroups = section.filters['enabled-groups'] || [];
    syncEnabledGroups(enabledGroups, dropGroupsEnabled);
  };
  /**
   * Exports settings set in json format
   */


  const loadSettingsBackupJson = async function () {
    const result = {
      'protocol-version': BACKUP_PROTOCOL_VERSION
    };
    const generalSettingsSection = loadGeneralSettingsSection();
    result['general-settings'] = generalSettingsSection['general-settings'];
    const extensionSpecificSettingsSection = loadExtensionSpecificSettingsSection();
    result['extension-specific-settings'] = extensionSpecificSettingsSection['extension-specific-settings'];
    const filtersSection = await loadFiltersSection();
    result['filters'] = filtersSection['filters'];
    const stealthSection = loadStealthModeSection();
    result['stealth'] = stealthSection['stealth'];
    return JSON.stringify(result);
  };
  /**
   * Validates data
   *
   * @param data
   */


  const validateJSON = data => {
    const valid = validator_default()(data);

    if (!valid) {
      log/* log.error */.c.error((validator_default()).errors);
      return false;
    }

    return true;
  };
  /**
   * Imports settings set from json format
   * @param {string} json
   */


  const applySettingsBackupJson = async function (json) {
    function onFinished(success) {
      if (success) {
        log/* log.info */.c.info('Settings import finished successfully');
      } else {
        log/* log.error */.c.error('Error importing settings');
      }

      listeners.notifyListeners(listeners.SETTINGS_UPDATED, success);
    }

    let input = null;

    try {
      input = JSON.parse(json);
    } catch (ex) {
      log/* log.error */.c.error('Error parsing input json {0}, {1}', json, ex);
      onFinished(false);
      return false;
    }

    if (!input || input['protocol-version'] !== BACKUP_PROTOCOL_VERSION || !validateJSON(input)) {
      log/* log.error */.c.error('Json input is invalid {0}', json);
      onFinished(false);
      return false;
    }

    try {
      // apply stealth settings as soon as possible due to WebRTC permissions. AG-9980
      await applyStealthModeSection(input);
      await applyGeneralSettingsSection(input);
      applyExtensionSpecificSettingsSection(input);
      await applyFiltersSection(input);
      onFinished(true);
      return true;
    } catch (e) {
      log/* log.error */.c.error(e);
      onFinished(false);
      return false;
    }
  };
  /**
   * Applies default settings
   *
   * @return {Promise<boolean>}
   */


  const applyDefaultSettings = async () => {
    const input = defaultSettings;

    try {
      await applyGeneralSettingsSection(input);
      applyExtensionSpecificSettingsSection(input);
      await applyFiltersSection(input, true);
      await applyStealthModeSection(input);
      await application.addAndEnableFilters(subscriptions.getLangSuitableFilters());
      return true;
    } catch (e) {
      log/* log.error */.c.error(e);
      return false;
    }
  }; // EXPOSE


  return {
    /**
     * Loads settings backup json
     */
    loadSettingsBackup: loadSettingsBackupJson,

    /**
     * Applies settings backup json
     */
    applySettingsBackup: applySettingsBackupJson,

    /**
     * Applies default settings json
     */
    applyDefaultSettings
  };
}();
// EXTERNAL MODULE: ./node_modules/webextension-polyfill/dist/browser-polyfill.js
var browser_polyfill = __webpack_require__(53679);
var browser_polyfill_default = /*#__PURE__*/__webpack_require__.n(browser_polyfill);
;// CONCATENATED MODULE: ./Extension/src/background/utils/notifications.js


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */







/**
 * Object that manages user settings.
 * @constructor
 */

const notifications = function () {
  const VIEWED_NOTIFICATIONS = 'viewed-notifications';
  const LAST_NOTIFICATION_TIME = 'viewed-notification-time';
  const BIRTHDAY_14_PROMO_ID = 'birthday14Promo';
  const birthday14Notification = {
    id: BIRTHDAY_14_PROMO_ID,
    locales: {
      en: {
        title: 'What does AI say?',
        btn: 'Guess'
      },
      ru: {
        title: ' ',
        btn: ''
      },
      ko: {
        title: '  ?',
        btn: ' '
      },
      es: {
        title: 'Quiz: piensa como una IA',
        btn: 'Comenzar'
      },
      de: {
        title: 'Was sagt KI?',
        btn: 'Spielen'
      },
      pt_pt: {
        title: 'Quiz: pensa como uma IA',
        btn: 'Comear'
      },
      pt_br: {
        title: 'Quiz: pense como uma IA',
        btn: 'Comear'
      },
      zh_tw: {
        title: ' AI ',
        btn: ''
      },
      zh_cn: {
        title: ' AI ',
        btn: ''
      },
      ja: {
        title: 'AI ',
        btn: ''
      },
      fr: {
        title: 'L\'IA dit quoi?',
        btn: 'Devinez!'
      },
      it: {
        title: 'Cosa dice l\'IA?',
        btn: 'Indovinarlo'
      },
      uk: {
        title: '   ?',
        btn: ''
      },
      ar: {
        title: '   ',
        btn: ''
      },
      be: {
        title: '   ?',
        btn: ''
      },
      bg: {
        title: '  ?',
        btn: ''
      },
      ca: {
        title: 'Qu diu la IA?',
        btn: 'Jugar'
      },
      cs: {
        title: 'Co k uml inteligence?',
        btn: 'Pehrt'
      },
      da: {
        title: 'Hvad siger den kunstige intelligens?',
        btn: 'Spil'
      },
      el: {
        title: '    ;',
        btn: ''
      },
      es_419: {
        title: 'Quiz: piensa como una IA',
        btn: 'Comenzar'
      },
      fa: {
        title: '    ',
        btn: ''
      },
      fi: {
        title: 'Mit tekoly sanoo?',
        btn: 'Leikki'
      },
      he: {
        title: '?   ',
        btn: ''
      },
      hr: {
        title: 'to kae umjetna inteligencija?',
        btn: 'Igrati'
      },
      hu: {
        title: 'Mit mond az MI?',
        btn: 'Jtszik'
      },
      hy: {
        title: '   -:',
        btn: ''
      },
      id: {
        title: 'Apa yang dikatakan AI?',
        btn: 'Bermain'
      },
      lt: {
        title: 'K sako dirbtinis intelektas?',
        btn: 'aisti'
      },
      ms: {
        title: 'Apa kata Kecerdasan Buatan?',
        btn: 'Bermain'
      },
      nb: {
        title: 'Hva sier kunstig intelligens?',
        btn: 'Skuespill'
      },
      nl: {
        title: 'Wat zegt KI?',
        btn: 'Spelen'
      },
      pl: {
        title: 'Co mwi sztuczna inteligencja?',
        btn: 'Gra'
      },
      ro: {
        title: 'Ce spune inteligena artificial?',
        btn: 'Juca'
      },
      sk: {
        title: 'o hovor umel inteligencia?',
        btn: 'Hra'
      },
      sl: {
        title: 'Kaj pravi umetna inteligenca?',
        btn: 'Igrati'
      },
      sr: {
        title: 'ta kae vetaka inteligencija?',
        btn: 'Igra'
      },
      sv: {
        title: 'Vad sger artificiell intelligens?',
        btn: 'Leka'
      },
      tr: {
        title: 'Yapay zeka ne diyor?',
        btn: 'Oyun'
      },
      vi: {
        title: 'AI ni g?',
        btn: 'Chi'
      },
      hi: {
        title: '    ?',
        btn: ''
      },
      et: {
        title: 'Mida tleb tehisintellekt?',
        btn: 'Mngima'
      },
      th: {
        title: '?',
        btn: ''
      }
    },
    text: '',
    url: 'https://link.adtidy.net/forward.html?action=birthday_14_promo&app=browser_extension',
    from: '01 June 2023 12:00:00',
    to: '07 June 2023 23:59:00',
    type: 'animated',

    get icons() {
      return lazyGet(birthday14Notification, 'icons', () => ({
        ICON_GREEN: {
          '19': backgroundPage.getURL('assets/icons/bd14-on-19.png'),
          '38': backgroundPage.getURL('assets/icons/bd14-on-38.png')
        },
        ICON_GRAY: {
          '19': backgroundPage.getURL('assets/icons/bd14-off-19.png'),
          '38': backgroundPage.getURL('assets/icons/bd14-off-38.png')
        }
      }));
    }

  };
  /**
   * @typedef Notification
   * @type object
   * @property {string} id
   * @property {object} locales
   * @property {string} url
   * @property {string} text
   * @property {string} from
   * @property {string} to
   * @property {string} bgColor;
   * @property {string} textColor;
   * @property {string} badgeBgColor;
   * @property {string} badgeText;
   * @property {string} type;
   */

  const notifications = {
    birthday14Promo: birthday14Notification
  };
  /**
   * Gets the last time a notification was shown.
   * If it was not shown yet, initialized with the current time.
   */

  const getLastNotificationTime = function () {
    let lastTime = storage_localStorage.getItem(LAST_NOTIFICATION_TIME) || 0;

    if (lastTime === 0) {
      lastTime = new Date().getTime();
      storage_localStorage.setItem(LAST_NOTIFICATION_TIME, lastTime);
    }

    return lastTime;
  };

  const normalizeLanguage = locale => {
    if (!locale) {
      return null;
    }

    return locale.toLowerCase().replace('-', '_');
  };
  /**
   * Scans notification locales and returns the one matching navigator.language
   * @param {*} notification notification object
   * @returns {string} matching text or null
   */


  const getNotificationText = function (notification) {
    const language = normalizeLanguage(browser_polyfill_default().i18n.getUILanguage());

    if (!language) {
      return null;
    }

    const languageCode = language.split('_')[0];

    if (!languageCode) {
      return null;
    }

    return notification.locales[language] || notification.locales[languageCode];
  };
  /**
   * Scans notifications list and prepares them to be used (or removes expired)
   */


  const initNotifications = function () {
    const notificationsKeys = Object.keys(notifications);

    for (let i = 0; i < notificationsKeys.length; i += 1) {
      const notificationKey = notificationsKeys[i];
      const notification = notifications[notificationKey];
      notification.text = getNotificationText(notification);
      const to = new Date(notification.to).getTime();
      const expired = new Date().getTime() > to;

      if (!notification.text || expired) {
        // Remove expired and invalid
        delete notifications[notificationKey];
      }
    }
  }; // Prepare the notifications


  initNotifications();
  let currentNotification;
  let notificationCheckTime;
  const checkTimeoutMs = 10 * 60 * 1000; // 10 minutes

  const minPeriod = 30 * 60 * 1000; // 30 minutes

  const DELAY = 30 * 1000; // clear notification in 30 seconds

  let timeoutId;
  /**
   * Marks current notification as viewed
   * @param {boolean} withDelay if true, do this after a 30 sec delay
   */

  const setNotificationViewed = async function (withDelay) {
    if (withDelay) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        setNotificationViewed(false);
      }, DELAY);
      return;
    }

    if (currentNotification) {
      const viewedNotifications = storage_localStorage.getItem(VIEWED_NOTIFICATIONS) || [];
      const {
        id
      } = currentNotification;

      if (!viewedNotifications.includes(id)) {
        viewedNotifications.push(id);
        storage_localStorage.setItem(VIEWED_NOTIFICATIONS, viewedNotifications);
        const tab = await tabsApi.getActive();

        if (tab) {
          uiService.updateTabIconAndContextMenu(tab);
        }

        currentNotification = null;
      }
    }
  };
  /**
   * Finds out notification for current time and checks if notification wasn't shown yet
   *
   * @returns {null|Notification} - notification
   */


  const getCurrentNotification = function () {
    // Do not display notification on Firefox
    if (browserUtils.isFirefoxBrowser()) {
      return null;
    }

    const currentTime = new Date().getTime();
    const timeSinceLastNotification = currentTime - getLastNotificationTime();

    if (timeSinceLastNotification < minPeriod) {
      // Just a check to not show the notification too often
      return null;
    } // Check not often than once in 10 minutes


    const timeSinceLastCheck = currentTime - notificationCheckTime;

    if (notificationCheckTime > 0 && timeSinceLastCheck <= checkTimeoutMs) {
      return currentNotification;
    } // Update the last notification check time


    notificationCheckTime = currentTime;
    const notificationsKeys = Object.keys(notifications);
    const viewedNotifications = storage_localStorage.getItem(VIEWED_NOTIFICATIONS) || [];

    for (let i = 0; i < notificationsKeys.length; i += 1) {
      const notificationKey = notificationsKeys[i];
      const notification = notifications[notificationKey];
      const from = new Date(notification.from).getTime();
      const to = new Date(notification.to).getTime();

      if (from < currentTime && to > currentTime && !viewedNotifications.includes(notification.id)) {
        currentNotification = notification;
        return currentNotification;
      }
    }

    currentNotification = null;
    return currentNotification;
  };

  return {
    getCurrentNotification,
    setNotificationViewed,
    VIEWED_NOTIFICATIONS,
    LAST_NOTIFICATION_TIME
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/update-service.js


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */













/**
 * Service that manages extension version information and handles
 * extension update. For instance we may need to change storage schema on update.
 */

const applicationUpdateService = function () {
  /**
   * Helper to execute promises one by one
   *
   * @param methods Methods to execute
   * @private
   */
  async function executeMethods(methods) {
    try {
      // eslint-disable-next-line no-restricted-syntax
      for (const method of methods) {
        // eslint-disable-next-line no-await-in-loop
        await method();
      }
    } catch (e) {
      // if catch error while updating, reset settings and reload extension
      await settingsProvider.applyDefaultSettings();
      backgroundPage.runtime.reload();
    }
  }

  function handleUndefinedGroupStatuses() {
    const filters = subscriptions.getFilters();
    const filtersStateInfo = filtersState.getFiltersState();
    const enabledFilters = filters.filter(filter => {
      const {
        filterId
      } = filter;
      return !!(filtersStateInfo[filterId] && filtersStateInfo[filterId].enabled);
    });
    const groupState = filtersState.getGroupsState();
    enabledFilters.forEach(filter => {
      const {
        groupId
      } = filter;

      if (typeof groupState[groupId] === 'undefined') {
        application.enableGroup(filter.groupId);
      }
    });
  }

  function handleDefaultUpdatePeriodSetting() {
    const previousDefaultValue = 48 * 60 * 60 * 1000;
    const currentUpdatePeriod = settings.getFiltersUpdatePeriod();

    if (currentUpdatePeriod === previousDefaultValue) {
      settings.setFiltersUpdatePeriod(settings.DEFAULT_FILTERS_UPDATE_PERIOD);
    }
  }

  function clearCaches() {
    safebrowsing_browsers.clearCache();
  }
  /**
   * From that version we store already converted rule texts in storage
   */


  async function onUpdateRuleConverter() {
    const filtersStateInfo = filtersState.getFiltersState();
    const installedFiltersIds = Object.keys(filtersStateInfo).map(filterId => Number.parseInt(filterId, 10));
    const reloadRulesPromises = installedFiltersIds.map(async filterId => {
      if (filterId === utils.filters.USER_FILTER_ID) {
        return;
      }

      let loadedRulesText = await rulesStorage.read(filterId);

      if (!loadedRulesText) {
        loadedRulesText = [];
      }

      log/* log.info */.c.info('Reloading and converting {0} rules for filter {1}', loadedRulesText.length, filterId);
      const converted = es/* RuleConverter.convertRules */.cR.convertRules(loadedRulesText.join('\n')).split('\n');
      log/* log.debug */.c.debug('Saving {0} rules to filter {1}', converted.length, filterId);
      await rulesStorage.write(filterId, converted);
    });
    await Promise.all(reloadRulesPromises);
  }
  /**
   * In the v4.0.171 we have littered window.localStorage with proms used in the promo notifications module, now we
   * are clearing them
   */


  function onUpdateClearPromoDetails() {
    window.localStorage.removeItem(notifications.VIEWED_NOTIFICATIONS);
    window.localStorage.removeItem(notifications.LAST_NOTIFICATION_TIME);
  }
  /**
   * Function removes obsolete filters from the storage
   * @returns {Promise<any>}
   */


  async function handleObsoleteFiltersRemoval() {
    const filtersStateInfo = filtersState.getFiltersState();
    const allFiltersMetadata = subscriptions.getFilters();
    const installedFiltersIds = Object.keys(filtersStateInfo).map(filterId => Number.parseInt(filterId, 10));
    const existingFiltersIds = installedFiltersIds.filter(filterId => {
      return allFiltersMetadata.find(f => f.filterId === filterId);
    });
    const filtersIdsToRemove = installedFiltersIds.filter(id => {
      return !existingFiltersIds.includes(id);
    });
    filtersIdsToRemove.forEach(filterId => filtersState.removeFilter(filterId));
    const removePromises = filtersIdsToRemove.map(async filterId => {
      await rulesStorage.remove(filterId);
      log/* log.info */.c.info(`Filter with id: ${filterId} removed from the storage`);
    });
    await Promise.all(removePromises);
  }
  /**
   * Async returns extension run info
   *
   * {{isFirstRun: boolean, isUpdate: (boolean|*), currentVersion: (Prefs.version|*), prevVersion: *}}
   */


  const getRunInfo = function () {
    const prevVersion = browserUtils.getAppVersion();
    const currentVersion = backgroundPage.app.getVersion();
    browserUtils.setAppVersion(currentVersion);
    const isFirstRun = currentVersion !== prevVersion && !prevVersion;
    const isUpdate = !!(currentVersion !== prevVersion && prevVersion);
    return {
      isFirstRun,
      isUpdate,
      currentVersion,
      prevVersion
    };
  };
  /**
   * Handle extension update
   * @param runInfo   Run info
   */


  const onUpdate = async function (runInfo) {
    const methods = [];
    log/* log.info */.c.info(`The extension was updated from ${runInfo.prevVersion}`);

    if (browserUtils.isGreaterVersion('3.0.3', runInfo.prevVersion)) {
      methods.push(handleUndefinedGroupStatuses);
    }

    if (browserUtils.isGreaterVersion('3.3.5', runInfo.prevVersion)) {
      methods.push(handleDefaultUpdatePeriodSetting);
    }

    if (browserUtils.isGreaterVersion('4.0.67', runInfo.prevVersion)) {
      methods.push(onUpdateRuleConverter);
    }

    if (browserUtils.isGreaterVersion('4.0.180', runInfo.prevVersion)) {
      methods.push(onUpdateClearPromoDetails);
    } // On every update remove if necessary obsolete filters


    methods.push(handleObsoleteFiltersRemoval); // On every update clear persisted caches

    methods.push(clearCaches);
    await executeMethods(methods);
  };

  return {
    getRunInfo,
    onUpdate
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/filter/filters/filters-update.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */








/**
 * Filters update service
 */

const filtersUpdate = (() => {
  /**
   * Delay before doing first filters update check -- 5 minutes
   */
  const UPDATE_FILTERS_DELAY = 5 * 60 * 1000; // Get filters update period

  let filtersUpdatePeriod = settings.getFiltersUpdatePeriod();
  /**
   * Gets expires in sec end return in ms
   * If expires was less then minimumExpiresTime or we couldn't parse its value,
   * then return minimumExpiresTime
   * @param {*} expires
   * @returns {number}
   */

  const normalizeExpires = expires => {
    const minimumExpiresSec = 60 * 60;
    expires = Number.parseInt(expires, 10);

    if (Number.isNaN(expires) || expires < minimumExpiresSec) {
      expires = minimumExpiresSec;
    }

    return expires * 1000;
  };
  /**
   * Select filters for update. It depends on the time of last update,
   * on the filter enable status and group enable status
   * @param forceUpdate Force update flag.
   * @param filtersToUpdate Optional array of filters
   * @returns object
   */


  const selectFilterIdsToUpdate = (forceUpdate, filtersToUpdate) => {
    const filterIds = [];
    const customFilterIds = [];
    const filters = filtersToUpdate || subscriptions.getFilters();

    const needUpdate = filter => {
      const {
        lastCheckTime
      } = filter;
      let {
        expires
      } = filter;

      if (!lastCheckTime) {
        return true;
      }

      expires = normalizeExpires(expires);

      if (filtersUpdatePeriod === settings.DEFAULT_FILTERS_UPDATE_PERIOD) {
        return lastCheckTime + expires <= Date.now();
      }

      return lastCheckTime + filtersUpdatePeriod <= Date.now();
    };

    for (let i = 0; i < filters.length; i += 1) {
      const filter = filters[i];
      const group = subscriptions.getGroup(filter.groupId);

      if (filter.installed && filter.enabled && group.enabled) {
        if (forceUpdate || needUpdate(filter)) {
          if (filter.customUrl) {
            customFilterIds.push(filter.filterId);
          } else {
            filterIds.push(filter.filterId);
          }
        }
      }
    }

    return {
      filterIds,
      customFilterIds
    };
  };
  /**
   * Loads filter versions from remote server
   *
   * @param filterIds Filter identifiers
   * @private
   */


  const loadFiltersMetadataFromBackend = async filterIds => {
    if (filterIds.length === 0) {
      return [];
    }

    try {
      const filterMetadataList = await subscriptions.getFiltersMetadata(filterIds);
      log/* log.debug */.c.debug('Retrieved response from server for {0} filters, result: {1} metadata', filterIds.length, filterMetadataList.length);
      return filterMetadataList;
    } catch (e) {
      const errorMessage = `Error retrieved response from server for filters ${filterIds}, cause: ${e.message}`;
      log/* log.error */.c.error(errorMessage);
      throw new Error(errorMessage);
    }
  };
  /**
   * Loads filter rules
   *
   * @param filterMetadata Filter metadata
   * @param forceRemote Force download filter rules from remote server
   * (if false try to download local copy of rules if it's possible)
   * @private
   */


  async function loadFilterRules(filterMetadata, forceRemote) {
    const filter = subscriptions.getFilter(filterMetadata.filterId);
    filter._isDownloading = true;
    listeners.notifyListeners(listeners.START_DOWNLOAD_FILTER, filter);
    let filterRules;

    try {
      filterRules = await backend.downloadFilterRules(filter.filterId, forceRemote, settings.isUseOptimizedFiltersEnabled());
    } catch (e) {
      log/* log.error */.c.error('Error retrieving response from the server for filter {0}, cause: {1}:', filter.filterId, e || '');
      delete filter._isDownloading;
      listeners.notifyListeners(listeners.ERROR_DOWNLOAD_FILTER, filter);
      return false;
    }

    log/* log.info */.c.info('Retrieved response from server for filter {0}, rules count: {1}', filter.filterId, filterRules.length);
    delete filter._isDownloading;
    filter.version = filterMetadata.version;
    filter.lastUpdateTime = filterMetadata.timeUpdated;
    filter.lastCheckTime = forceRemote ? Date.now() : filterMetadata.timeUpdated;
    filter.loaded = true;
    filter.expires = filterMetadata.expires; // notify listeners

    listeners.notifyListeners(listeners.SUCCESS_DOWNLOAD_FILTER, filter);
    listeners.notifyListeners(listeners.UPDATE_FILTER_RULES, filter, filterRules);
    return true;
  }
  /**
   * Loads filters (ony-by-one) from the remote server
   *
   * @param filterMetadataList List of filter metadata to load
   * @private
   */


  const loadFiltersFromBackend = async filterMetadataList => {
    const promises = filterMetadataList.map(async filterMetadata => {
      const result = await loadFilterRules(filterMetadata, true);

      if (result) {
        return filterMetadata.filterId;
      }

      throw new Error('An error occurred');
    });
    const filterIds = await Promise.all(promises);
    return filterIds;
  };
  /**
   * Update filters with custom urls
   *
   * @param customFilterIds
   */


  async function updateCustomFilters(customFilterIds) {
    if (customFilterIds.length === 0) {
      return [];
    }

    const promises = customFilterIds.map(async filterId => {
      const filter = subscriptions.getFilter(filterId);
      const updatedFilterId = await customFilters.updateCustomFilter(filter.customUrl, {});

      if (updatedFilterId) {
        return filter;
      }

      return null;
    });
    const filters = await Promise.all(promises);
    const updatedFilters = filters.filter(f => f);

    if (updatedFilters.length > 0) {
      const filterIdsString = updatedFilters.map(f => f.filterId).join(', ');
      log/* log.info */.c.info(`Updated custom filters with ids: ${filterIdsString}`);
    }

    return updatedFilters;
  }
  /**
   * Filters update options
   * @typedef {Object} UpdateProps
   * @property [boolean] forceUpdate - if should ignore update period
   * @property [boolean] ignoreVersion - if should ignore filter version, used on switch of optimized filters
   * @property [Filter[]] filters - array of filters to update
   */

  /**
   * Downloads and saves metadata from backend
   * @return {Promise<void>}
   */


  const updateMetadata = async () => {
    log/* log.info */.c.info('Downloading metadata from backend..');
    await subscriptions.reloadMetadataFromBackend();
    await subscriptions.reloadI18nMetadataFromBackend();
    log/* log.info */.c.info('Metadata updated from backend');
  };
  /**
   * Checks filters updates.
   *
   * @param [UpdateProps]
   */


  const checkAntiBannerFiltersUpdate = async ({
    forceUpdate,
    ignoreVersion,
    filters
  } = {}) => {
    // Don't update in background if request filter isn't running
    if (!forceUpdate && !antiBannerService.isRunning()) {
      return [];
    } // On force initiated on first run on by user's direct call


    if (forceUpdate && !filters) {
      await updateMetadata();
    }

    log/* log.info */.c.info('Start checking filters updates'); // Select filters for update

    const toUpdate = selectFilterIdsToUpdate(forceUpdate, filters);
    const filterIdsToUpdate = toUpdate.filterIds;
    const customFilterIdsToUpdate = toUpdate.customFilterIds;
    const totalToUpdate = filterIdsToUpdate.length + customFilterIdsToUpdate.length;

    if (totalToUpdate === 0) {
      log/* log.info */.c.info('There is no filters to update');
      return [];
    }

    log/* log.info */.c.info('Checking updates for {0} filters', totalToUpdate);
    /**
     * Loads filters with changed version
     * @param filterMetadataList
     */

    const loadFiltersFromBackendCallback = async filterMetadataList => {
      const filterIds = await loadFiltersFromBackend(filterMetadataList);
      const filters = filterIds.map(subscriptions.getFilter).filter(f => f);
      const customFilters = await updateCustomFilters(customFilterIdsToUpdate);
      return filters.concat(customFilters);
    };
    /**
     * Method is called after we have got server response
     * Now we check filters version and update filter if needed
     * @param filterMetadataList
     * @param forceUpdate
     */


    const selectFilterMetadataListToUpdate = (filterMetadataList, forceUpdate) => {
      const filterMetadataListToUpdate = [];

      for (let i = 0; i < filterMetadataList.length; i += 1) {
        const filterMetadata = filterMetadataList[i];
        const filter = subscriptions.getFilter(filterMetadata.filterId);

        if (filter && filterMetadata) {
          if (forceUpdate || filterMetadata.version && browserUtils.isGreaterVersion(filterMetadata.version, filter.version)) {
            log/* log.info */.c.info(`Updating filter ${filter.filterId} to version ${filterMetadata.version}`);
            filter.lastUpdateTime = Date.now();
            filterMetadataListToUpdate.push(filterMetadata);
          } else {
            // remember that this filter version was checked
            filter.lastCheckTime = Date.now();
          }
        }
      }

      return filterMetadataListToUpdate;
    }; // Retrieve current filters metadata for update


    const filterMetadataList = await loadFiltersMetadataFromBackend(filterIdsToUpdate);
    const filterMetadataListToUpdate = selectFilterMetadataListToUpdate(filterMetadataList, ignoreVersion);
    const loadedFilters = await loadFiltersFromBackendCallback(filterMetadataListToUpdate);
    return loadedFilters;
  }; // Scheduling job


  let scheduleUpdateTimeoutId;

  function scheduleUpdate() {
    const checkTimeout = 1000 * 60 * 30;

    if (scheduleUpdateTimeoutId) {
      clearTimeout(scheduleUpdateTimeoutId);
    } // don't update filters if filters update period is equal to 0


    if (filtersUpdatePeriod === 0) {
      return;
    }

    scheduleUpdateTimeoutId = setTimeout(async () => {
      try {
        await checkAntiBannerFiltersUpdate();
      } catch (ex) {
        log/* log.error */.c.error('Error update filters, cause {0}', ex);
      }

      scheduleUpdate();
    }, checkTimeout);
  }
  /**
   * Schedules filters update job
   *
   * @param isFirstRun App first run flag
   * @private
   */


  function scheduleFiltersUpdate(isFirstRun) {
    filtersUpdatePeriod = settings.getFiltersUpdatePeriod(); // First run delay

    if (isFirstRun) {
      setTimeout(checkAntiBannerFiltersUpdate, UPDATE_FILTERS_DELAY, {
        forceUpdate: isFirstRun
      });
    }

    scheduleUpdate();
  }

  return {
    checkAntiBannerFiltersUpdate,
    scheduleFiltersUpdate,
    loadFilterRules
  };
})();
;// CONCATENATED MODULE: ./Extension/src/background/filter/antibanner.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */














/**
 * Creating service that manages our filter rules.
 */

const antiBannerService = (() => {
  // Request filter contains all filter rules
  // This class does the actual filtering (checking URLs, constructing CSS/JS to inject, etc)
  let requestFilter = new RequestFilter(); // Service is not initialized yet

  let requestFilterInitTime = 0; // Application is running flag

  let applicationRunning = false; // Application initialized flag (Sets on first call of 'start' method)

  let applicationInitialized = false;
  /**
   * Delay on application updated event
   */

  const APP_UPDATED_NOTIFICATION_DELAY = 60 * 1000;
  const FILTERS_CHANGE_DEBOUNCE_PERIOD = 1000;
  const RELOAD_FILTERS_DEBOUNCE_PERIOD = 1000;
  /**
   * List of events which cause RequestFilter re-creation
   * @type {Array}
   */

  const UPDATE_REQUEST_FILTER_EVENTS = [listeners.UPDATE_FILTER_RULES, listeners.FILTER_ENABLE_DISABLE, listeners.FILTER_GROUP_ENABLE_DISABLE, listeners.ADD_RULES, listeners.REMOVE_RULE];

  const isUpdateRequestFilterEvent = el => UPDATE_REQUEST_FILTER_EVENTS.indexOf(el.event) >= 0;
  /**
   * List of events which cause saving filter rules to the rules storage
   * @type {Array}
   */


  const SAVE_FILTER_RULES_TO_STORAGE_EVENTS = [listeners.UPDATE_FILTER_RULES, listeners.ADD_RULES, listeners.REMOVE_RULE];

  const isSaveRulesToStorageEvent = function (el) {
    return SAVE_FILTER_RULES_TO_STORAGE_EVENTS.indexOf(el.event) >= 0;
  };

  let reloadedRules = false;
  /**
   * AntiBannerService initialize method. Process install, update or simple run.
   * @param options Constructor options
   */

  async function initialize(options) {
    /**
     * Waits and notifies listener with application updated event
     * @param runInfo
     */
    const notifyApplicationUpdated = function (runInfo) {
      setTimeout(() => {
        listeners.notifyListeners(listeners.APPLICATION_UPDATED, runInfo);
      }, APP_UPDATED_NOTIFICATION_DELAY);
    };
    /**
     * This method is called when filter subscriptions have been loaded from remote server.
     * It is used to recreate RequestFilter object.
     */


    const initRequestFilter = async function () {
      subscriptions.loadFiltersVersionAndStateInfo();
      subscriptions.loadGroupsStateInfo();
      await createRequestFilter();
      addFiltersChangeEventListener();
    };
    /**
     * Callback for subscriptions loaded event
     */


    const onSubscriptionLoaded = async function (runInfo) {
      // Subscribe to events which lead to update filters (e.g. switch to optimized and back to default)
      subscribeToFiltersChangeEvents();

      if (runInfo.isFirstRun) {
        // Add event listener for filters change
        addFiltersChangeEventListener(); // Run callback
        // Request filter will be initialized during install

        if (typeof options.onInstall === 'function') {
          await options.onInstall();
        }
      } else if (runInfo.isUpdate) {
        // Updating storage schema on extension update (if needed)
        await applicationUpdateService.onUpdate(runInfo);
        await initRequestFilter(); // Show updated version popup

        notifyApplicationUpdated(runInfo);
      } else {
        // Init RequestFilter object
        await initRequestFilter();
      } // Schedule filters update job


      filtersUpdate.scheduleFiltersUpdate(runInfo.isFirstRun);
    };
    /**
     * Init extension common info.
     */


    const runInfo = await applicationUpdateService.getRunInfo();
    await subscriptions.init();
    await onSubscriptionLoaded(runInfo);
  }
  /**
   * Initialize application (process install or update) . Create and start request filter
   * @param options
   */


  const start = async function (options) {
    if (applicationRunning === true) {
      return;
    }

    applicationRunning = true;

    if (!applicationInitialized) {
      await initialize(options);
      applicationInitialized = true;
      return;
    }

    await createRequestFilter();
  };
  /**
   * Request Filter info
   */


  const getRequestFilterInfo = function () {
    let rulesCount = 0;

    if (requestFilter) {
      rulesCount = requestFilter.getRulesCount();
    }

    return {
      rulesCount
    };
  };
  /**
   * Clear request filter
   */


  const stop = async function () {
    applicationRunning = false;
    requestFilter = new RequestFilter();
    await engine.startEngine([]);
    listeners.notifyListeners(listeners.REQUEST_FILTER_UPDATED, getRequestFilterInfo());
  };
  /**
   * Checks application has been initialized
   * @returns {boolean}
   */


  const isInitialized = function () {
    return applicationInitialized;
  };
  /**
   * Getter for request filter
   */


  const getRequestFilter = function () {
    return requestFilter;
  };
  /**
   * Gets filter by ID.
   * Throws exception if filter not found.
   *
   * @param filterId Filter identifier
   * @returns {*} Filter got from subscriptions.getFilter OR null for no filter found
   * @private
   */


  function getFilterById(filterId) {
    const filterMetadata = subscriptions.getFilter(filterId);

    if (!filterMetadata) {
      log/* log.info */.c.info(`Filter with id: ${filterId} not found`);
      return null;
    }

    return filterMetadata;
  }
  /**
   * Loads filter from storage (if in extension package) or from backend
   *
   * @param filterId Filter identifier
   * @param forceRemote Force download filter rules from backend
   */


  const addAntiBannerFilter = async (filterId, forceRemote = false) => {
    const filterMetadata = getFilterById(filterId);

    if (!filterMetadata) {
      return false;
    }

    if (filterMetadata.installed && !forceRemote) {
      return true;
    }

    const onFilterLoaded = success => {
      if (success) {
        filterMetadata.installed = true;
        listeners.notifyListeners(listeners.FILTER_ADD_REMOVE, filterMetadata);
      }

      return success;
    };

    if (filterMetadata.loaded && !forceRemote) {
      return onFilterLoaded(true);
    }

    if (filterMetadata.customUrl) {
      const {
        title,
        trusted,
        enabled
      } = filterMetadata;
      await customFilters.updateCustomFilter(filterMetadata.customUrl, {
        title,
        trusted,
        enabled
      });
      return onFilterLoaded(true);
    }

    const result = await filtersUpdate.loadFilterRules(filterMetadata, forceRemote);
    return onFilterLoaded(result);
  };
  /**
   * Reloads filters from backend
   *
   * @private
   */


  async function reloadAntiBannerFilters() {
    await filtersUpdate.checkAntiBannerFiltersUpdate({
      forceUpdate: true,
      ignoreVersion: true
    });
  }
  /**
   * Called when filters were loaded from the storage
   *
   * @param rulesFilterMap Map for populating rules (filterId -> rules collection)
   */


  async function onFiltersLoadedFromStorage(rulesFilterMap) {
    const start = new Date().getTime();
    log/* log.info */.c.info('Starting request filter initialization..');
    const newRequestFilter = new RequestFilter();

    if (requestFilterInitTime === 0) {
      // Setting the time of request filter very first initialization
      requestFilterInitTime = new Date().getTime();
      listeners.notifyListeners(listeners.APPLICATION_INITIALIZED);
    }
    /**
     * Checks by filter id if filter is enabled and has rules
     * @param rulesFilterMap
     * @param filterId
     * @return {boolean}
     */


    const hasFilterRules = (rulesFilterMap, filterId) => {
      const enabledFilterIds = Object.keys(rulesFilterMap);
      const foundFilterId = enabledFilterIds.find(enabledFilterId => enabledFilterId === filterId);

      if (foundFilterId) {
        const rules = enabledFilterIds[foundFilterId];

        if (rules && rules.length > 0) {
          return true;
        }
      }

      return false;
    };
    /**
     * Checks rulesFilterMap is empty (no one of filters are enabled)
     * @param rulesFilterMap
     * @returns {boolean}
     */


    function isEmptyRulesFilterMap(rulesFilterMap) {
      const enabledFilterIds = Object.keys(rulesFilterMap);

      if (enabledFilterIds.length === 0) {
        return true;
      } // User filter is enabled by default, but it may not contain any rules


      return !hasFilterRules(utils.filters.USER_FILTER_ID);
    }
    /**
     * STEP 3: Called when request filter has been filled with rules.
     * This is the last step of request filter initialization.
     */


    const requestFilterInitialized = function () {
      // Request filter is ready
      requestFilter = newRequestFilter;
      listeners.notifyListeners(listeners.REQUEST_FILTER_UPDATED, getRequestFilterInfo());
      log/* log.info */.c.info('Finished request filter initialization in {0} ms. Rules count: {1}', new Date().getTime() - start, newRequestFilter.getRulesCount());
      /**
       * If no one of filters is enabled, don't reload rules,
       * except when there are enabled stealth mode rules
       */

      if (isEmptyRulesFilterMap(rulesFilterMap) && !stealthService.hasFilterRules()) {
        return;
      }

      if (newRequestFilter.getRulesCount() === 0 && !reloadedRules) {
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/205
        log/* log.info */.c.info('No rules have been found - checking filter updates');
        reloadAntiBannerFilters();
        reloadedRules = true;
      } else if (newRequestFilter.getRulesCount() > 0 && reloadedRules) {
        log/* log.info */.c.info('Filters reloaded, deleting reloadRules flag');
        reloadedRules = false;
      }
    };
    /**
     * Fills engine with rules
     */


    const startTSUrlFilterEngine = async () => {
      const lists = [];
      let userFilterList; // eslint-disable-next-line guard-for-in,no-restricted-syntax

      for (let filterId in rulesFilterMap) {
        // To number
        filterId = Number(filterId);
        const isTrustedFilter = subscriptions.isTrustedFilter(filterId);
        const rulesTexts = rulesFilterMap[filterId].join('\n');
        const filterList = new es/* StringRuleList */.eq(filterId, rulesTexts, false, !isTrustedFilter, !isTrustedFilter);

        if (filterId === utils.filters.USER_FILTER_ID) {
          userFilterList = filterList;
        } else {
          lists.push(filterList);
        }
      } // We push user filter list in the end in order to make possible script rules to work
      // AG-9443


      if (userFilterList) {
        lists.push(userFilterList);
      } // append stealth mode rules


      const stealthModeList = stealthService.getStealthModeRuleList();
      lists.push(stealthModeList);
      await engine.startEngine(lists);
      requestFilterInitialized();
    };

    await startTSUrlFilterEngine();
  }
  /**
   * Create new request filter and add distinct rules from the storage.
   *
   * @private
   */


  async function createRequestFilter() {
    if (applicationRunning === false) {
      return;
    }

    const start = new Date().getTime();
    log/* log.info */.c.info('Starting loading filter rules from the storage'); // Prepare map for filter rules
    // Map key is filter ID
    // Map value is array with filter rules

    const rulesFilterMap = Object.create(null);
    /**
     * STEP 2: Called when all filter rules have been loaded from storage
     */

    const loadAllFilterRulesDone = async () => {
      log/* log.info */.c.info('Finished loading filter rules from the storage in {0} ms', new Date().getTime() - start);
      await onFiltersLoadedFromStorage(rulesFilterMap);
    };
    /**
     * Loads filter rules from storage
     *
     * @param filterId Filter identifier
     * @param rulesFilterMap Map for loading rules
     * @returns {*} Deferred object
     */


    const loadFilterRulesFromStorage = async (filterId, rulesFilterMap) => {
      let rulesText = await rulesStorage.read(filterId);

      if (rulesText) {
        if (Number(filterId) === utils.filters.USER_FILTER_ID) {
          rulesText = userrules.convertRules(rulesText);
        }

        rulesFilterMap[filterId] = rulesText;
      }
    };
    /**
     * STEP 1: load all filters from the storage.
     */


    const loadFilterRules = async function () {
      const promises = [];
      const filters = subscriptions.getFilters();

      for (let i = 0; i < filters.length; i += 1) {
        const filter = filters[i];
        const group = subscriptions.getGroup(filter.groupId);

        if (filter.enabled && group.enabled) {
          promises.push(loadFilterRulesFromStorage(filter.filterId, rulesFilterMap));
        }
      }

      if (settings.getUserFilterEnabled()) {
        // get user filter rules from storage
        promises.push(loadFilterRulesFromStorage(utils.filters.USER_FILTER_ID, rulesFilterMap));
      } // Load all filters and then recreate request filter


      await Promise.all(promises);
      await loadAllFilterRulesDone();
    };

    loadFilterRules();
  }
  /**
   * Adds event listener for filters changes.
   * If filter is somehow changed this method checks if we should save changes to the storage
   * and if we should recreate RequestFilter.
   *
   * @private
   */


  function addFiltersChangeEventListener() {
    let filterEventsHistory = [];
    let onFilterChangeTimeout = null;

    const processEventsHistory = async function () {
      const filterEvents = filterEventsHistory.slice(0);
      filterEventsHistory = [];
      onFilterChangeTimeout = null;
      const needCreateRequestFilter = filterEvents.some(isUpdateRequestFilterEvent); // Split by filterId

      const eventsByFilter = Object.create(null);

      for (let i = 0; i < filterEvents.length; i += 1) {
        const filterEvent = filterEvents[i]; // don't add group events

        if (!filterEvent.filter) {
          continue;
        }

        if (!(filterEvent.filter.filterId in eventsByFilter)) {
          eventsByFilter[filterEvent.filter.filterId] = [];
        }

        eventsByFilter[filterEvent.filter.filterId].push(filterEvent);
      }

      const promises = []; // eslint-disable-next-line no-restricted-syntax

      for (const filterId of Object.keys(eventsByFilter)) {
        const needSaveRulesToStorage = eventsByFilter[filterId].some(isSaveRulesToStorageEvent);

        if (!needSaveRulesToStorage) {
          continue;
        } // eslint-disable-next-line no-use-before-define


        const promise = processSaveFilterRulesToStorageEvents(filterId, eventsByFilter[filterId]);
        promises.push(promise);
      }

      if (needCreateRequestFilter) {
        // Rules will be added to request filter lazy,
        // listeners will be notified about REQUEST_FILTER_UPDATED later
        await Promise.all(promises);
        await createRequestFilter();
      } else {
        // Rules are already in request filter, notify listeners
        listeners.notifyListeners(listeners.REQUEST_FILTER_UPDATED, getRequestFilterInfo());
      }
    };

    const processFilterEvent = function (event, filter, rules) {
      filterEventsHistory.push({
        event,
        filter,
        rules
      });

      if (onFilterChangeTimeout !== null) {
        clearTimeout(onFilterChangeTimeout);
      }

      onFilterChangeTimeout = setTimeout(processEventsHistory, FILTERS_CHANGE_DEBOUNCE_PERIOD);
    };

    const processGroupEvent = function (event, group) {
      filterEventsHistory.push({
        event,
        group
      });

      if (onFilterChangeTimeout !== null) {
        clearTimeout(onFilterChangeTimeout);
      }

      onFilterChangeTimeout = setTimeout(processEventsHistory, FILTERS_CHANGE_DEBOUNCE_PERIOD);
    };

    listeners.addListener((event, filter, rules) => {
      switch (event) {
        case listeners.ADD_RULES:
        case listeners.REMOVE_RULE:
        case listeners.UPDATE_FILTER_RULES:
        case listeners.FILTER_ENABLE_DISABLE:
          processFilterEvent(event, filter, rules);
          break;

        default:
          break;
      }
    });
    listeners.addListener((event, group) => {
      switch (event) {
        case listeners.FILTER_GROUP_ENABLE_DISABLE:
          processGroupEvent(event, group);
          break;

        default:
          break;
      }
    });
  }
  /**
   * Saves updated filter rules to the storage.
   *
   * @param filterId Filter id
   * @param events Events (what has changed?)
   * @private
   */


  async function processSaveFilterRulesToStorageEvents(filterId, events) {
    let loadedRulesText = await rulesStorage.read(filterId);

    for (let i = 0; i < events.length; i += 1) {
      if (!loadedRulesText) {
        loadedRulesText = [];
      }

      const event = events[i];
      const eventType = event.event;
      const eventRules = event.rules; // eslint-disable-next-line default-case

      switch (eventType) {
        case listeners.ADD_RULES:
          // ditch empty first editor line while adding rule
          // AG-10727
          loadedRulesText = loadedRulesText.length === 1 && loadedRulesText[0] === '' ? eventRules : loadedRulesText.concat(eventRules);
          log/* log.debug */.c.debug('Add {0} rules to filter {1}', eventRules.length, filterId);
          break;

        case listeners.REMOVE_RULE:
          {
            const actionRule = eventRules[0];
            utils.collections.removeAll(loadedRulesText, actionRule);
            log/* log.debug */.c.debug('Remove {0} rule from filter {1}', actionRule, filterId);
            break;
          }

        case listeners.UPDATE_FILTER_RULES:
          loadedRulesText = eventRules;
          log/* log.debug */.c.debug('Update filter {0} rules count to {1}', filterId, eventRules.length);
          break;
      }
    }

    let rulesTextToSave = loadedRulesText;

    if (Number(filterId) !== utils.filters.USER_FILTER_ID) {
      log/* log.debug */.c.debug('Converting {0} rules for filter {1}', loadedRulesText.length, filterId);
      rulesTextToSave = es/* RuleConverter.convertRules */.cR.convertRules(loadedRulesText.join('\n')).split('\n');
    }

    log/* log.debug */.c.debug('Saving {0} rules to filter {1}', rulesTextToSave.length, filterId);
    await rulesStorage.write(filterId, rulesTextToSave); // notify that user rules were saved, to update saving button on options page

    if (Number(filterId) === utils.filters.USER_FILTER_ID) {
      listeners.notifyListeners(listeners.USER_FILTER_UPDATED);
    }
  }
  /**
   * Subscribe to events which lead to filters update.
   * @private
   */


  function subscribeToFiltersChangeEvents() {
    // on USE_OPTIMIZED_FILTERS setting change we need to reload filters
    const onUsedOptimizedFiltersChange = utils.concurrent.debounce(reloadAntiBannerFilters, RELOAD_FILTERS_DEBOUNCE_PERIOD);
    settings.onUpdated.addListener(async setting => {
      switch (setting) {
        case settings.USE_OPTIMIZED_FILTERS:
          onUsedOptimizedFiltersChange();
          break;

        case settings.FILTERS_UPDATE_PERIOD:
          filtersUpdate.scheduleFiltersUpdate();
          break;

        case settings.USER_FILTER_ENABLED:
          await createRequestFilter();
          break;

        default:
          break;
      }
    });
  }
  /**
   * Get request filter initialization time
   * @returns {number}
   */


  const getRequestFilterInitTime = function () {
    return requestFilterInitTime;
  };
  /**
   * Is Application running
   */


  const isRunning = () => applicationRunning;

  return {
    start,
    stop,
    isInitialized,
    isRunning,
    addAntiBannerFilter,
    getRequestFilter,
    getRequestFilterInitTime,
    getRequestFilterInfo
  };
})();
;// CONCATENATED MODULE: ./Extension/src/background/application.js


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */










/**
 * AdGuard application class
 */

const application = (() => {
  /**
   * Timeout for recently updated filters and again enabled filters - 5 minutes
   */
  const ENABLED_FILTERS_SKIP_TIMEOUT = 5 * 60 * 1000;

  const start = async options => {
    await antiBannerService.start(options);
  };

  const stop = async () => {
    await antiBannerService.stop();
  };
  /**
   * Checks application has been initialized
   * @returns {boolean}
   */


  const isInitialized = () => antiBannerService.isInitialized();
  /**
   * Offer filters on extension install, select default filters and filters by locale and country
   */


  const offerFilters = () => {
    // These filters are enabled by default
    const filterIds = [utils.filters.ENGLISH_FILTER_ID, utils.filters.SEARCH_AND_SELF_PROMO_FILTER_ID];

    if (prefs.mobile) {
      filterIds.push(utils.filters.MOBILE_ADS_FILTER_ID);
    }

    const langSuitableFilters = subscriptions.getLangSuitableFilters();
    filterIds.push(...langSuitableFilters);
    return filterIds;
  };
  /**
   * List of enabled filters.
   * User filter and allowlist filter are always enabled so they are excluded.
   *
   * @returns {Array} List of enabled filters
   */


  const getEnabledFilters = () => subscriptions.getFilters().filter(f => f.installed && f.enabled);

  const getEnabledFiltersFromEnabledGroups = () => {
    const filters = subscriptions.getFilters();
    const enabledGroupsIds = subscriptions.getGroups().filter(g => g.enabled).map(g => g.groupId);
    return filters.filter(f => f.enabled && enabledGroupsIds.includes(f.groupId));
  };
  /**
   * Checks if specified filter is enabled
   *
   * @param filterId Filter identifier
   * @returns {*} true if enabled
   */


  const isFilterEnabled = function (filterId) {
    const filter = subscriptions.getFilter(filterId);
    return filter && filter.enabled;
  };
  /**
   * Checks if specified filter is installed (downloaded)
   *
   * @param filterId Filter id
   * @returns {*} true if installed
   */


  const isFilterInstalled = function (filterId) {
    const filter = subscriptions.getFilter(filterId);
    return filter && filter.installed;
  };
  /**
   * Force checks updates for filters if specified or all filters
   *
   * @param {Object[]} [filters] optional list of filters
   */


  const checkFiltersUpdates = async filters => {
    if (filters) {
      // Skip recently downloaded filters
      const outdatedFilters = filters.filter(f => (f.lastCheckTime ? Date.now() - f.lastCheckTime > ENABLED_FILTERS_SKIP_TIMEOUT : true // but always check for updates for custom filters
      ) || f.groupId === constants/* ANTIBANNER_GROUPS_ID.CUSTOM_FILTERS_GROUP_ID */.CI.CUSTOM_FILTERS_GROUP_ID);

      if (outdatedFilters.length > 0) {
        try {
          const filters = await filtersUpdate.checkAntiBannerFiltersUpdate({
            forceUpdate: true,
            filters: outdatedFilters
          });
          return filters;
        } catch (e) {
          log/* log.error */.c.error(e.message);
          throw e;
        }
      } else {
        return [];
      }
    } else {
      try {
        const filters = await filtersUpdate.checkAntiBannerFiltersUpdate({
          forceUpdate: true
        });
        return filters;
      } catch (e) {
        log/* log.error */.c.error(e.message);
        throw e;
      }
    }
  };
  /**
   * Enable group
   * @param {number} groupId filter group identifier
   */


  const enableGroup = function (groupId) {
    const group = subscriptions.getGroup(groupId);

    if (!group || group.enabled) {
      return;
    }

    group.enabled = true;
    listeners.notifyListeners(listeners.FILTER_GROUP_ENABLE_DISABLE, group);
  };
  /**
   * Disable group
   * @param {number} groupId filter group identifier
   * @param {boolean} drop
   */


  const disableGroup = (groupId, drop) => {
    const group = subscriptions.getGroup(groupId);

    if (!group || !group.enabled) {
      return;
    }

    group.enabled = false;

    if (drop) {
      delete group.enabled;
    }

    listeners.notifyListeners(listeners.FILTER_GROUP_ENABLE_DISABLE, group);
  };
  /**
   * Enable filter
   *
   * @param {Number} filterId Filter identifier
   * @param {{forceGroupEnable: boolean}} [options]
   * @returns {boolean} true if filter was enabled successfully
   */


  const enableFilter = (filterId, options) => {
    const filter = subscriptions.getFilter(filterId);

    if (!filter || filter.enabled || !filter.installed) {
      return false;
    }

    filter.enabled = true;
    /**
     * we enable group if it was never enabled or disabled early
     */

    const {
      groupId
    } = filter;
    const forceGroupEnable = options && options.forceGroupEnable;

    if (!subscriptions.groupHasEnabledStatus(groupId) || forceGroupEnable) {
      enableGroup(groupId);
    }

    listeners.notifyListeners(listeners.FILTER_ENABLE_DISABLE, filter);
    return true;
  };
  /**
   * Successively add filters from filterIds and then enable successfully added filters
   * @param filterIds Filter identifiers
   * @param {{forceGroupEnable: boolean, forceRemote: boolean }} [options]
   */


  const addAndEnableFilters = async (filterIds, options) => {
    const enabledFilters = [];

    if (!filterIds || filterIds.length === 0) {
      return enabledFilters;
    }

    filterIds = utils.collections.removeDuplicates(filterIds.slice(0));

    for (let i = 0; i < filterIds.length; i += 1) {
      const filterId = filterIds[i]; // eslint-disable-next-line no-await-in-loop

      const success = await antiBannerService.addAntiBannerFilter(filterId, options && options.forceRemote);

      if (success) {
        const changed = enableFilter(filterId, options);

        if (changed) {
          const filter = subscriptions.getFilter(filterId);
          enabledFilters.push(filter);
        }
      }
    }

    return enabledFilters;
  };
  /**
   * Disables filters by id
   *
   * @param {Array.<Number>} filterIds Filter identifiers
   * @returns {boolean} true if filter was disabled successfully
   */


  const disableFilters = function (filterIds) {
    // Copy array to prevent parameter mutation
    filterIds = utils.collections.removeDuplicates(filterIds.slice(0));

    for (let i = 0; i < filterIds.length; i += 1) {
      const filterId = filterIds[i];
      const filter = subscriptions.getFilter(filterId);

      if (!filter || !filter.enabled || !filter.installed) {
        continue;
      }

      filter.enabled = false;
      listeners.notifyListeners(listeners.FILTER_ENABLE_DISABLE, filter);
    }
  };
  /**
   * Uninstalls filters
   *
   * @param {Array.<Number>} filterIds Filter identifiers
   * @returns {boolean} true if filter was removed successfully
   */


  const uninstallFilters = function (filterIds) {
    // Copy array to prevent parameter mutation
    filterIds = utils.collections.removeDuplicates(filterIds.slice(0));

    for (let i = 0; i < filterIds.length; i += 1) {
      const filterId = filterIds[i];
      const filter = subscriptions.getFilter(filterId);

      if (!filter || !filter.installed) {
        continue;
      }

      log/* log.debug */.c.debug('Uninstall filter {0}', filter.filterId);
      filter.enabled = false;
      filter.installed = false;
      listeners.notifyListeners(listeners.FILTER_ENABLE_DISABLE, filter);
      listeners.notifyListeners(listeners.FILTER_ADD_REMOVE, filter);
    }
  };
  /**
   * Removes filter
   *
   * @param {Number} filterId Filter identifier
   */


  const removeFilter = function (filterId) {
    const filter = subscriptions.getFilter(filterId);

    if (!filter || filter.removed) {
      return;
    }

    if (!filter.customUrl) {
      log/* log.error */.c.error('Filter {0} is not custom and could not be removed', filter.filterId);
      return;
    }

    log/* log.debug */.c.debug('Remove filter {0}', filter.filterId);
    filter.enabled = false;
    filter.installed = false;
    filter.removed = true;
    listeners.notifyListeners(listeners.FILTER_ENABLE_DISABLE, filter);
    listeners.notifyListeners(listeners.FILTER_ADD_REMOVE, filter);
  };
  /**
   * Loads filter rules from url, then tries to parse header to filter metadata
   * and adds filter object to subscriptions from it.
   * These custom filters will have special attribute customUrl, from there it could be downloaded and updated.
   *
   * @param url custom url, there rules are
   * @param options object containing title of custom filter
   */


  const loadCustomFilter = async function (url, options) {
    log/* log.info */.c.info('Downloading custom filter from {0}', url);

    if (!url) {
      throw new Error('No url provided');
    }

    const filterId = await customFilters.updateCustomFilter(url, options);

    if (filterId) {
      log/* log.info */.c.info('Custom filter downloaded');
      const filter = subscriptions.getFilter(filterId); // In case filter is loaded again and was removed before

      delete filter.removed;
      return filter;
    }

    throw new Error('No filter downloaded');
  };

  const loadCustomFilterInfo = async (url, options) => {
    log/* log.info */.c.info(`Downloading custom filter info from ${url}`);

    if (!url) {
      throw new Error('No url provided');
    }

    const res = await customFilters.getCustomFilterInfo(url, options);

    if (res !== null && res !== void 0 && res.filter) {
      log/* log.info */.c.info('Custom filter data downloaded');
      return res;
    }

    if (res !== null && res !== void 0 && res.errorAlreadyExists) {
      log/* log.error */.c.error('Custom filter already exists');
      return {
        error: translator/* translator.getMessage */.O.getMessage('options_antibanner_custom_filter_already_exists')
      };
    }

    if (res !== null && res !== void 0 && res.error) {
      log/* log.error */.c.error('Error occurred', res.error);
      return res;
    }

    throw new Error('Error occurred during custom filter download');
  };

  return {
    start,
    stop,
    isInitialized,
    offerFilters,
    getEnabledFilters,
    isFilterEnabled,
    isFilterInstalled,
    checkFiltersUpdates,
    addAndEnableFilters,
    disableFilters,
    uninstallFilters,
    removeFilter,
    enableGroup,
    disableGroup,
    loadCustomFilter,
    loadCustomFilterInfo,
    getEnabledFiltersFromEnabledGroups
  };
})();
;// CONCATENATED MODULE: ./Extension/src/background/utils/filtering-log-window-state.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Object that manages filtering log size and position.
 * @constructor
 */
const filteringLogWindowState = function () {
  const FILTERING_LOG_WINDOW_STATE = 'filtering-log-window-state';

  const setState = windowState => {
    if (!windowState) {
      return;
    }

    localStorage.setItem(FILTERING_LOG_WINDOW_STATE, JSON.stringify(windowState));
  };

  const getState = () => {
    const windowState = localStorage.getItem(FILTERING_LOG_WINDOW_STATE);
    return JSON.parse(windowState);
  };

  return {
    setState,
    getState
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/ui-service.js


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */

/* eslint-disable max-len */




















/**
 * UI service
 */

const uiService = function () {
  // styles for alert popup and update info popup
  // should be used inside iframe
  const alertStylesUrl = backgroundPage.getURL('/assets/css/alert-popup.css'); // styles for alert popup container
  // should be injected into web page to set the alert position on page properly

  const alertContainerStylesUrl = backgroundPage.getURL('/assets/css/alert-container.css'); // style for the update info popup iframe
  // should be injected into web page to set the popup position on page properly

  const updateIframeStyleUrl = backgroundPage.getURL('/assets/css/update-iframe.css');
  const browserActionTitle = translator/* translator.getMessage */.O.getMessage('name');
  const contextMenuCallbackMappings = {
    'context_block_site_ads': function () {
      openAssistant();
    },
    'context_block_site_element': function () {
      openAssistant(true);
    },
    'context_security_report': async function () {
      const tab = await tabsApi.getActive();

      if (tab) {
        openSiteReportTab(tab.url);
      }
    },
    'context_complaint_website': async function () {
      const tab = await tabsApi.getActive();

      if (tab) {
        openAbuseTab(tab.url, 'context_menu');
      }
    },
    'context_site_filtering_on': async function () {
      const tab = await tabsApi.getActive();

      if (tab) {
        unAllowlistTab(tab);
      }
    },
    'context_site_filtering_off': async function () {
      const tab = await tabsApi.getActive();

      if (tab) {
        allowlistTab(tab);
      }
    },
    'context_enable_protection': function () {
      changeApplicationFilteringDisabled(false);
    },
    'context_disable_protection': function () {
      changeApplicationFilteringDisabled(true);
    },
    'context_open_settings': function () {
      openSettingsTab();
    },
    'context_open_log': function () {
      openFilteringLog();
    },
    'context_update_antibanner_filters': function () {
      checkFiltersUpdates();
    }
  };

  const extensionStoreLink = function () {
    let browser = 'chrome';

    if (browserUtils.isOperaBrowser()) {
      browser = 'opera';
    } else if (browserUtils.isFirefoxBrowser()) {
      browser = 'firefox';
    } else if (browserUtils.isEdgeChromiumBrowser()) {
      browser = 'edge';
    }

    const action = `${browser}_store`;
    return `https://link.adtidy.org/forward.html?action=${action}&from=options_screen&app=browser_extension`;
  }();

  const THANKYOU_PAGE_URL = 'https://link.adtidy.org/forward.html?action=thank_you_page&from=background&app=browser_extension';
  /**
   * Update icon for tab
   * @param tab Tab
   * @param options Options for icon or badge values
   */

  async function updateTabIcon(tab, options) {
    let icon;
    let badge;
    let badgeColor = '#555';

    if (tab.tabId === BACKGROUND_TAB_ID) {
      return;
    }

    try {
      if (options) {
        icon = options.icon;
        badge = options.badge;
      } else {
        let blocked;
        let disabled;
        const tabInfo = frames_frames.getFrameInfo(tab);
        disabled = tabInfo.applicationFilteringDisabled;
        disabled = disabled || tabInfo.documentAllowlisted;

        if (!disabled && settings.showPageStatistic()) {
          blocked = tabInfo.totalBlockedTab.toString();
        } else {
          blocked = '0';
        }

        if (disabled) {
          icon = prefs.ICONS.ICON_GRAY;
        } else {
          icon = prefs.ICONS.ICON_GREEN;
        }

        badge = utils.workaround.getBlockedCountText(blocked); // If there's an active notification, indicate it on the badge

        const notification = notifications.getCurrentNotification();

        if (notification) {
          badge = notification.badgeText || badge;
          badgeColor = notification.badgeBgColor || badgeColor;
          const hasSpecialIcons = !!notification.icons;

          if (hasSpecialIcons) {
            if (disabled) {
              icon = notification.icons.ICON_GRAY;
            } else {
              icon = notification.icons.ICON_GREEN;
            }
          }
        }
      }

      await backgroundPage.browserAction.setBrowserAction(tab, icon, badge, badgeColor, browserActionTitle);
    } catch (ex) {
      log/* log.error */.c.error('Error while updating icon for tab {0}: {1}', tab.tabId, new Error(ex));
    }
  } // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1915


  let lastCallArgs = null;
  let isWorking = false;
  const updateTabIconAsync = utils.concurrent.debounce(async (...args) => {
    if (isWorking) {
      lastCallArgs = args;
      return;
    }

    isWorking = true;
    await updateTabIcon(...args);

    if (lastCallArgs) {
      args = lastCallArgs;
      lastCallArgs = null;
      await updateTabIcon(...args);
    }

    isWorking = false;
  }, 100);
  /**
   * Update extension browser action popup window
   * @param tab - active tab
   */

  function updatePopupStats(tab) {
    const tabInfo = frames_frames.getFrameInfo(tab);

    if (!tabInfo) {
      return;
    }

    common_script/* runtimeImpl.sendMessage */.VX.sendMessage({
      type: 'updateTotalBlocked',
      tabInfo
    }).catch(() => {// throws errors if popup is closed, ignore them
    });
  }

  const updatePopupStatsAsync = utils.concurrent.debounce(tab => {
    updatePopupStats(tab);
  }, 250);
  /**
   * Creates context menu item
   * @param title Title id
   * @param options Create options
   */

  function addMenu(title, options) {
    const createProperties = {
      contexts: ['all'],
      title: translator/* translator.getMessage */.O.getMessage(title)
    };

    if (options) {
      if (options.id) {
        createProperties.id = options.id;
      }

      if (options.parentId) {
        createProperties.parentId = options.parentId;
      }

      if (options.disabled) {
        createProperties.enabled = false;
      }

      if (options.messageArgs) {
        createProperties.title = translator/* translator.getMessage */.O.getMessage(title, options.messageArgs);
      }

      if (options.contexts) {
        createProperties.contexts = options.contexts;
      }

      if ('checkable' in options) {
        createProperties.checkable = options.checkable;
      }

      if ('checked' in options) {
        createProperties.checked = options.checked;
      }
    }

    let callback;

    if (options && options.action) {
      callback = contextMenuCallbackMappings[options.action];
    } else {
      callback = contextMenuCallbackMappings[title];
    }

    if (typeof callback === 'function') {
      createProperties.onclick = callback;
    }

    backgroundPage.contextMenus.create(createProperties);
  }

  function customizeContextMenu(tab) {
    function addSeparator() {
      backgroundPage.contextMenus.create({
        type: 'separator',
        contexts: ['all']
      });
    }

    const tabInfo = frames_frames.getFrameInfo(tab);

    if (tabInfo.applicationFilteringDisabled) {
      addMenu('context_site_protection_disabled');
      addSeparator();
      addMenu('context_open_log');
      addMenu('context_open_settings');
      addMenu('context_enable_protection');
    } else if (tabInfo.urlFilteringDisabled) {
      addMenu('context_site_filtering_disabled');
      addSeparator();
      addMenu('context_open_log');
      addMenu('context_open_settings');
      addMenu('context_update_antibanner_filters');
    } else {
      if (tabInfo.documentAllowlisted && !tabInfo.userAllowlisted) {
        addMenu('context_site_exception');
      } else if (tabInfo.canAddRemoveRule) {
        if (tabInfo.documentAllowlisted) {
          addMenu('context_site_filtering_on');
        } else {
          addMenu('context_site_filtering_off');
        }
      }

      addSeparator();

      if (!tabInfo.documentAllowlisted) {
        addMenu('context_block_site_ads');
        addMenu('context_block_site_element', {
          contexts: ['image', 'video', 'audio']
        });
      }

      addMenu('context_security_report');
      addMenu('context_complaint_website');
      addSeparator();
      addMenu('context_update_antibanner_filters');
      addSeparator();
      addMenu('context_open_settings');
      addMenu('context_open_log');
      addMenu('context_disable_protection');
    }
  }

  function customizeMobileContextMenu(tab) {
    const tabInfo = frames_frames.getFrameInfo(tab);

    if (tabInfo.applicationFilteringDisabled) {
      addMenu('popup_site_protection_disabled_android', {
        action: 'context_enable_protection',
        checked: true,
        checkable: true
      });
      addMenu('popup_open_log_android', {
        action: 'context_open_log'
      });
      addMenu('popup_open_settings', {
        action: 'context_open_settings'
      });
    } else if (tabInfo.urlFilteringDisabled) {
      addMenu('context_site_filtering_disabled');
      addMenu('popup_open_log_android', {
        action: 'context_open_log'
      });
      addMenu('popup_open_settings', {
        action: 'context_open_settings'
      });
      addMenu('context_update_antibanner_filters');
    } else {
      addMenu('popup_site_protection_disabled_android', {
        action: 'context_disable_protection',
        checked: false,
        checkable: true
      });

      if (tabInfo.documentAllowlisted && !tabInfo.userAllowlisted) {
        addMenu('popup_in_allowlist_android');
      } else if (tabInfo.canAddRemoveRule) {
        if (tabInfo.documentAllowlisted) {
          addMenu('popup_site_filtering_state', {
            action: 'context_site_filtering_on',
            checkable: true,
            checked: false
          });
        } else {
          addMenu('popup_site_filtering_state', {
            action: 'context_site_filtering_off',
            checkable: true,
            checked: true
          });
        }
      }

      if (!tabInfo.documentAllowlisted) {
        addMenu('popup_block_site_ads_android', {
          action: 'context_block_site_ads'
        });
      }

      addMenu('popup_open_log_android', {
        action: 'context_open_log'
      });
      addMenu('popup_security_report_android', {
        action: 'context_security_report'
      });
      addMenu('popup_open_settings', {
        action: 'context_open_settings'
      });
      addMenu('context_update_antibanner_filters');
    }
  }
  /**
   * Update context menu for tab
   * @param tab Tab
   */


  function updateTabContextMenu(tab) {
    // Isn't supported by Android WebExt
    if (!backgroundPage.contextMenus) {
      return;
    }

    backgroundPage.contextMenus.removeAll();

    if (settings.showContextMenu()) {
      if (prefs.mobile) {
        customizeMobileContextMenu(tab);
      } else {
        customizeContextMenu(tab);
      }

      if (typeof backgroundPage.contextMenus.render === 'function') {
        // In some case we need to manually render context menu
        backgroundPage.contextMenus.render();
      }
    }
  }

  function closeAllPages() {
    tabsApi.forEach(tab => {
      if (tab.url.indexOf(backgroundPage.getURL('')) >= 0) {
        tabsApi.remove(tab.tabId);
      }
    });
  }

  function getPageUrl(page) {
    return backgroundPage.getURL(`pages/${page}`);
  }

  const isAdguardTab = tab => {
    const {
      url
    } = tab;
    let parsedUrl;

    try {
      parsedUrl = new URL(url);
    } catch (e) {
      log/* log.error */.c.error(e);
      return false;
    }

    const schemeUrl = backgroundPage.app.getUrlScheme();
    return parsedUrl.protocol.indexOf(schemeUrl) > -1;
  };

  const showAlertMessagePopup = async (title, text, alertStyles) => {
    const tab = await tabsApi.getActive();
    const alertContainerStylesResponse = await fetch(alertContainerStylesUrl);
    const alertContainerStyles = await alertContainerStylesResponse.text();

    if (tab) {
      tabsApi.sendMessage(tab.tabId, {
        type: 'show-alert-popup',
        isAdguardTab: isAdguardTab(tab),
        title,
        text,
        alertStyles,
        alertContainerStyles
      });
    }
  };
  /**
   * Depending on version numbers select proper message for description
   *
   * @param currentVersion
   * @param previousVersion
   */


  function getUpdateDescriptionMessage(currentVersion, previousVersion) {
    if (browserUtils.getMajorVersionNumber(currentVersion) > browserUtils.getMajorVersionNumber(previousVersion) || browserUtils.getMinorVersionNumber(currentVersion) > browserUtils.getMinorVersionNumber(previousVersion)) {
      return translator/* translator.getMessage */.O.getMessage('options_popup_version_update_description_major');
    }

    return translator/* translator.getMessage */.O.getMessage('options_popup_version_update_description_minor');
  }
  /**
   * Shows application updated popup
   *
   * @param currentVersion
   * @param previousVersion
   * @param alertStyles
   * @param updateIframeStyles
   */


  const showApplicationUpdatedPopup = async (currentVersion, previousVersion, alertStyles, updateIframeStyles) => {
    const promoNotification = notifications.getCurrentNotification();

    if (!promoNotification && browserUtils.getMajorVersionNumber(currentVersion) === browserUtils.getMajorVersionNumber(previousVersion) && browserUtils.getMinorVersionNumber(currentVersion) === browserUtils.getMinorVersionNumber(previousVersion)) {
      // In case of no promo available or versions equivalence
      return;
    }

    let offer = translator/* translator.getMessage */.O.getMessage('options_popup_version_update_offer');
    let offerDesc = '';
    let offerButtonHref = 'https://link.adtidy.org/forward.html?action=learn_about_adguard&from=version_popup&app=browser_extension';
    let offerButtonText = translator/* translator.getMessage */.O.getMessage('options_popup_version_update_offer_button_text');

    if (promoNotification) {
      offer = promoNotification.text.title;
      offerDesc = promoNotification.text.desc;
      offerButtonText = promoNotification.text.btn;
      offerButtonHref = `${promoNotification.url}&from=version_popup`;
    }

    const message = {
      type: 'show-version-updated-popup',
      title: translator/* translator.getMessage */.O.getMessage('options_popup_version_update_title_text', {
        current_version: currentVersion
      }),
      description: getUpdateDescriptionMessage(currentVersion, previousVersion),
      changelogHref: 'https://link.adtidy.org/forward.html?action=github_version_popup&from=version_popup&app=browser_extension',
      changelogText: translator/* translator.getMessage */.O.getMessage('options_popup_version_update_changelog_text'),
      showPromoNotification: !!promoNotification,
      offer,
      offerDesc,
      offerButtonText,
      offerButtonHref,
      disableNotificationText: translator/* translator.getMessage */.O.getMessage('options_popup_version_update_disable_notification'),
      alertStyles,
      updateIframeStyles
    };
    await sendMessageToActiveTab(message);
  };

  let sendMessageTries = 0;
  const MAX_TRIES = 500; // 2500 sec

  const TRIES_TIMEOUT = 5000;
  /**
   * Tries to send message to an active tab,
   * in case of updated app, the content script on not-reloaded tab will not be able to send success callback,
   * so then we postpone the try by TRIES_TIMEOUT.
   *
   * @param message
   */

  const sendMessageToActiveTab = async message => {
    const result = await trySendMessageToActiveTab(message);

    if (result) {
      return;
    }

    sendMessageTries += 1;

    if (sendMessageTries > MAX_TRIES) {
      // Give up trying
      log/* log.warn */.c.warn('Reached max tries on attempts to show application popup');
      return;
    }

    setTimeout(async () => {
      await sendMessageToActiveTab(message);
    }, TRIES_TIMEOUT);
  };

  const trySendMessageToActiveTab = async message => {
    const tab = await tabsApi.getActive();

    if (!tab) {
      return false;
    }

    message.isAdguardTab = isAdguardTab(tab);
    const result = await tabsApi.sendMessage(tab.tabId, message);

    if (!result) {
      return false;
    }

    return true;
  };

  function getFiltersUpdateResultMessage(success, updatedFilters) {
    let title = '';
    let text = '';

    if (success && updatedFilters) {
      if (updatedFilters.length === 0) {
        title = '';
        text = translator/* translator.getMessage */.O.getMessage('options_popup_update_not_found');
      } else {
        title = '';
        text = updatedFilters.sort((a, b) => {
          if (a.groupId === b.groupId) {
            return a.displayNumber - b.displayNumber;
          }

          return a.groupId === b.groupId;
        }).map(filter => `${filter.name}`).join(', ');

        if (updatedFilters.length > 1) {
          text += ` ${translator/* translator.getMessage */.O.getMessage('options_popup_update_filters')}`;
        } else {
          text += ` ${translator/* translator.getMessage */.O.getMessage('options_popup_update_filter')}`;
        }
      }
    } else {
      title = translator/* translator.getMessage */.O.getMessage('options_popup_update_title_error');
      text = translator/* translator.getMessage */.O.getMessage('options_popup_update_error');
    }

    return {
      title,
      text
    };
  }

  function getFiltersEnabledResultMessage(enabledFilters) {
    const title = translator/* translator.getMessage */.O.getMessage('alert_popup_filter_enabled_title');
    const text = [];
    enabledFilters.sort((a, b) => a.displayNumber - b.displayNumber);

    for (let i = 0; i < enabledFilters.length; i += 1) {
      const filter = enabledFilters[i];
      text.push(translator/* translator.getMessage */.O.getMessage('alert_popup_filter_enabled_desc', {
        filter_name: filter.name
      }));
    }

    return {
      title,
      text
    };
  }
  /**
   * Updates extension icon and context menu for tab
   * @param {Object} tab
   * @param {boolean} reloadFrameData
   * @param {boolean} [changeIcon=true]
   */


  const updateTabIconAndContextMenu = function (tab, reloadFrameData, changeIcon = true) {
    if (reloadFrameData) {
      frames_frames.reloadFrameData(tab);
    } // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1917


    if (changeIcon) {
      updateTabIconAsync(tab);
    }

    updateTabContextMenu(tab);
  };

  const openExportRulesTab = function (hash) {
    openTab(getPageUrl(`export.html#${hash}`));
  };
  /**
   * Open settings tab with hash parameters or without them
   * @param anchor
   * @param hashParameters
   */


  const openSettingsTab = function (anchor, hashParameters = {}) {
    if (anchor) {
      hashParameters.anchor = anchor;
    }

    const options = {
      activateSameTab: true,
      hashParameters
    };
    openTab(getPageUrl('options.html'), options);
  };

  const openSiteReportTab = function (url) {
    const domain = utils.url.toPunyCode(utils.url.getDomainName(url));

    if (domain) {
      openTab(`https://link.adtidy.org/forward.html?action=site_report_page&domain=${encodeURIComponent(domain)}&from=context_menu&app=browser_extension`);
    }
  };
  /**
   * Generates query string with stealth options information
   * @returns {string}
   */


  const getStealthString = filterIds => {
    const stealthOptions = [{
      queryKey: 'ext_hide_referrer',
      settingKey: settings.HIDE_REFERRER
    }, {
      queryKey: 'hide_search_queries',
      settingKey: settings.HIDE_SEARCH_QUERIES
    }, {
      queryKey: 'DNT',
      settingKey: settings.SEND_DO_NOT_TRACK
    }, {
      queryKey: 'x_client',
      settingKey: settings.BLOCK_CHROME_CLIENT_DATA
    }, {
      queryKey: 'webrtc',
      settingKey: settings.BLOCK_WEBRTC
    }, {
      queryKey: 'third_party_cookies',
      settingKey: settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES,
      settingValueKey: settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES_TIME
    }, {
      queryKey: 'first_party_cookies',
      settingKey: settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES,
      settingValueKey: settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES_TIME
    }];
    const stealthEnabled = !settings.getProperty(settings.DISABLE_STEALTH_MODE);

    if (!stealthEnabled) {
      return `&stealth.enabled=${stealthEnabled}`;
    }

    let stealthOptionsString = stealthOptions.map(option => {
      const {
        queryKey,
        settingKey,
        settingValueKey
      } = option;
      const setting = settings.getProperty(settingKey);
      let settingString;

      if (!setting) {
        return '';
      }

      if (!settingValueKey) {
        settingString = setting;
      } else {
        settingString = settings.getProperty(settingValueKey);
      }

      return `stealth.${queryKey}=${encodeURIComponent(settingString)}`;
    }).filter(string => string.length > 0).join('&'); // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1937

    const isRemoveUrlParamsEnabled = filterIds.includes(constants/* ANTIBANNER_FILTERS_ID.URL_TRACKING_FILTER_ID */.gu.URL_TRACKING_FILTER_ID);

    if (isRemoveUrlParamsEnabled) {
      stealthOptionsString = `${stealthOptionsString}&stealth.strip_url=true`;
    }

    return `&stealth.enabled=${stealthEnabled}&${stealthOptionsString}`;
  };
  /**
   * Generates query string with browsing security information
   * @returns {string}
   */


  const getBrowserSecurityString = () => {
    const isEnabled = !settings.getProperty(settings.DISABLE_SAFEBROWSING);
    return `&browsing_security.enabled=${isEnabled}`;
  };
  /**
   * Appends hash parameters if they exists
   * @param rowUrl
   * @param hashParameters
   * @returns {string} prepared url
   */


  const appendHashParameters = (rowUrl, hashParameters) => {
    if (!hashParameters) {
      return rowUrl;
    }

    if (rowUrl.indexOf('#') > -1) {
      log/* log.warn */.c.warn(`Hash parameters can't be applied to the url with hash: '${rowUrl}'`);
      return rowUrl;
    }

    let hashPart;
    const {
      anchor
    } = hashParameters;

    if (anchor) {
      delete hashParameters[anchor];
    }

    const hashString = Object.keys(hashParameters).map(key => `${key}=${hashParameters[key]}`).join('&');

    if (hashString.length <= 0) {
      hashPart = anchor && anchor.length > 0 ? `#${anchor}` : '';
      return rowUrl + hashPart;
    }

    hashPart = anchor && anchor.length > 0 ? `replacement=${anchor}&${hashString}` : hashString;
    hashPart = encodeURIComponent(hashPart);
    return `${rowUrl}#${hashPart}`;
  };

  const openTab = async (url, options = {}) => {
    const {
      activateSameTab,
      inBackground,
      inNewWindow,
      type,
      hashParameters,
      width,
      height,
      top,
      left,
      isFullscreen
    } = options;
    url = appendHashParameters(url, hashParameters);

    const onTabFound = async tab => {
      if (tab.url !== url) {
        await tabsApi.reload(tab.tabId, url);
      }

      if (!inBackground) {
        await tabsApi.activate(tab.tabId);
      }

      return tab;
    };

    url = utils.strings.contains(url, '://') ? url : backgroundPage.getURL(url);
    const tabs = await tabsApi.getAll(); // try to find between opened tabs

    if (activateSameTab) {
      for (let i = 0; i < tabs.length; i += 1) {
        const tab = tabs[i];

        if (utils.url.urlEquals(tab.url, url)) {
          return onTabFound(tab);
        }
      }
    }

    const tab = await tabsApi.create({
      url,
      type: type || 'normal',
      active: !inBackground,
      inNewWindow,
      width,
      height,
      top,
      left,
      isFullscreen
    });
    return tab;
  };
  /**
   * Opens site complaint report tab
   * https://github.com/AdguardTeam/ReportsWebApp#pre-filling-the-app-with-query-parameters
   * @param url
   */


  const openAbuseTab = function (url, from) {
    let browser;
    let browserDetails;
    const supportedBrowsers = ['Chrome', 'Firefox', 'Opera', 'Safari', 'IE', 'Edge'];

    if (supportedBrowsers.includes(prefs.browser)) {
      browser = prefs.browser;
    } else {
      browser = 'Other';
      browserDetails = prefs.browser;
    }

    const filterIds = application.getEnabledFiltersFromEnabledGroups().map(filter => filter.filterId);
    openTab(`https://link.adtidy.org/forward.html?action=report&from=${from}&app=browser_extension&product_type=Ext&product_version=${encodeURIComponent(backgroundPage.app.getVersion())}&browser=${encodeURIComponent(browser)}${browserDetails ? `&browser_detail=${encodeURIComponent(browserDetails)}` : ''}&url=${encodeURIComponent(url)}&filters=${encodeURIComponent(filterIds.join('.'))}${getStealthString(filterIds)}${getBrowserSecurityString()}`);
  };

  const openFilteringLog = async function (tabId) {
    const FILTERING_LOG_PAGE = 'filtering-log.html';
    const windowState = filteringLogWindowState.getState();
    const options = {
      activateSameTab: true,
      type: 'popup',
      ...windowState
    };

    if (!tabId) {
      const tab = await tabsApi.getActive();

      if (tab) {
        const {
          tabId
        } = tab;
        await openTab(getPageUrl(FILTERING_LOG_PAGE) + (tabId ? `#${tabId}` : ''), options);
      }

      return;
    }

    await openTab(getPageUrl(FILTERING_LOG_PAGE) + (tabId ? `#${tabId}` : ''), options);
  };
  /**
   * Opens user rules editor in the separate window in fullscreen
   * @return {Promise<void>}
   */


  const openFullscreenUserRules = async () => {
    const theme = settings.getProperty('appearance-theme');
    const FULLSCREEN_USER_RULES_PAGE = `fullscreen-user-rules.html?theme=${theme}`;
    const options = {
      activateSameTab: true,
      inNewWindow: true
    };
    await openTab(getPageUrl(FULLSCREEN_USER_RULES_PAGE), options);
  };

  const openThankYouPage = async () => {
    const params = browserUtils.getExtensionParams();
    params.push(`_locale=${encodeURIComponent(backgroundPage.app.getLocale())}`);
    const thankyouUrl = `${THANKYOU_PAGE_URL}&${params.join('&')}`; // TODO move url in constants

    const filtersDownloadUrl = getPageUrl('filter-download.html');
    const tabs = await tabsApi.getAll(); // Finds the filter-download page and reload it within the thank-you page URL

    for (let i = 0; i < tabs.length; i += 1) {
      const tab = tabs[i];

      if (tab.url === filtersDownloadUrl) {
        tabsApi.activate(tab.tabId);
        tabsApi.reload(tab.tabId, thankyouUrl);
        return;
      }
    }

    await openTab(thankyouUrl);
  };

  const openComparePage = async () => {
    await openTab(pages_constants/* COMPARE_URL */.pR);
  };

  const openExtensionStore = async function () {
    await openTab(extensionStoreLink);
  };

  const openFiltersDownloadPage = function () {
    openTab(getPageUrl('filter-download.html'));
  };

  const openCustomFiltersModal = async (url, title) => {
    let path = 'options.html#filters?group=0';

    if (title) {
      path += `&title=${title}`;
    }

    path += `&subscribe=${encodeURIComponent(url)}`;
    const tab = await openTab(getPageUrl(path), {
      activateSameTab: true
    });
    await tabsApi.reload(tab.tabId);
  };

  const allowlistTab = function (tab) {
    const tabInfo = frames_frames.getFrameInfo(tab);
    allowlist.allowlistUrl(tabInfo.url);
    updateTabIconAndContextMenu(tab, true);
    tabsApi.reload(tab.tabId);
  };

  const unAllowlistTab = function (tab) {
    const tabInfo = frames_frames.getFrameInfo(tab);
    userrules.unAllowlistFrame(tabInfo);
    updateTabIconAndContextMenu(tab, true);
    tabsApi.reload(tab.tabId);
  };

  const changeApplicationFilteringDisabled = async function (disabled) {
    settings.changeFilteringDisabled(disabled);
    const tab = await tabsApi.getActive();

    if (tab) {
      // third arg is 'false' for no icon change to avoid icon blink
      updateTabIconAndContextMenu(tab, true, false);
      tabsApi.reload(tab.tabId);
    }
  };
  /**
   * Checks filters updates and returns updated filter
   * @param {Object[]} [filters] optional list of filters
   * @param {boolean} [showPopup = true] show update filters popup
   * @return {Object[]} [filters] list of updated filters
   */


  const checkFiltersUpdates = async (filters, showPopup = true) => {
    const showPopupEvent = listeners.UPDATE_FILTERS_SHOW_POPUP;

    try {
      const updatedFilters = await application.checkFiltersUpdates(filters);

      if (showPopup) {
        listeners.notifyListeners(showPopupEvent, true, updatedFilters);
        listeners.notifyListeners(listeners.FILTERS_UPDATE_CHECK_READY, updatedFilters);
      } else if (updatedFilters && updatedFilters.length > 0) {
        const updatedFilterStr = updatedFilters.map(f => `Filter ID: ${f.filterId}`).join(', ');
        log/* log.info */.c.info(`Filters were auto updated: ${updatedFilterStr}`);
      }

      return updatedFilters;
    } catch (e) {
      if (showPopup) {
        listeners.notifyListeners(showPopupEvent, false);
        listeners.notifyListeners(listeners.FILTERS_UPDATE_CHECK_READY);
      }

      return [];
    }
  };

  const getAssistantToken = (() => {
    const assistantToken = (0,index_browser/* nanoid */.x0)();
    return () => {
      return assistantToken;
    };
  })();

  const initAssistant = async selectElement => {
    const options = {
      addRuleCallbackName: constants/* MESSAGE_TYPES.CONTENT_SCRIPT_ADD_USER_RULE */.oK.CONTENT_SCRIPT_ADD_USER_RULE,
      selectElement,
      token: getAssistantToken()
    }; // init assistant

    const tab = await tabsApi.getActive();

    if (tab) {
      tabsApi.sendMessage(tab.tabId, {
        type: 'initAssistant',
        options
      });
    }
  };
  /**
   * The `openAssistant` function uses the `tabs.executeScript` function to inject
   * the Assistant code into a page without using messaging.
   * We do it dynamically and not include assistant file into the default content scripts
   * in order to reduce the overall memory usage.
   *
   * @param {boolean} selectElement - if true select the element on which the Mousedown event was
   */


  const openAssistant = async selectElement => {
    // Load Assistant code to the active tab immediately
    await tabsApi.executeScriptFile(null, {
      file: '/pages/assistant.js'
    });
    await initAssistant(selectElement);
  };

  const init = async () => {
    const alertStylesResponse = await fetch(alertStylesUrl);
    const alertStyles = await alertStylesResponse.text();
    const updateIframeStylesResponse = await fetch(updateIframeStyleUrl);
    const updateIframeStyles = await updateIframeStylesResponse.text(); // update icon on event received

    listeners.addListener((event, tab, reset) => {
      if (event !== listeners.UPDATE_TAB_BUTTON_STATE || !tab) {
        return;
      }

      let options;

      if (reset) {
        options = {
          icon: prefs.ICONS.ICON_GREEN,
          badge: ''
        };
      }

      updateTabIconAsync(tab, options);
    }); // Update tab icon and context menu while loading

    tabsApi.onUpdated.addListener(async tab => {
      const {
        tabId
      } = tab; // BrowserAction is set separately for each tab

      updateTabIconAsync(tab);
      const aTab = await tabsApi.getActive();

      if (aTab) {
        if (aTab.tabId !== tabId) {
          return;
        } // ContextMenu is set for all tabs, so update it only for current tab


        updateTabContextMenu(aTab);
      }
    }); // Update tab icon and context menu on active tab changed

    tabsApi.onActivated.addListener(tab => {
      updateTabIconAndContextMenu(tab, true);
    }); // Update icon and popup stats on ads blocked

    listeners.addListener(async (event, rule, tab, blocked) => {
      if (event !== listeners.ADS_BLOCKED || !tab) {
        return;
      }

      pageStats.updateStats(rule.getFilterListId(), blocked, new Date());
      const tabBlocked = frames_frames.updateBlockedAdsCount(tab, blocked);

      if (tabBlocked === null) {
        return;
      }

      updateTabIconAsync(tab);
      const activeTab = await tabsApi.getActive();

      if (activeTab) {
        if (tab.tabId === activeTab.tabId) {
          updatePopupStatsAsync(activeTab);
        }
      }
    }); // Update context menu on change user settings

    settings.onUpdated.addListener(async setting => {
      if (setting === settings.DISABLE_SHOW_CONTEXT_MENU) {
        const tab = await tabsApi.getActive();

        if (tab) {
          updateTabContextMenu(tab);
        }
      }
    }); // Update tab icon and context menu on application initialization

    listeners.addListener(async event => {
      if (event === listeners.APPLICATION_INITIALIZED) {
        const tab = await tabsApi.getActive();

        if (tab) {
          updateTabIconAndContextMenu(tab);
        }
      }
    }); // on application updated event

    listeners.addListener((event, info) => {
      if (event === listeners.APPLICATION_UPDATED) {
        if (settings.isShowAppUpdatedNotification()) {
          showApplicationUpdatedPopup(info.currentVersion, info.prevVersion, alertStyles, updateIframeStyles);
        }
      }
    }); // on filter auto-enabled event

    listeners.addListener((event, enabledFilters) => {
      if (event === listeners.ENABLE_FILTER_SHOW_POPUP) {
        const result = getFiltersEnabledResultMessage(enabledFilters);
        showAlertMessagePopup(result.title, result.text, alertStyles);
      }
    }); // on filter enabled event

    listeners.addListener((event, payload) => {
      switch (event) {
        case listeners.FILTER_ENABLE_DISABLE:
          if (payload.enabled) {
            checkFiltersUpdates([payload], false);
          }

          break;

        case listeners.FILTER_GROUP_ENABLE_DISABLE:
          if (payload.enabled && payload.filters) {
            const enabledFilters = payload.filters.filter(f => f.enabled);
            checkFiltersUpdates(enabledFilters, false);
          }

          break;

        default:
          break;
      }
    }); // on filters updated event

    listeners.addListener((event, success, updatedFilters) => {
      if (event === listeners.UPDATE_FILTERS_SHOW_POPUP) {
        const result = getFiltersUpdateResultMessage(success, updatedFilters);
        showAlertMessagePopup(result.title, result.text, alertStyles);
      }
    }); // close all page on unload

    unload.when(closeAllPages);
  };

  return {
    init,
    openExportRulesTab,
    openSettingsTab,
    openSiteReportTab,
    openFilteringLog,
    openFullscreenUserRules,
    openThankYouPage,
    openComparePage,
    openExtensionStore,
    openFiltersDownloadPage,
    openCustomFiltersModal,
    openAbuseTab,
    updateTabIconAndContextMenu,
    allowlistTab,
    unAllowlistTab,
    changeApplicationFilteringDisabled,
    checkFiltersUpdates,
    openAssistant,
    openTab,
    showAlertMessagePopup,
    getAssistantToken
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/startup.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */










/**
 * Extension initialize logic. Called from start.js
 */

const startup = async function () {
  async function onLocalStorageLoaded() {
    log/* log.info */.c.info('Starting adguard... Version: {0}. Id: {1}', backgroundPage.app.getVersion(), backgroundPage.app.getId()); // Initialize popup button

    backgroundPage.browserAction.setPopup({
      popup: backgroundPage.getURL('pages/popup.html')
    }); // Set uninstall page url
    // eslint-disable-next-line max-len

    const uninstallUrl = 'https://link.adtidy.org/forward.html?action=adguard_uninstal_ext&from=background&app=browser_extension';

    try {
      await extension_api_browser/* browser.runtime.setUninstallURL */.X.runtime.setUninstallURL(uninstallUrl);
    } catch (e) {
      log/* log.error */.c.error(e);
    }

    allowlist.init();
    filtering_log_browsers.init();
    await uiService.init();
    stealthService.init();
    /**
     * Start application
     */

    application.start({
      async onInstall() {
        // Process installation

        /**
         * Show UI installation page
         */
        uiService.openFiltersDownloadPage(); // Retrieve filters and install them

        const filterIds = application.offerFilters();
        await application.addAndEnableFilters(filterIds); // enable language-specific group by default

        await application.enableGroup(constants/* ANTIBANNER_GROUPS_ID.LANGUAGE_FILTERS_GROUP_ID */.CI.LANGUAGE_FILTERS_GROUP_ID);
      }

    });
  }

  await rulesStorage.init();
  await storage_localStorage.init();
  onLocalStorageLoaded();
};
;// CONCATENATED MODULE: ./Extension/src/background/start.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * Extension startup entry point
 */

const start = () => {
  log/* log.info */.c.info('Initializing adguard');
  startup();
};
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.set.js
var es_typed_array_set = __webpack_require__(57168);
// EXTERNAL MODULE: ./node_modules/@adguard/tsurlfilter/dist/es/network-rule-ab8c23a3.js
var network_rule_ab8c23a3 = __webpack_require__(73700);
// EXTERNAL MODULE: ./node_modules/@adguard/tsurlfilter/dist/es/simple-regex-ea3ddcd2.js
var simple_regex_ea3ddcd2 = __webpack_require__(87922);
// EXTERNAL MODULE: ./node_modules/@adguard/tsurlfilter/dist/es/network-rule-options.js
var network_rule_options = __webpack_require__(46463);
;// CONCATENATED MODULE: ./node_modules/@adguard/tsurlfilter/dist/es/cookie-filtering.js







/**
 * Cookie rules manager class
 */
var CookieRulesFinder = /** @class */ (function () {
    function CookieRulesFinder() {
    }
    /**
     * Filters blocking rules
     * Used in content scripts
     *
     * @param url
     * @param rules
     */
    CookieRulesFinder.getBlockingRules = function (url, rules) {
        return rules.filter(function (rule) { return !CookieRulesFinder.isModifyingRule(rule); });
    };
    /**
     * Finds a rule that doesn't modify cookie: i.e. this rule cancels cookie or it's a allowlist rule.
     *
     * @param cookieName Cookie name
     * @param rules Matching rules
     * @param isThirdPartyCookie
     * @return Found rule or null
     */
    CookieRulesFinder.lookupNotModifyingRule = function (cookieName, rules, isThirdPartyCookie) {
        var blockingRules = [];
        var allowlistRules = [];
        for (var i = 0; i < rules.length; i += 1) {
            var rule = rules[i];
            if (!CookieRulesFinder.matchThirdParty(rule, isThirdPartyCookie)) {
                continue;
            }
            var cookieModifier = rule.getAdvancedModifier();
            if (cookieModifier.matches(cookieName) && !CookieRulesFinder.isModifyingRule(rule)) {
                if (rule.isAllowlist()) {
                    allowlistRules.push(rule);
                }
                else {
                    blockingRules.push(rule);
                }
            }
        }
        if (allowlistRules.length > 0) {
            return allowlistRules[0];
        }
        if (blockingRules.length > 0) {
            return blockingRules[0];
        }
        return null;
    };
    /**
     * Finds rules that modify cookie
     *
     * @param cookieName Cookie name
     * @param rules Matching rules
     * @param isThirdPartyCookie
     * @return Modifying rules
     */
    CookieRulesFinder.lookupModifyingRules = function (cookieName, rules, isThirdPartyCookie) {
        var result = [];
        var allowlistRules = [];
        if (rules && rules.length > 0) {
            for (var i = 0; i < rules.length; i += 1) {
                var rule = rules[i];
                if (!CookieRulesFinder.matchThirdParty(rule, isThirdPartyCookie)) {
                    continue;
                }
                var cookieModifier = rule.getAdvancedModifier();
                if (!cookieModifier.matches(cookieName)) {
                    continue;
                }
                if (!rule.isAllowlist() && !CookieRulesFinder.isModifyingRule(rule)) {
                    return [];
                }
                if (rule.isAllowlist()) {
                    allowlistRules.push(rule);
                }
                else {
                    result.push(rule);
                }
            }
        }
        if (allowlistRules.length > 0) {
            return allowlistRules;
        }
        return result;
    };
    /**
     * Checks if rule and third party flag matches
     *
     * @param rule
     * @param isThirdParty
     */
    CookieRulesFinder.matchThirdParty = function (rule, isThirdParty) {
        if (!rule.isOptionEnabled(network_rule_ab8c23a3.N.ThirdParty)) {
            return true;
        }
        return isThirdParty === rule.isOptionEnabled(network_rule_ab8c23a3.N.ThirdParty);
    };
    /**
     * Checks if $cookie rule is modifying
     *
     * @param rule $cookie rule
     * @return result
     */
    CookieRulesFinder.isModifyingRule = function (rule) {
        var cookieModifier = rule.getAdvancedModifier();
        return cookieModifier.getSameSite() !== null
            || (cookieModifier.getMaxAge() !== null && cookieModifier.getMaxAge() > 0);
    };
    return CookieRulesFinder;
}());

/**
 * Synthetic Cookie-like object parsed from headers
 */
var ParsedCookie = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param name
     * @param value
     * @param url
     */
    function ParsedCookie(name, value, url) {
        /**
         * Cookie's third-party status.
         */
        this.thirdParty = false;
        this.name = name;
        this.value = value;
        this.url = url;
        var tldResult = (0,url_94de2ee3.p)(url);
        this.domain = tldResult.domain;
    }
    return ParsedCookie;
}());

/**
 * Cookie Utils
 */
var CookieUtils = /** @class */ (function () {
    function CookieUtils() {
    }
    /**
     * Parses set-cookie header from http response header
     * @param header
     * @param url
     */
    CookieUtils.parseSetCookieHeader = function (header, url) {
        if (!header.name || header.name.toLowerCase() !== 'set-cookie') {
            return null;
        }
        if (!header.value) {
            return null;
        }
        return CookieUtils.parseSetCookie(header.value, url);
    };
    /**
     * Parses set-cookie headers for cookie objects
     *
     * @param responseHeaders
     * @param url
     * @returns array of parsed cookies
     */
    CookieUtils.parseSetCookieHeaders = function (responseHeaders, url) {
        var result = [];
        var iResponseHeaders = responseHeaders.length;
        while (iResponseHeaders > 0) {
            iResponseHeaders -= 1;
            var header = responseHeaders[iResponseHeaders];
            var setCookie = CookieUtils.parseSetCookieHeader(header, url);
            if (setCookie) {
                result.push(setCookie);
            }
        }
        return result;
    };
    /**
     * Parse an HTTP Cookie header string and return an object with all cookie name-value pairs.
     *
     * @param cookieValue HTTP Cookie value
     * @param url
     * @returns Array of cookie name-value pairs
     */
    CookieUtils.parseCookies = function (cookieValue, url) {
        var cookies = [];
        // Split Cookie values
        var pairs = cookieValue.split(/; */);
        for (var i = 0; i < pairs.length; i += 1) {
            var pair = pairs[i];
            var eqIdx = pair.indexOf('=');
            // skip things that don't look like key=value
            if (eqIdx < 0) {
                continue;
            }
            var key = pair.substr(0, eqIdx).trim();
            var value = pair.substr(eqIdx + 1, pair.length).trim();
            var parsedCookie = new ParsedCookie(key, value, url);
            /**
             * Not obviously there are few special name prefixes
             * https://developer.cdn.mozilla.net/pt-BR/docs/Web/HTTP/Headers/Set-Cookie
             */
            if (key.startsWith('__Secure-') || key.startsWith('__Host-')) {
                parsedCookie.secure = true;
            }
            cookies.push(parsedCookie);
        }
        return cookies;
    };
    /**
     * Parses "Set-Cookie" header value and returns a cookie object with its properties
     *
     * @param setCookieValue "Set-Cookie" header value to parse
     * @param url
     * @returns cookie object or null if it failed to parse the value
     */
    CookieUtils.parseSetCookie = function (setCookieValue, url) {
        var parts = setCookieValue.split(';').filter(function (s) { return !!s; });
        var nameValuePart = parts.shift();
        if (!nameValuePart) {
            return null;
        }
        var nameValue = nameValuePart.split('=');
        var name = nameValue.shift();
        // everything after the first =, joined by a "=" if there was more than one part
        var value = nameValue.join('=');
        var cookie = new ParsedCookie(name, value, url);
        parts.forEach(function (part) {
            var sides = part.split('=');
            var key = sides
                .shift()
                .trimStart()
                .toLowerCase();
            var optionValue = sides.join('=');
            if (key === 'expires') {
                cookie.expires = new Date(optionValue);
            }
            else if (key === 'max-age') {
                cookie.maxAge = parseInt(optionValue, 10);
            }
            else if (key === 'secure') {
                cookie.secure = true;
            }
            else if (key === 'httponly') {
                cookie.httpOnly = true;
            }
            else if (key === 'samesite') {
                cookie.sameSite = optionValue;
            }
            else if (key === 'path') {
                cookie.path = optionValue;
            }
        });
        return cookie;
    };
    /**
     * Updates cookie maxAge value
     *
     * @param cookie Cookie to modify
     * @param maxAge
     * @return if cookie was modified
     */
    CookieUtils.updateCookieMaxAge = function (cookie, maxAge) {
        var currentTimeSec = Date.now() / 1000;
        var cookieExpiresTimeSec = null;
        if (cookie.maxAge) {
            cookieExpiresTimeSec = currentTimeSec + cookie.maxAge;
        }
        else if (cookie.expires) {
            cookieExpiresTimeSec = cookie.expires.getTime() / 1000;
        }
        var newCookieExpiresTimeSec = currentTimeSec + maxAge;
        if (cookieExpiresTimeSec === null || cookieExpiresTimeSec > newCookieExpiresTimeSec) {
            // eslint-disable-next-line no-param-reassign
            cookie.expires = new Date(newCookieExpiresTimeSec * 1000);
            // eslint-disable-next-line no-param-reassign
            cookie.maxAge = maxAge;
            return true;
        }
        return false;
    };
    /**
     * Serializes cookie data into a string suitable for Set-Cookie header.
     *
     * @param cookie A cookie object
     * @return Set-Cookie string or null if it failed to serialize object
     * @throws {TypeError} Thrown in case of invalid input data
     * @public
     */
    CookieUtils.serializeCookie = function (cookie) {
        if (!cookie) {
            throw new TypeError('empty cookie data');
        }
        // 1. Validate fields
        if (!CookieUtils.FIELD_CONTENT_REGEX.test(cookie.name)) {
            throw new TypeError("Cookie name is invalid: ".concat(cookie.name));
        }
        if (cookie.value && !CookieUtils.FIELD_CONTENT_REGEX.test(cookie.value)) {
            throw new TypeError("Cookie value is invalid: ".concat(cookie.value));
        }
        if (cookie.domain && !CookieUtils.FIELD_CONTENT_REGEX.test(cookie.domain)) {
            throw new TypeError("Cookie domain is invalid: ".concat(cookie.domain));
        }
        if (cookie.path && !CookieUtils.FIELD_CONTENT_REGEX.test(cookie.path)) {
            throw new TypeError("Cookie path is invalid: ".concat(cookie.path));
        }
        if (cookie.expires && typeof cookie.expires.toUTCString !== 'function') {
            throw new TypeError("Cookie expires is invalid: ".concat(cookie.expires));
        }
        // 2. Build Set-Cookie header value
        var setCookieValue = cookie.name + '=' + cookie.value;
        if (typeof cookie.maxAge === 'number' && !Number.isNaN(cookie.maxAge)) {
            setCookieValue += '; Max-Age=' + Math.floor(cookie.maxAge);
        }
        if (cookie.domain) {
            setCookieValue += '; Domain=' + cookie.domain;
        }
        if (cookie.path) {
            setCookieValue += '; Path=' + cookie.path;
        }
        if (cookie.expires) {
            setCookieValue += '; Expires=' + cookie.expires.toUTCString();
        }
        if (cookie.httpOnly) {
            setCookieValue += '; HttpOnly';
        }
        if (cookie.secure) {
            setCookieValue += '; Secure';
        }
        if (cookie.sameSite) {
            var sameSite = cookie.sameSite.toLowerCase();
            switch (sameSite) {
                case 'lax':
                    setCookieValue += '; SameSite=Lax';
                    break;
                case 'strict':
                    setCookieValue += '; SameSite=Strict';
                    break;
                case 'none':
                    setCookieValue += '; SameSite=None';
                    break;
                default:
                    throw new TypeError("Cookie sameSite is invalid: ".concat(cookie.sameSite));
            }
        }
        // Don't affected. Let it be here just in case
        // https://bugs.chromium.org/p/chromium/issues/detail?id=232693
        if (cookie.priority) {
            setCookieValue += "; Priority=".concat(cookie.priority);
        }
        return setCookieValue;
    };
    /**
     * RegExp to match field-content in RFC 7230 sec 3.2
     *
     * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
     * field-vchar   = VCHAR / obs-text
     * obs-text      = %x80-FF
     */
    // eslint-disable-next-line no-control-regex
    CookieUtils.FIELD_CONTENT_REGEX = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    return CookieUtils;
}());

var browserPolyfill = {exports: {}};

(function (module, exports) {
(function (global, factory) {
  {
    factory(module);
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : network_rule_ab8c23a3.c, function (module) {
  if (typeof browser === "undefined" || Object.getPrototypeOf(browser) !== Object.prototype) {
    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";
    const SEND_RESPONSE_DEPRECATION_WARNING = "Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)";
    const wrapAPIs = extensionAPIs => {
      const apiMetadata = {
        "alarms": {
          "clear": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "clearAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "get": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "bookmarks": {
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getChildren": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getRecent": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getSubTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTree": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "browserAction": {
          "disable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "enable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "getBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getBadgeText": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "openPopup": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setBadgeText": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "browsingData": {
          "remove": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "removeCache": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCookies": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeDownloads": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFormData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeHistory": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeLocalStorage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePasswords": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePluginData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "settings": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "commands": {
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "contextMenus": {
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "cookies": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAllCookieStores": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "set": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "devtools": {
          "inspectedWindow": {
            "eval": {
              "minArgs": 1,
              "maxArgs": 2,
              "singleCallbackArg": false
            }
          },
          "panels": {
            "create": {
              "minArgs": 3,
              "maxArgs": 3,
              "singleCallbackArg": true
            },
            "elements": {
              "createSidebarPane": {
                "minArgs": 1,
                "maxArgs": 1
              }
            }
          }
        },
        "downloads": {
          "cancel": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "download": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "erase": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFileIcon": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "open": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "pause": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFile": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "resume": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "extension": {
          "isAllowedFileSchemeAccess": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "isAllowedIncognitoAccess": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "history": {
          "addUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "deleteRange": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getVisits": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "i18n": {
          "detectLanguage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAcceptLanguages": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "identity": {
          "launchWebAuthFlow": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "idle": {
          "queryState": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "management": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getSelf": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setEnabled": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "uninstallSelf": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "notifications": {
          "clear": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPermissionLevel": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "pageAction": {
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "hide": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "permissions": {
          "contains": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "request": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "runtime": {
          "getBackgroundPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPlatformInfo": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "openOptionsPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "requestUpdateCheck": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "sendMessage": {
            "minArgs": 1,
            "maxArgs": 3
          },
          "sendNativeMessage": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "setUninstallURL": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "sessions": {
          "getDevices": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getRecentlyClosed": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "restore": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "storage": {
          "local": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          },
          "managed": {
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            }
          },
          "sync": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          }
        },
        "tabs": {
          "captureVisibleTab": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "detectLanguage": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "discard": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "duplicate": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "executeScript": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getZoom": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getZoomSettings": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goBack": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goForward": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "highlight": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "insertCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "query": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "reload": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "sendMessage": {
            "minArgs": 2,
            "maxArgs": 3
          },
          "setZoom": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "setZoomSettings": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "update": {
            "minArgs": 1,
            "maxArgs": 2
          }
        },
        "topSites": {
          "get": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "webNavigation": {
          "getAllFrames": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFrame": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "webRequest": {
          "handlerBehaviorChanged": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "windows": {
          "create": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getLastFocused": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        }
      };
      if (Object.keys(apiMetadata).length === 0) {
        throw new Error("api-metadata.json has not been included in browser-polyfill");
      }
      class DefaultWeakMap extends WeakMap {
        constructor(createItem, items = undefined) {
          super(items);
          this.createItem = createItem;
        }
        get(key) {
          if (!this.has(key)) {
            this.set(key, this.createItem(key));
          }
          return super.get(key);
        }
      }
      const isThenable = value => {
        return value && typeof value === "object" && typeof value.then === "function";
      };
      const makeCallback = (promise, metadata) => {
        return (...callbackArgs) => {
          if (extensionAPIs.runtime.lastError) {
            promise.reject(new Error(extensionAPIs.runtime.lastError.message));
          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
            promise.resolve(callbackArgs[0]);
          } else {
            promise.resolve(callbackArgs);
          }
        };
      };
      const pluralizeArguments = numArgs => numArgs == 1 ? "argument" : "arguments";
      const wrapAsyncFunction = (name, metadata) => {
        return function asyncFunctionWrapper(target, ...args) {
          if (args.length < metadata.minArgs) {
            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
          }
          if (args.length > metadata.maxArgs) {
            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
          }
          return new Promise((resolve, reject) => {
            if (metadata.fallbackToNoCallback) {
              try {
                target[name](...args, makeCallback({
                  resolve,
                  reject
                }, metadata));
              } catch (cbError) {
                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + "falling back to call it without a callback: ", cbError);
                target[name](...args);
                metadata.fallbackToNoCallback = false;
                metadata.noCallback = true;
                resolve();
              }
            } else if (metadata.noCallback) {
              target[name](...args);
              resolve();
            } else {
              target[name](...args, makeCallback({
                resolve,
                reject
              }, metadata));
            }
          });
        };
      };
      const wrapMethod = (target, method, wrapper) => {
        return new Proxy(method, {
          apply(targetMethod, thisObj, args) {
            return wrapper.call(thisObj, target, ...args);
          }
        });
      };
      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
      const wrapObject = (target, wrappers = {}, metadata = {}) => {
        let cache = Object.create(null);
        let handlers = {
          has(proxyTarget, prop) {
            return prop in target || prop in cache;
          },
          get(proxyTarget, prop, receiver) {
            if (prop in cache) {
              return cache[prop];
            }
            if (!(prop in target)) {
              return undefined;
            }
            let value = target[prop];
            if (typeof value === "function") {
              if (typeof wrappers[prop] === "function") {
                value = wrapMethod(target, target[prop], wrappers[prop]);
              } else if (hasOwnProperty(metadata, prop)) {
                let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                value = wrapMethod(target, target[prop], wrapper);
              } else {
                value = value.bind(target);
              }
            } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
              value = wrapObject(value, wrappers[prop], metadata[prop]);
            } else if (hasOwnProperty(metadata, "*")) {
              value = wrapObject(value, wrappers[prop], metadata["*"]);
            } else {
              Object.defineProperty(cache, prop, {
                configurable: true,
                enumerable: true,
                get() {
                  return target[prop];
                },
                set(value) {
                  target[prop] = value;
                }
              });
              return value;
            }
            cache[prop] = value;
            return value;
          },
          set(proxyTarget, prop, value, receiver) {
            if (prop in cache) {
              cache[prop] = value;
            } else {
              target[prop] = value;
            }
            return true;
          },
          defineProperty(proxyTarget, prop, desc) {
            return Reflect.defineProperty(cache, prop, desc);
          },
          deleteProperty(proxyTarget, prop) {
            return Reflect.deleteProperty(cache, prop);
          }
        };
        let proxyTarget = Object.create(target);
        return new Proxy(proxyTarget, handlers);
      };
      const wrapEvent = wrapperMap => ({
        addListener(target, listener, ...args) {
          target.addListener(wrapperMap.get(listener), ...args);
        },
        hasListener(target, listener) {
          return target.hasListener(wrapperMap.get(listener));
        },
        removeListener(target, listener) {
          target.removeListener(wrapperMap.get(listener));
        }
      });
      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        return function onRequestFinished(req) {
          const wrappedReq = wrapObject(req, {}
          , {
            getContent: {
              minArgs: 0,
              maxArgs: 0
            }
          });
          listener(wrappedReq);
        };
      });
      let loggedSendResponseDeprecationWarning = false;
      const onMessageWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        return function onMessage(message, sender, sendResponse) {
          let didCallSendResponse = false;
          let wrappedSendResponse;
          let sendResponsePromise = new Promise(resolve => {
            wrappedSendResponse = function (response) {
              if (!loggedSendResponseDeprecationWarning) {
                console.warn(SEND_RESPONSE_DEPRECATION_WARNING, new Error().stack);
                loggedSendResponseDeprecationWarning = true;
              }
              didCallSendResponse = true;
              resolve(response);
            };
          });
          let result;
          try {
            result = listener(message, sender, wrappedSendResponse);
          } catch (err) {
            result = Promise.reject(err);
          }
          const isResultThenable = result !== true && isThenable(result);
          if (result !== true && !isResultThenable && !didCallSendResponse) {
            return false;
          }
          const sendPromisedResult = promise => {
            promise.then(msg => {
              sendResponse(msg);
            }, error => {
              let message;
              if (error && (error instanceof Error || typeof error.message === "string")) {
                message = error.message;
              } else {
                message = "An unexpected error occurred";
              }
              sendResponse({
                __mozWebExtensionPolyfillReject__: true,
                message
              });
            }).catch(err => {
              console.error("Failed to send onMessage rejected reply", err);
            });
          };
          if (isResultThenable) {
            sendPromisedResult(result);
          } else {
            sendPromisedResult(sendResponsePromise);
          }
          return true;
        };
      });
      const wrappedSendMessageCallback = ({
        reject,
        resolve
      }, reply) => {
        if (extensionAPIs.runtime.lastError) {
          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
            resolve();
          } else {
            reject(new Error(extensionAPIs.runtime.lastError.message));
          }
        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
          reject(new Error(reply.message));
        } else {
          resolve(reply);
        }
      };
      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
        if (args.length < metadata.minArgs) {
          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
        }
        if (args.length > metadata.maxArgs) {
          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
        }
        return new Promise((resolve, reject) => {
          const wrappedCb = wrappedSendMessageCallback.bind(null, {
            resolve,
            reject
          });
          args.push(wrappedCb);
          apiNamespaceObj.sendMessage(...args);
        });
      };
      const staticWrappers = {
        devtools: {
          network: {
            onRequestFinished: wrapEvent(onRequestFinishedWrappers)
          }
        },
        runtime: {
          onMessage: wrapEvent(onMessageWrappers),
          onMessageExternal: wrapEvent(onMessageWrappers),
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 1,
            maxArgs: 3
          })
        },
        tabs: {
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 2,
            maxArgs: 3
          })
        }
      };
      const settingMetadata = {
        clear: {
          minArgs: 1,
          maxArgs: 1
        },
        get: {
          minArgs: 1,
          maxArgs: 1
        },
        set: {
          minArgs: 1,
          maxArgs: 1
        }
      };
      apiMetadata.privacy = {
        network: {
          "*": settingMetadata
        },
        services: {
          "*": settingMetadata
        },
        websites: {
          "*": settingMetadata
        }
      };
      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
    };
    if (typeof chrome != "object" || !chrome || !chrome.runtime || !chrome.runtime.id) {
      throw new Error("This script should only be loaded in a browser extension.");
    }
    module.exports = wrapAPIs(chrome);
  } else {
    module.exports = browser;
  }
});

}(browserPolyfill));
var browser$1 = browserPolyfill.exports;

/**
 * Cookie api implementation
 */
var BrowserCookieApi = /** @class */ (function () {
    function BrowserCookieApi() {
    }
    /**
     * Removes cookie
     *
     * @param name
     * @param url
     */
    BrowserCookieApi.prototype.removeCookie = function (name, url) {
        return (0,network_rule_ab8c23a3.e)(this, void 0, void 0, function () {
            var e_1;
            return (0,network_rule_ab8c23a3.f)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, browser$1.cookies.remove({ name: name, url: url })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, true];
                    case 2:
                        e_1 = _a.sent();
                        network_rule_ab8c23a3.l.error(e_1.message);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/, false];
                }
            });
        });
    };
    /**
     * Updates cookie
     *
     * @param cookie Cookie for update
     */
    BrowserCookieApi.prototype.modifyCookie = function (cookie) {
        return (0,network_rule_ab8c23a3.e)(this, void 0, void 0, function () {
            var update, e_2;
            return (0,network_rule_ab8c23a3.f)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        update = BrowserCookieApi.convertToSetDetailsType(cookie);
                        return [4 /*yield*/, browser$1.cookies.set(update)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, true];
                    case 2:
                        e_2 = _a.sent();
                        network_rule_ab8c23a3.l.error(e_2.message);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/, false];
                }
            });
        });
    };
    BrowserCookieApi.convertToSetDetailsType = function (cookie) {
        return {
            /**
             * The request-URI to associate with the setting of the cookie.
             * This value can affect the default domain and path values of the created cookie.
             * If host permissions for this URL are not specified in the manifest file, the API call will fail.
             */
            url: cookie.url,
            /**
             * The name of the cookie. Empty by default if omitted.
             * Optional.
             */
            name: cookie.name,
            /**
             * The value of the cookie. Empty by default if omitted.
             * Optional.
             */
            value: cookie.value,
            /**
             * The domain of the cookie. If omitted, the cookie becomes a host-only cookie.
             * Optional.
             */
            domain: cookie.domain,
            /**
             * Whether the cookie should be marked as Secure. Defaults to false.
             * Optional.
             */
            secure: cookie.secure,
            /**
             * Whether the cookie should be marked as HttpOnly. Defaults to false.
             * Optional.
             */
            httpOnly: cookie.httpOnly,
            /**
             * The cookie's same-site status.
             * Optional.
             */
            sameSite: BrowserCookieApi.getSameSiteStatus(cookie.sameSite),
            /**
             * The expiration date of the cookie as the number of seconds since the UNIX epoch.
             * If omitted, the cookie becomes a session cookie.
             * Optional.
             */
            expirationDate: cookie.expires ? cookie.expires.getTime() : undefined,
        };
    };
    /**
     * Returns same-site type
     *
     * @param sameSite
     */
    BrowserCookieApi.getSameSiteStatus = function (sameSite) {
        if (sameSite) {
            if (sameSite.toLowerCase() === 'lax') {
                return 'lax';
            }
            if (sameSite.toLowerCase() === 'strict') {
                return 'strict';
            }
        }
        return undefined;
    };
    return BrowserCookieApi;
}());

/**
 * Cookie filtering
 *
 * The following public methods should be set as suitable webrequest events listeners,
 * check sample extension in this repo for an example
 *
 * Logic introduction:
 *
 * onBeforeRequest:
 * - get $cookie rules for current url
 *
 * onBeforeSendHeaders:
 * - get all cookies for request url
 * - store cookies (first-party)
 *
 * onHeadersReceived:
 * - parse set-cookie header, only to detect if the cookie in header will be set from third-party request
 * - save third-party flag for this cookie cookie.thirdParty=request.thirdParty
 * - apply rules via removing them from headers and removing them with browser.cookies api
 * TODO Rewrite/split method for extensions on MV3, because we wont have possibility to remove rules via headers
 *
 * onCompleted/onErrorOccurred:
 * - delete request context from the storage
 *
 * onCompleted
 * - apply rules via content script
 * In content-scripts (check /src/content-script/cookie-controller.ts):
 * - get matching cookie rules
 * - apply
 */
var CookieFiltering = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param filteringLog
     */
    function CookieFiltering(filteringLog) {
        this.browserCookieApi = new BrowserCookieApi();
        this.requestContextStorage = new Map();
        this.filteringLog = filteringLog;
    }
    /**
     * Finds rules for request and saves it to context storage
     * @param details
     * @param rules
     */
    CookieFiltering.prototype.onBeforeRequest = function (details, rules) {
        this.requestContextStorage.set(details.requestId, {
            rules: rules,
            cookies: [],
            url: details.url,
            tabId: details.tabId,
        });
    };
    /**
     * Parses cookies from headers
     * @param details
     */
    CookieFiltering.prototype.onBeforeSendHeaders = function (details) {
        if (!details.requestHeaders) {
            return;
        }
        var context = this.requestContextStorage.get(details.requestId);
        if (!context) {
            return;
        }
        var cookieHeader = findHeaderByName(details.requestHeaders, 'Cookie');
        if (!cookieHeader || !cookieHeader.value) {
            return;
        }
        var cookies = CookieUtils.parseCookies(cookieHeader.value, context.url);
        if (cookies.length === 0) {
            return;
        }
        context.cookies = cookies;
    };
    /**
     * Applies cookies to headers
     * @param details
     * @private
     */
    CookieFiltering.prototype.applyRulesToCookieHeaders = function (details) {
        var _this = this;
        var headersModified = false;
        if (!details.responseHeaders) {
            return headersModified;
        }
        var context = this.requestContextStorage.get(details.requestId);
        if (!context) {
            return headersModified;
        }
        var _loop_1 = function (i) {
            var header = details.responseHeaders[i];
            var cookie = CookieUtils.parseSetCookieHeader(header, details.url);
            if (!cookie) {
                return "continue";
            }
            var bRule = CookieRulesFinder.lookupNotModifyingRule(cookie.name, context.rules, details.thirdParty);
            if (bRule) {
                if (!bRule.isAllowlist()) {
                    details.responseHeaders.splice(i, 1);
                    headersModified = true;
                }
                this_1.filteringLog.addCookieEvent({
                    tabId: context.tabId,
                    cookieName: cookie.name,
                    cookieValue: cookie.value,
                    cookieDomain: cookie.domain,
                    cookieRule: bRule,
                    isModifyingCookieRule: false,
                    thirdParty: details.thirdParty,
                    timestamp: Date.now(),
                });
            }
            var mRules = CookieRulesFinder.lookupModifyingRules(cookie.name, context.rules, details.thirdParty);
            if (mRules.length > 0) {
                var appliedRules = CookieFiltering.applyRuleToBrowserCookie(cookie, mRules);
                if (appliedRules.length > 0) {
                    headersModified = true;
                    details.responseHeaders[i] = { name: 'set-cookie', value: CookieUtils.serializeCookie(cookie) };
                    appliedRules.forEach(function (r) {
                        _this.filteringLog.addCookieEvent({
                            tabId: details.tabId,
                            cookieName: cookie.name,
                            cookieValue: cookie.value,
                            cookieDomain: cookie.domain,
                            cookieRule: r,
                            isModifyingCookieRule: true,
                            thirdParty: details.thirdParty,
                            timestamp: Date.now(),
                        });
                    });
                }
            }
        };
        var this_1 = this;
        for (var i = details.responseHeaders.length - 1; i >= 0; i -= 1) {
            _loop_1(i);
        }
        return headersModified;
    };
    /**
     * Parses set-cookie header
     * looks up third-party cookies
     * This callback won't work for mv3 extensions
     * TODO separate or rewrite to mv2 and mv3 methods
     *
     * @param details
     */
    CookieFiltering.prototype.onHeadersReceived = function (details) {
        var _a;
        var context = this.requestContextStorage.get(details.requestId);
        if (!context) {
            return false;
        }
        if (details.responseHeaders) {
            var cookies = CookieUtils.parseSetCookieHeaders(details.responseHeaders, context.url);
            var newCookies = cookies.filter(function (c) { return !context.cookies.includes(c); });
            for (var _i = 0, newCookies_1 = newCookies; _i < newCookies_1.length; _i++) {
                var cookie = newCookies_1[_i];
                cookie.thirdParty = details.thirdParty;
            }
            (_a = context.cookies).push.apply(_a, newCookies);
        }
        // remove cookie headers
        // this method won't work in the extension build with manifest v3
        var headersModified = this.applyRulesToCookieHeaders(details);
        // removes cookies with browser.cookie api
        this.applyRules(details.requestId)
            .catch(function (e) {
            network_rule_ab8c23a3.l.error(e.message);
        });
        return headersModified;
    };
    CookieFiltering.prototype.onCompleted = function (details) {
        this.requestContextStorage.delete(details.requestId);
    };
    CookieFiltering.prototype.onErrorOccurred = function (details) {
        this.requestContextStorage.delete(details.requestId);
    };
    /**
     * Looks up blocking rules for content-script
     *
     * @param requestId
     */
    CookieFiltering.prototype.getBlockingRules = function (requestId) {
        var context = this.requestContextStorage.get(requestId);
        if (!context) {
            return [];
        }
        return CookieRulesFinder.getBlockingRules(context.url, context.rules);
    };
    /**
     * Applies rules
     * @param requestId
     */
    CookieFiltering.prototype.applyRules = function (requestId) {
        return (0,network_rule_ab8c23a3.e)(this, void 0, void 0, function () {
            var context, _a, rules, cookies, promises;
            var _this = this;
            return (0,network_rule_ab8c23a3.f)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        context = this.requestContextStorage.get(requestId);
                        _a = context, rules = _a.rules, cookies = _a.cookies;
                        if (!rules || !cookies) {
                            return [2 /*return*/];
                        }
                        promises = cookies.map(function (cookie) {
                            return _this.applyRulesToCookie(cookie, rules, context.tabId);
                        });
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Applies rules to cookie
     *
     * @param cookie
     * @param cookieRules
     * @param tabId
     */
    /* istanbul ignore next */
    CookieFiltering.prototype.applyRulesToCookie = function (cookie, cookieRules, tabId) {
        return (0,network_rule_ab8c23a3.e)(this, void 0, void 0, function () {
            var cookieName, isThirdPartyCookie, bRule, _a, mRules, appliedRules;
            var _this = this;
            return (0,network_rule_ab8c23a3.f)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        cookieName = cookie.name;
                        isThirdPartyCookie = cookie.thirdParty;
                        bRule = CookieRulesFinder.lookupNotModifyingRule(cookieName, cookieRules, isThirdPartyCookie);
                        if (!bRule) return [3 /*break*/, 3];
                        _a = bRule.isAllowlist();
                        if (_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.browserCookieApi.removeCookie(cookie.name, cookie.url)];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        if (_a) {
                            this.filteringLog.addCookieEvent({
                                tabId: tabId,
                                cookieName: cookie.name,
                                cookieValue: cookie.value,
                                cookieDomain: cookie.domain,
                                cookieRule: bRule,
                                isModifyingCookieRule: false,
                                thirdParty: isThirdPartyCookie,
                                timestamp: Date.now(),
                            });
                        }
                        return [2 /*return*/];
                    case 3:
                        mRules = CookieRulesFinder.lookupModifyingRules(cookieName, cookieRules, isThirdPartyCookie);
                        if (!(mRules.length > 0)) return [3 /*break*/, 5];
                        appliedRules = CookieFiltering.applyRuleToBrowserCookie(cookie, mRules);
                        if (!(appliedRules.length > 0)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.browserCookieApi.modifyCookie(cookie)];
                    case 4:
                        if (_b.sent()) {
                            appliedRules.forEach(function (r) {
                                _this.filteringLog.addCookieEvent({
                                    tabId: tabId,
                                    cookieName: cookie.name,
                                    cookieValue: cookie.value,
                                    cookieDomain: cookie.domain,
                                    cookieRule: r,
                                    isModifyingCookieRule: true,
                                    thirdParty: isThirdPartyCookie,
                                    timestamp: Date.now(),
                                });
                            });
                        }
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Modifies instance of BrowserCookie with provided rules
     *
     * @param cookie Cookie modify
     * @param rules Cookie matching rules
     * @return applied rules
     *
     */
    CookieFiltering.applyRuleToBrowserCookie = function (cookie, rules) {
        var appliedRules = [];
        for (var i = 0; i < rules.length; i += 1) {
            var rule = rules[i];
            if (rule.isAllowlist()) {
                appliedRules.push(rule);
                continue;
            }
            var cookieModifier = rule.getAdvancedModifier();
            var modified = false;
            var sameSite = cookieModifier.getSameSite();
            if (sameSite && cookie.sameSite !== sameSite) {
                // eslint-disable-next-line no-param-reassign
                cookie.sameSite = sameSite;
                modified = true;
            }
            var maxAge = cookieModifier.getMaxAge();
            if (maxAge) {
                if (CookieUtils.updateCookieMaxAge(cookie, maxAge)) {
                    modified = true;
                }
            }
            if (modified) {
                appliedRules.push(rule);
            }
        }
        return appliedRules;
    };
    return CookieFiltering;
}());



;// CONCATENATED MODULE: ./Extension/src/background/filter/services/cookie-service.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */





/**
 * Returns cookie rules matching request details
 *
 * @param tab
 * @param url
 * @param referrer
 * @return {NetworkRule[]}
 */

const getCookieRules = (tab, url, referrer) => {
  return webRequestService.getCookieRules(tab, url, referrer, request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT);
};
/**
 * Returns cookie rules data for content script
 *
 * Steps:
 * - content script requests matching cookie rules for the frame(in which this script is executed)
 * - service returns matching set of rules data to content script
 * - the rules are applied with TSUrlFilterContentScript.CookieController
 * - filtering log receives callback with applied rules data
 *
 * The important point is:
 * - there is no way to run cookie controller script via chrome.tabs.executeScript cause one only could be executed
 * for all frames or main frame only. But it's not correct cause there should be different rules
 * for each frame.
 *
 * @param tab
 * @param url
 * @param referrer
 * @returns {Array|null} serialized rules data
 */

const getCookieRulesDataForContentScript = (tab, url, referrer) => {
  const cookieRules = getCookieRules(tab, url, referrer);

  if (!cookieRules) {
    return null;
  }

  const blockingRules = cookieRules.filter(rule => {
    const cookieModifier = rule.getAdvancedModifier();
    return !cookieModifier.getSameSite() && !cookieModifier.getMaxAge();
  });
  return blockingRules.map(rule => {
    return {
      ruleText: rule.getText(),
      match: rule.getAdvancedModifierValue(),
      isThirdParty: rule.isOptionEnabled(es/* NetworkRuleOption.ThirdParty */.SJ.ThirdParty),
      filterId: rule.getFilterListId(),
      isAllowlist: rule.isAllowlist()
    };
  });
};
/**
 * Cookie filtering service
 */

const cookieService = new CookieFiltering(filtering_log_browsers);
;// CONCATENATED MODULE: ./node_modules/@adguard/tsurlfilter/dist/es/headers-service.js


/**
 * Headers filtering service module
 */
var HeadersService = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param filteringLog
     */
    function HeadersService(filteringLog) {
        this.filteringLog = filteringLog;
    }
    /**
     * On before send headers handler.
     * Removes request headers.
     *
     * @param details
     * @param rules
     * @return if headers modified
     */
    HeadersService.prototype.onBeforeSendHeaders = function (details, rules) {
        var _this = this;
        if (!details.requestHeaders) {
            return false;
        }
        if (rules.length === 0) {
            return false;
        }
        var result = false;
        rules.forEach(function (rule) {
            if (HeadersService.applyRule(details.requestHeaders, rule, true)) {
                result = true;
                _this.filteringLog.addRemoveHeaderEvent(details.tabId, details.url, rule.getAdvancedModifierValue(), rule);
            }
        });
        return result;
    };
    /**
     * On headers received handler.
     * Remove response headers.
     *
     * @param details
     * @param rules
     * @return if headers modified
     */
    HeadersService.prototype.onHeadersReceived = function (details, rules) {
        var _this = this;
        if (!details.responseHeaders) {
            return false;
        }
        if (rules.length === 0) {
            return false;
        }
        var result = false;
        rules.forEach(function (rule) {
            if (HeadersService.applyRule(details.responseHeaders, rule, false)) {
                result = true;
                _this.filteringLog.addRemoveHeaderEvent(details.tabId, details.url, rule.getAdvancedModifierValue(), rule);
            }
        });
        return result;
    };
    /**
     * Applies rule to headers
     *
     * @param headers
     * @param rule
     * @param isRequestHeaders
     */
    HeadersService.applyRule = function (headers, rule, isRequestHeaders) {
        var modifier = rule.getAdvancedModifier();
        if (!modifier) {
            return false;
        }
        var headerName = modifier.getApplicableHeaderName(isRequestHeaders);
        if (!headerName) {
            return false;
        }
        return removeHeader(headers, headerName);
    };
    return HeadersService;
}());



;// CONCATENATED MODULE: ./Extension/src/background/filter/services/headers-service.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */





/**
 * Returns $removeheader rules matching request details
 *
 * @param tab
 * @param url
 * @param referrer
 * @return {NetworkRule[]}
 */

const getRemoveHeaderRules = (tab, url, referrer) => {
  return filteringApi.getRemoveHeaderRules({
    requestUrl: url,
    frameUrl: referrer,
    requestType: request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT,
    frameRule: frames_frames.getFrameRule(tab)
  });
};
/**
 * Headers filtering service
 */

const headersService = new HeadersService(filtering_log_browsers);
;// CONCATENATED MODULE: ./Extension/src/background/content-filtering/content-filtering.chrome.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */
const chromeContentFiltering = undefined;
/* harmony default export */ const content_filtering_chrome = (chromeContentFiltering);
;// CONCATENATED MODULE: ./Extension/src/background/webrequest.js



/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */

/* eslint-disable max-len */




















const webrequestInit = function () {
  const CSP_HEADER_NAME = 'Content-Security-Policy';
  /**
   * In the case of the tabs.insertCSS API support we're trying to collapse a blocked element from the background page.
   * In order to do it we need to have a mapping requestType<->tagNames.
   */

  const REQUEST_TYPE_COLLAPSE_TAG_NAMES = {
    [request_types/* RequestTypes.SUBDOCUMENT */.l.SUBDOCUMENT]: ['frame', 'iframe'],
    [request_types/* RequestTypes.IMAGE */.l.IMAGE]: ['img']
  };
  /**
   * In the newer versions of Firefox and Chromium we're able to inject CSS and scripts
   * using a better approach -- `browser.tabs.insertCSS` and `browser.tabs.executeScript`
   * instead of the traditional one (messaging to the content script).
   */

  const shouldUseInsertCSSAndExecuteScript = prefs.features.canUseInsertCSSAndExecuteScript;
  /**
   * Retrieve referrer url from request details.
   * Extract referrer by priority:
   * 1. referrerUrl in requestDetails
   * 2. url of frame where request was created
   * 3. url of main frame
   *
   * @param requestDetails
   * @returns {*|Frame}
   */

  function getReferrerUrl(requestDetails) {
    return requestDetails.referrerUrl || frames_frames.getFrameUrl(requestDetails.tab, requestDetails.requestFrameId) || frames_frames.getMainFrameUrl(requestDetails.tab);
  }
  /**
   * Process request
   *
   * @param {RequestDetails} requestDetails
   * @returns {boolean|{Object}} False if request must be blocked, object if url was redirected
   */


  function onBeforeRequest(requestDetails) {
    var _requestRule;

    if (backgroundPage.app.isOwnRequest(requestDetails.referrerUrl)) {
      return;
    }

    const {
      tab,
      requestId,
      originUrl,
      requestType,
      frameId,
      requestFrameId = 0,
      method
    } = requestDetails;
    const {
      tabId
    } = tab;
    let {
      requestUrl
    } = requestDetails;

    if (requestType === request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT || requestType === request_types/* RequestTypes.SUBDOCUMENT */.l.SUBDOCUMENT) {
      frames_frames.recordFrame(tab, frameId, requestUrl, requestType);
    }

    if (requestType === request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT) {
      // Reset tab button state
      listeners.notifyListeners(listeners.UPDATE_TAB_BUTTON_STATE, tab, true);
      /**
       * Just to remember!
       * In the case of the "about:newtab" pages we don't receive onResponseReceived event for the main_frame
       * Also if chrome://newtab is overwritten, we won't receive any webRequest events for the main_frame
       * Unfortunately, we can't do anything in this case and just must remember about it
       */

      /**
       * Binds rule to the main_frame request
       * In integration mode, rule from the headers will override this value
       */

      const tabRequestRule = frames_frames.getFrameRule(tab);

      if (tabRequestRule) {
        requestContextStorage.update(requestId, {
          requestRule: tabRequestRule
        });
      }
    }

    if (!utils.url.isHttpOrWsRequest(requestUrl)) {
      // Do not mess with other extensions
      return;
    }

    const referrerUrl = getReferrerUrl(requestDetails); // truncate too long urls
    // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1493

    const MAX_URL_LENGTH = 1024 * 16;

    if (requestUrl.length > MAX_URL_LENGTH) {
      requestUrl = requestUrl.slice(0, MAX_URL_LENGTH);
    } // Record request for other types


    const context = requestContextStorage.record({
      requestId,
      requestUrl,
      referrerUrl,
      originUrl,
      // TODO: use single requestType field
      requestType,
      engineRequestType: request_types/* RequestTypes.transformRequestType */.l.transformRequestType(requestType),
      tab,
      method
    });
    let requestRule = webRequestService.getRuleForRequest(tab, requestUrl, referrerUrl, requestType);

    if (!((_requestRule = requestRule) !== null && _requestRule !== void 0 && _requestRule.isDocumentAllowlistRule())) {
      cookieService.onBeforeRequest(requestDetails, getCookieRules(tab, requestUrl, referrerUrl) || []);
    }

    requestRule = webRequestService.postProcessRequest(tab, requestUrl, referrerUrl, requestType, requestRule);

    if (requestRule) {
      requestContextStorage.update(requestId, {
        requestRule
      });
    }

    if (requestRule && !requestRule.isAllowlist() && requestRule.isOptionEnabled(es/* NetworkRuleOption.Popup */.SJ.Popup) && requestType === request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT) {
      const isNewTab = tabsApi.isNewPopupTab(tabId);

      if (isNewTab) {
        tabsApi.remove(tabId);
        return {
          cancel: true
        };
      }
    }

    const response = webRequestService.getBlockedResponseByRule(requestRule, requestType, requestUrl);

    if (!response) {
      /*
       Strip url by $removeparam rules
       $removeparam rules are applied after URL blocking rules
       https://github.com/AdguardTeam/CoreLibs/issues/1462
      */
      const cleansedUrl = webRequestService.removeParamFromUrl(tab, requestUrl, referrerUrl, requestType, method);

      if (cleansedUrl) {
        return {
          redirectUrl: cleansedUrl
        };
      }
    }

    if (response && response.documentBlockedPage) {
      // Here we do not use redirectUrl because it is not working in firefox without specifying it
      // as the web_accessible_resources.
      documentFilterService.showDocumentBlockPage(tabId, response.documentBlockedPage);
      return {
        cancel: true
      };
    }

    if (response && response.cancel) {
      collapseElement(tabId, requestFrameId, requestUrl, referrerUrl, requestType);
    } // Content filtering will be undefined for chromium based builds
    // Do not launch content filtering for blocked requests


    if (!(response !== null && response !== void 0 && response.cancel) && content_filtering_chrome) {
      const replaceRules = webRequestService.getReplaceRules(tab, requestUrl, referrerUrl, requestType) || [];
      const htmlRules = webRequestService.getContentRules(tab, referrerUrl) || [];

      if (replaceRules.length > 0 || htmlRules.length > 0) {
        const supportedStreamFilterRequestTypes = [request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT, request_types/* RequestTypes.SUBDOCUMENT */.l.SUBDOCUMENT, request_types/* RequestTypes.STYLESHEET */.l.STYLESHEET, request_types/* RequestTypes.SCRIPT */.l.SCRIPT, request_types/* RequestTypes.XMLHTTPREQUEST */.l.XMLHTTPREQUEST, request_types/* RequestTypes.OTHER */.l.OTHER];

        if (supportedStreamFilterRequestTypes.includes(requestType)) {
          content_filtering_chrome.onBeforeRequest(backgroundPage.webRequest.filterResponseData(requestId), context, replaceRules || [], htmlRules || []);
        }
      }
    }

    return response;
  }
  /**
   * Tries to collapse a blocked element using tabs.insertCSS.
   *
   * This method of collapsing has numerous advantages over the traditional one.
   * First of all, it prevents blocked elements flickering as it occurs earlier.
   * Second, it is harder to detect as there's no custom <style> node required.
   *
   * However, we're still keeping the old approach intact - we have not enough information
   * here to properly collapse elements that use relative URLs (<img src='../path_to_element'>).
   *
   * @param {number} tabId Tab id
   * @param {number} requestFrameId Id of a frame request was sent from
   * @param {string} requestUrl Request URL
   * @param {string} referrerUrl Referrer URL
   * @param {string} requestType A member of RequestTypes
   */


  function collapseElement(tabId, requestFrameId, requestUrl, referrerUrl, requestType) {
    if (!shouldUseInsertCSSAndExecuteScript) {
      return;
    }

    const tagNames = REQUEST_TYPE_COLLAPSE_TAG_NAMES[requestType];

    if (!tagNames) {
      // Collapsing is not supported for this request type
      return;
    } // Collapsing is not supported for the requests which happen out of the tabs, e.g. other extensions


    if (tabId === -1) {
      return;
    } // Strip the protocol and host name (for first-party requests) from the selector


    const thirdParty = es/* isThirdPartyRequest */.ag(requestUrl, referrerUrl);
    let srcUrlStartIndex = requestUrl.indexOf('//');

    if (!thirdParty) {
      srcUrlStartIndex = requestUrl.indexOf('/', srcUrlStartIndex + 2);
    }

    const srcUrl = requestUrl.substring(srcUrlStartIndex);
    const collapseStyle = '{ display: none!important; visibility: hidden!important; height: 0px!important; min-height: 0px!important; }';
    let css = '';
    let iTagNames = tagNames.length;

    while (iTagNames) {
      iTagNames -= 1;
      css += `${tagNames[iTagNames]}[src$="${srcUrl}"] ${collapseStyle}\n`;
    }

    tabsApi.insertCssCode(tabId, requestFrameId, css);
  }
  /**
   * Called before request is sent to the remote endpoint.
   * This method is used to modify headers for stealth service
   * and also to record referrer header in frame data.
   *
   * @param requestDetails Request details
   * @returns {*} headers to send
   */


  function onBeforeSendHeaders(requestDetails) {
    const {
      tab,
      requestId,
      requestUrl,
      requestType,
      requestHeaders
    } = requestDetails;
    requestContextStorage.update(requestId, {
      requestHeaders
    });
    let requestHeadersModified = false;

    if (requestType === request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT) {
      // Save ref header
      const refHeader = browserUtils.findHeaderByName(requestHeaders, 'Referer');

      if (refHeader) {
        frames_frames.recordFrameReferrerHeader(tab, refHeader.value);
      }
    }

    cookieService.onBeforeSendHeaders(requestDetails);

    if (stealthService.processRequestHeaders(requestId, requestHeaders)) {
      requestHeadersModified = true;
    }

    if (headersService.onBeforeSendHeaders(requestDetails, getRemoveHeaderRules(tab, requestUrl, getReferrerUrl(requestDetails)))) {
      requestHeadersModified = true;
    }

    if (requestHeadersModified) {
      requestContextStorage.update(requestId, {
        modifiedRequestHeaders: requestHeaders
      });
      return {
        requestHeaders
      };
    }

    return {};
  }
  /**
   * Safebrowsing check
   *
   * @param tab
   * @param mainFrameUrl
   */


  async function filterSafebrowsing(tab, mainFrameUrl) {
    if (frames_frames.isTabProtectionDisabled(tab) || frames_frames.isTabAllowlistedForSafebrowsing(tab)) {
      return;
    }

    const referrerUrl = browserUtils.getSafebrowsingBackUrl(tab);
    const incognitoTab = frames_frames.isIncognitoTab(tab);
    const safebrowsingUrl = await safebrowsing_browsers.checkSafebrowsingFilter(mainFrameUrl, referrerUrl);

    if (!safebrowsingUrl) {
      return;
    } // Chrome doesn't allow open extension url in incognito mode


    if (incognitoTab && browserUtils.isChromium()) {
      // Closing tab before opening a new one may lead to browser crash (Chromium)
      uiService.openTab(safebrowsingUrl).then(() => {
        tabsApi.remove(tab.tabId);
      });
    } else {
      tabsApi.reload(tab.tabId, safebrowsingUrl);
    }
  }
  /**
   * On headers received callback function.
   * We do check request for safebrowsing
   * and check if websocket connections should be blocked.
   * Do not make this function async, otherwise csp rules won't apply in time
   *
   * @param requestDetails Request details
   * @returns {{responseHeaders: *}} Headers to send
   */


  function onHeadersReceived(requestDetails) {
    const {
      tab,
      requestUrl,
      requestType,
      requestId,
      statusCode
    } = requestDetails;
    let responseHeaders = requestDetails.responseHeaders || [];
    const referrerUrl = getReferrerUrl(requestDetails);
    const contentType = browserUtils.getHeaderValueByName(responseHeaders, 'content-type');
    requestContextStorage.update(requestId, {
      responseHeaders,
      statusCode,
      contentType
    });
    webRequestService.processRequestResponse(tab, requestUrl, referrerUrl, requestType, responseHeaders); // Safebrowsing check

    if (requestType === request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT // Don't apply safebrowsing filter in case of redirect
    // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/995
    && statusCode !== 301 && statusCode !== 302) {
      // Do not await function bellow, otherwise csp rules won't apply in time
      // Issue AG-6230
      filterSafebrowsing(tab, requestUrl);
    }

    let responseHeadersModified = false;

    if (requestType === request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT || requestType === request_types/* RequestTypes.SUBDOCUMENT */.l.SUBDOCUMENT) {
      const cspHeaders = getCSPHeaders(requestDetails);

      if (cspHeaders && cspHeaders.length > 0) {
        responseHeaders = responseHeaders.concat(cspHeaders);
        responseHeadersModified = true;
      }
    }

    if (cookieService.onHeadersReceived(requestDetails)) {
      responseHeadersModified = true;
    }

    if (headersService.onHeadersReceived(requestDetails, getRemoveHeaderRules(tab, requestUrl, referrerUrl))) {
      responseHeadersModified = true;
    }

    if (responseHeadersModified) {
      requestContextStorage.update(requestId, {
        modifiedResponseHeaders: responseHeaders
      });
      return {
        responseHeaders
      };
    }
  }
  /**
   * Modify CSP header to block WebSocket, prohibit data: and blob: frames and WebWorkers
   * @param requestDetails
   * @returns {{responseHeaders: *}} CSP headers
   */


  function getCSPHeaders(requestDetails) {
    // Please note, that we do not modify response headers in Edge before Creators update:
    // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/401
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8796739/
    if (browserUtils.isEdgeBeforeCreatorsUpdate()) {
      return;
    }

    const {
      tab
    } = requestDetails;
    const {
      requestId
    } = requestDetails;
    const {
      requestUrl
    } = requestDetails;
    const {
      requestType
    } = requestDetails;
    const frameUrl = frames_frames.getFrameUrl(tab, requestDetails.frameId);
    const cspHeaders = [];
    /**
     * Retrieve $CSP rules specific for the request
     * https://github.com/adguardteam/adguardbrowserextension/issues/685
     */

    const cspRules = webRequestService.getCspRules(tab, requestUrl, frameUrl, requestType);

    if (cspRules) {
      for (let i = 0; i < cspRules.length; i += 1) {
        const rule = cspRules[i]; // Don't forget: getCspRules returns all $csp rules, we must directly check that the rule is blocking.

        if (webRequestService.isRequestBlockedByRule(rule)) {
          cspHeaders.push({
            name: CSP_HEADER_NAME,
            value: rule.getAdvancedModifierValue()
          });
        }
      }

      if (cspRules.length > 0) {
        requestContextStorage.update(requestId, {
          cspRules
        });
      }
    }
    /**
     * Websocket connection is blocked by connect-src directive
     * https://www.w3.org/TR/CSP2/#directive-connect-src
     *
     * Web Workers is blocked by child-src directive
     * https://www.w3.org/TR/CSP2/#directive-child-src
     * https://www.w3.org/TR/CSP3/#directive-worker-src
     * We have to use child-src as fallback for worker-src, because it isn't supported
     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/worker-src#Browser_compatibility
     *
     * We also need the frame-src restriction since CSPs are not inherited from the parent for documents with data: and blob: URLs
     * https://bugs.chromium.org/p/chromium/issues/detail?id=513860
     */


    return cspHeaders;
  }
  /**
   * Intercepts csp_report requests.
   * Check the URL of the report.
   * For chromium and firefox:
   * If it's sent to a third party, block it right away.
   * For firefox only:
   * If it contains moz://extension with our extension ID, block it as well.
   * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1792
   * @param {RequestDetails} details
   * @returns {{cancel: boolean}}
   */


  function handleCspReportRequests(details) {
    const {
      requestBody,
      requestUrl,
      originUrl,
      requestId,
      referrerUrl,
      requestType,
      tab
    } = details;
    const requestContext = requestContextStorage.get(requestId);

    if (!requestContext) {
      // Record request for other types
      requestContextStorage.record({
        requestId,
        requestUrl,
        referrerUrl,
        originUrl,
        requestType,
        tab
      });
    } // block if request is third party


    const thirdParty = es/* isThirdPartyRequest */.ag(requestUrl, originUrl);

    if (frames_frames.shouldStopRequestProcess(tab)) {
      return;
    }

    if (thirdParty) {
      requestContextStorage.update(requestId, {
        cspReportBlocked: true
      });
      return {
        cancel: true
      };
    } // block if requestBody contains moz://extension with our extension ID


    if (browserUtils.isFirefoxBrowser()) {
      try {
        const extensionUrl = backgroundPage.app.getExtensionUrl();
        const report = String.fromCharCode.apply(null, new Uint8Array(requestBody.raw[0].bytes));

        if (report.indexOf(extensionUrl) !== -1) {
          requestContextStorage.update(requestId, {
            cspReportBlocked: true
          });
          return {
            cancel: true
          };
        }
      } catch (e) {
        log/* log.debug */.c.debug('Unable to parse CSP report request body content', details.url);
      }
    }
  }
  /**
   * Add listeners described above.
   */


  backgroundPage.webRequest.onBeforeRequest.addListener(onBeforeRequest, ['<all_urls>']);
  /**
   * Handler for csp reports urls
   */

  backgroundPage.webRequest.onBeforeRequest.addListener(handleCspReportRequests, ['<all_urls>'], ['csp_report'], ['requestBody']);
  backgroundPage.webRequest.onBeforeSendHeaders.addListener(onBeforeSendHeaders, ['<all_urls>']);
  backgroundPage.webRequest.onHeadersReceived.addListener(onHeadersReceived, ['<all_urls>']);
  /**
   * If page uses service worker then it can do not fire main DOCUMENT request, that's why we check
   * frame data before scripts are injected
   * This listener should be added before any other listener of onCommitted event
   * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1459
   * @param details
   */

  const onCommittedCheckFrameUrl = details => {
    const {
      tab,
      requestType,
      frameId,
      requestUrl
    } = details;

    if (requestType !== request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT || tab.tabId === BACKGROUND_TAB_ID) {
      return;
    }

    frames_frames.checkAndRecordMainFrame(tab, frameId, requestUrl, requestType);
  };

  backgroundPage.webNavigation.onCommitted.addListener(onCommittedCheckFrameUrl);
  let handlerBehaviorTimeout = null;
  listeners.addListener(event => {
    switch (event) {
      case listeners.ADD_RULES:
      case listeners.REMOVE_RULE:
      case listeners.UPDATE_FILTER_RULES:
      case listeners.UPDATE_ALLOWLIST_FILTER_RULES:
      case listeners.FILTER_ENABLE_DISABLE:
        if (handlerBehaviorTimeout !== null) {
          clearTimeout(handlerBehaviorTimeout);
        }

        handlerBehaviorTimeout = setTimeout(() => {
          handlerBehaviorTimeout = null;
          backgroundPage.webRequest.handlerBehaviorChanged();
        }, 3000);
        break;

      default: // do noting

    }
  });

  if (shouldUseInsertCSSAndExecuteScript) {
    /**
     * Applying CSS/JS rules from the background page.
     * This function implements the algorithm suggested here: https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1029
     * For faster script injection, we prepare scriptText onHeadersReceived event (we can't use onBeforeRequest
     * event because we can't detect adguard application headers early in order to know should extension inject scripts or no),
     * save it and try to inject twice:
     * first time onResponseStarted event - this event fires early, but is not reliable
     * second time onCommitted event - this event fires on when part of document has been received, this event is reliable
     * Every time we try to inject script we check if script wasn't yet executed
     * We use browser.tabs.insertCSS and browser.tabs.executeScript functions to inject our CSS/JS rules.
     * This method can be used in modern Chrome and FF only.
     * Bellow are presented rough event flows in Chrome and Firefox
     * This flows are were tested for Chrome 67.0.3396.87 (64 bit) and Firefox 60.0.2 (64-bit)
     * FLOWS MAY BE MODIFIED IN THE FUTURE
     *
                                            Chrome flow description
                                         +--------------------------------+
                                        |                                |
                                        | webRequest.onHeadersReceived   |     Prepare injection
                                        |                                |
                                        +---------------+----------------+
                                                        |
                                        +---------------v--------------+
                                        |                              |
                                        | webRequest.onResponseStarted |     Try to inject JS
                                        |                              |
                                        +------------------------------+
         onCommitted event belongs to     +------------------------------+
        WebNavigation events and fires   |                              |
        independently from               | webNavigation.onCommitted    |     Inject JS and CSS
        onResponseStarted event.         |                              |     Remove injection
        Thats why we try to inject       +------------------------------+
        two times
                                        +------------------------------+
                                        |                              |
                                        | webRequest.onErrorOccured    |     Remove injections on error
                                        |                              |
                                        +------------------------------+
                                             Firefox flow description
         onCommitted event in Firefox for +------------------------------+
        sub_frames fires before          |                              |
        onHeadersReceived event          | webNavigation.onCommitted     |
        That's why we inject our code    |                              |
        on onCompletedEvent              +------------------------------+
                                         +--------------------------------+
                                        |                                |
                                        | webRequest.onHeadersReceived   |      Prepare injection
                                        |                                |
                                        +--------------+-----------------+
                                                       |
                                        +--------------v---------------+
                                        |                              |
                                        | webRequest.onResponseStarted |      Try to inject JS code
                                        |                              |
                                        +------------------------------+
                                         +------------------------------+
                                        |                              |
                                        | webNavigation.onCommitted     |      Inject JS and CSS for main_frame
                                        |                              |      Remove injection
                                        +------------------------------+
                                         +------------------------------+
                                        |                              |
                                        | webRequest.onCompleted       |      Inject JS and CSS for sub_frame
                                        |                              |      Remove injection
                                        +------------------------------+
                                         +------------------------------+
                                        |                              |
                                        | webRequest.onErrorOccured    |     Remove injections on error
                                        |                              |
                                        +------------------------------+
        On tab close we clear our injections for corresponding tab
        Also our injections removes old injections for iframes when user navigates to other page in the same tab
         In Firefox and Chrome if page has iframes without remote source we can not get rules for this iframe with usual methods,
        That's why we get rules for main frame and inject them.
                                        +- ----------------------------------+
                                        |                                    |     Get injection for main iframe
                                        |  webNavigation.onDOMContentLoaded  |     inject it in the frame without
                                        |                                    |     remote source
                                        +- ----------------------------------+
     */
    (function () {
      /**
       * This object is used:
       * 1. to save js and css texts when onHeadersReceived event fires
       * by key corresponding to tabId and frameId
       * 2. to get js and css texts for injection
       * After injection corresponding js and css texts are removed from the object
       */
      const injections = {
        /**
         * @typedef Injection
         * @property {Boolean} ready value depends on are css and js texts ready or not. If false we should retry get them later
         * @property {String} [jsScriptText] prepared JS code text for injection
         * @property {String} [cssText] prepared CSS code text for injection
         */

        /**
         * Saves css, js and ready flag in injection object
         * @param tabId
         * @param frameId
         * @param {Injection} injection
         */
        set(tabId, frameId, injection) {
          if (frameId === 0) {
            delete this[tabId];
          }

          if (!this[tabId]) {
            this[tabId] = {};
          }

          this[tabId][frameId] = injection;
        },

        get(tabId, frameId) {
          if (this[tabId]) {
            return this[tabId][frameId];
          }

          return undefined;
        },

        /**
         * Removes injection corresponding to tabId and frameId
         * @param {Number} tabId
         * @param {Number} frameId
         */
        removeTabFrameInjection(tabId, frameId) {
          if (this[tabId]) {
            delete this[tabId][frameId];

            if (Object.keys(this[tabId]).length === 0) {
              delete this[tabId];
            }
          }
        },

        /**
         * Removes all injections corresponding to tabId
         * @param {Number} tabId
         */
        removeTabInjection(tabId) {
          delete this[tabId];
        }

      };
      /**
       * Taken from
       * {@link https://github.com/seanl-adg/InlineResourceLiteral/blob/master/index.js#L136}
       * {@link https://github.com/joliss/js-string-escape/blob/master/index.js}
       */

      const reJsEscape = /["'\\\n\r\u2028\u2029]/g;

      function escapeJs(match) {
        switch (match) {
          case '"':
          case "'":
          case '\\':
            return `\\${match}`;

          case '\n':
            return '\\n\\\n';
          // Line continuation character for ease
          // of reading inlined resource.

          case '\r':
            return '';
          // Carriage returns won't have
          // any semantic meaning in JS

          case '\u2028':
            return '\\u2028';

          case '\u2029':
            return '\\u2029';

          default: // do nothing

        }
      }
      /**
       * We use changing variable name because global properties
       * can be modified across isolated worlds of extension content page and tab page
       * https://bugs.chromium.org/p/project-zero/issues/detail?id=1225&desc=6
       */


      const variableName = `scriptExecuted${Date.now()}`;

      function buildScriptText(scriptText) {
        if (!scriptText) {
          return null;
        }
        /**
         * Executes scripts in a scope of the page.
         * In order to prevent multiple script execution checks if script was already executed
         * Sometimes in Firefox when content-filtering is applied to the page race condition happens.
         * This causes an issue when the page doesn't have its document.head or document.documentElement at the moment of
         * injection. So script waits for them. But if a quantity of frame-requests reaches FRAME_REQUESTS_LIMIT then
         * script stops waiting with the error.
         * Description of the issue: https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1004
         */


        const injectedScript = `(function() {\
                    if (window.${variableName}) {\
                        return;\
                    }\
                    var script = document.createElement("script");\
                    script.setAttribute("type", "text/javascript");\
                    script.textContent = "${scriptText.replace(reJsEscape, escapeJs)}";\
                    var FRAME_REQUESTS_LIMIT = 500;\
                    var frameRequests = 0;\
                    function waitParent () {\
                        frameRequests += 1;\
                        var parent = document.head || document.documentElement;\
                        if (parent) {\
                            try {\
                                parent.appendChild(script);\
                                parent.removeChild(script);\
                            } catch (e) {\
                            } finally {\
                                window.${variableName} = true;\
                                return true;\
                            }\
                        }\
                        if(frameRequests < FRAME_REQUESTS_LIMIT) {\
                            requestAnimationFrame(waitParent);\
                        } else {\
                            console.log("AdGuard: document.head or document.documentElement were unavailable too long");\
                        }\
                    }\
                    waitParent();\
                })()`;
        return injectedScript;
      }
      /**
       * @param {SelectorsData} selectorsData Selectors data
       * @returns {string} CSS to be supplied to insertCSS or null if selectors data is empty
       */


      function buildCssText(selectorsData) {
        if (!selectorsData || !selectorsData.css) {
          return null;
        }

        return selectorsData.css.join('\n');
      }
      /**
       * Checks requestType, tabId and event
       * We don't inject CSS or JS if request wasn't related to tab, or if request type
       * is not equal to DOCUMENT or SUBDOCUMENT.
       * @param {String} requestType
       * @param {Number} tabId
       * @param {String} eventName
       * @returns {Boolean}
       */


      function shouldSkipInjection(requestType, tabId, eventName) {
        /**
         * onCompleted event is used only to inject code to the Firefox iframes
         * because in current Firefox implementation webNavigation.onCommitted event for iframes
         * occures early than webRequest.onHeadersReceived event
         * if onCompleted event fired with requestType DOCUMENT then we skip it, because we
         * use onCompleted event only for SUBDOCUMENTS
         */
        if (eventName === 'onCompleted' && requestType === request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT) {
          return true;
        }

        if (tabId === BACKGROUND_TAB_ID) {
          return true;
        }

        if (requestType !== request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT && requestType !== request_types/* RequestTypes.SUBDOCUMENT */.l.SUBDOCUMENT) {
          return true;
        }

        return false;
      }

      const REQUEST_FILTER_READY_TIMEOUT = 100;
      /**
       * Prepares injection content (scripts and css) for a given frame.
       * @param {RequestDetails} details
       */

      function prepareInjection(details) {
        const {
          requestType
        } = details;
        const {
          tab
        } = details;
        const {
          tabId
        } = tab;

        if (shouldSkipInjection(requestType, tabId)) {
          return;
        }

        const {
          frameId
        } = details;
        const url = details.requestUrl;
        const result = webRequestService.processGetSelectorsAndScripts({
          tabId
        }, url, true);

        if (result.requestFilterReady === false) {
          injections.set(tabId, frameId, {
            ready: false
          });
        } else {
          injections.set(tabId, frameId, {
            ready: true,
            jsScriptText: buildScriptText(result.scripts),
            cssText: buildCssText(result.selectors),
            url
          });
        }
      }
      /**
       * Injects js code in the page on responseStarted event only if event was fired from the main_frame
       * @param {RequestDetails} details Details about the webrequest event
       */


      function tryInjectOnResponseStarted(details) {
        const {
          tab
        } = details;
        const {
          tabId
        } = tab;
        const {
          requestType
        } = details;
        const {
          frameId
        } = details;

        if (shouldSkipInjection(requestType, tabId)) {
          return;
        }

        const injection = injections.get(tabId, frameId);

        if (injection && injection.jsScriptText) {
          // grep "localScriptRulesService" for details about script source
          tabsApi.executeScriptCode(tabId, frameId, injection.jsScriptText);
        }
      }
      /**
       * Function checks if injection corresponds to url
       * This check could be useful when injections were prepared in the onBeforeRequest
       * or onHeadersReceived events and then there was redirection and document request
       * didn't fired in webRequest events
       * @param injection
       * @param url
       * @returns {boolean}
       */


      function isInjectionForUrl(injection, url) {
        return injection && injection.url === url;
      }
      /**
       * Injects necessary CSS and scripts into the web page.
       * @param {RequestDetails} details Details about the navigation event
       * @param {String} eventName Event name
       */


      function tryInject(details, eventName) {
        const {
          tab
        } = details;
        const {
          tabId
        } = tab;
        const {
          frameId
        } = details;
        const {
          requestType
        } = details;
        const frameUrl = details.requestUrl;

        if (shouldSkipInjection(requestType, tabId, eventName)) {
          return;
        }

        const injection = injections.get(tabId, frameId);

        if (injection && !injection.ready) {
          /**
           * If injection is not ready yet, we call prepareScripts and tryInject functions again
           * setTimeout callback lambda function accepts onCommitted details and eventName
           */
          setTimeout((details, eventName) => {
            prepareInjection(details);
            tryInject(details, eventName);
          }, REQUEST_FILTER_READY_TIMEOUT, details, eventName);
          injections.removeTabFrameInjection(tabId, frameId);
          return;
        }
        /**
         * webRequest api doesn't see requests served from service worker like they are served from the cache
         * https://bugs.chromium.org/p/chromium/issues/detail?id=766433
         * that's why we can't prepare injections when webRequest events fire
         * also we should check if injection url is correct
         * so we try to prepare this injection in the onCommit event again
         */


        if (requestType === request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT && (!injection || !isInjectionForUrl(injection, frameUrl))) {
          prepareInjection(details);
          tryInject(details, eventName);
          return;
        }
        /**
         * Sometimes it can happen that onCommitted event fires earlier than onHeadersReceived
         * for example onCommitted event for iframes in Firefox
         */


        if (!injection) {
          return;
        }

        if (injection.jsScriptText) {
          // grep "localScriptRulesService" for details about script source
          tabsApi.executeScriptCode(tabId, frameId, injection.jsScriptText);
        }

        if (injection.cssText) {
          tabsApi.insertCssCode(tabId, frameId, injection.cssText);
        }

        const mainFrameUrl = frames_frames.getMainFrameUrl({
          tabId
        });

        if (isIframeWithoutSrc(frameUrl, frameId, mainFrameUrl)) {
          log/* log.warn */.c.warn('Unexpected onCommitted event from this frame - frameId: {0}, frameUrl: {1}. See https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1046', frameId, frameUrl);
        }

        injections.removeTabFrameInjection(tabId, frameId);
      }
      /**
       * Removes injection if onErrorOccured event fires for corresponding tabId and frameId
       * @param {RequestDetails} details
       */


      function removeInjection(details) {
        const {
          requestType
        } = details;
        const {
          tab
        } = details;
        const {
          tabId
        } = tab;

        if (shouldSkipInjection(requestType, tabId)) {
          return;
        }

        const {
          frameId
        } = details;
        injections.removeTabFrameInjection(tabId, frameId);
      }
      /**
       * Checks if iframe does not have a remote source
       * or is src is about:blank, javascript:'', etc
       * We don't include iframes with 'src=data:' because chrome and firefox don't allow to inject
       * in iframes with this type of src, this bug is reported here
       * https://bugs.chromium.org/p/chromium/issues/detail?id=55084
       * @param {string} frameUrl url
       * @param {number} frameId unique id of frame in the tab
       * @param {string} mainFrameUrl url of tab where iframe exists
       */


      function isIframeWithoutSrc(frameUrl, frameId, mainFrameUrl) {
        return (frameUrl === mainFrameUrl || frameUrl === 'about:blank' || frameUrl === 'about:srcdoc' // eslint-disable-next-line no-script-url
        || frameUrl.indexOf('javascript:') > -1) && frameId !== MAIN_FRAME_ID;
      }
      /**
       * This method injects css and js code in iframes without remote source
       * Usual webRequest callbacks don't fire for iframes without remote source
       * Also urls in these iframes may be "about:blank", "about:srcdoc", etc.
       * Due to this reason we prepare injections for them as for mainframe
       * and inject them only when onDOMContentLoaded fires
       * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1046
       * @param {{tabId: Number, url: String, processId: Number, frameId: Number, timeStamp: Number}} details
       */


      function tryInjectInIframesWithoutSrc(details) {
        const {
          frameId,
          tabId,
          url: frameUrl
        } = details;
        /**
         * Get url of the tab where iframe exists
         */

        const mainFrameUrl = frames_frames.getMainFrameUrl({
          tabId
        });

        if (mainFrameUrl && isIframeWithoutSrc(frameUrl, frameId, mainFrameUrl)) {
          const result = webRequestService.processGetSelectorsAndScripts({
            tabId
          }, mainFrameUrl, true);

          if (result.requestFilterReady === false) {
            setTimeout(details => {
              tryInjectInIframesWithoutSrc(details);
            }, REQUEST_FILTER_READY_TIMEOUT, details);
            return;
          }

          const jsScriptText = buildScriptText(result.scripts);
          const cssText = buildCssText(result.selectors);

          if (jsScriptText) {
            // grep "localScriptRulesService" for details about script source
            tabsApi.executeScriptCode(tabId, frameId, jsScriptText);
          }

          if (cssText) {
            tabsApi.insertCssCode(tabId, frameId, cssText);
          }
        }
      }
      /**
       * https://developer.chrome.com/extensions/webRequest
       * https://developer.chrome.com/extensions/webNavigation
       */


      backgroundPage.webRequest.onHeadersReceived.addListener(prepareInjection, ['<all_urls>']);
      backgroundPage.webRequest.onResponseStarted.addListener(tryInjectOnResponseStarted, ['<all_urls>']);
      backgroundPage.webNavigation.onCommitted.addListener(tryInject);
      backgroundPage.webRequest.onErrorOccurred.addListener(removeInjection, ['<all_urls>']);
      backgroundPage.webNavigation.onDOMContentLoaded.addListener(tryInjectInIframesWithoutSrc); // In the current Firefox version (60.0.2), the onCommitted even fires earlier than
      // onHeadersReceived for SUBDOCUMENT requests
      // This is true only for SUBDOCUMENTS i.e. iframes
      // so we inject code when onCompleted event fires

      if (browserUtils.isFirefoxBrowser()) {
        backgroundPage.webRequest.onCompleted.addListener(details => {
          tryInject(details, 'onCompleted');
        }, ['<all_urls>']);
      } // Remove injections when tab is closed


      tabsApi.onRemoved.addListener(injections.removeTabInjection);
    })();
  }
  /**
   * Request context recording
   */


  backgroundPage.webRequest.onCompleted.addListener(requestDetails => {
    const {
      requestId,
      statusCode
    } = requestDetails;
    cookieService.onCompleted(requestDetails);

    if (statusCode) {
      requestContextStorage.onRequestCompleted(requestId, statusCode);
    } else {
      requestContextStorage.onRequestCompleted(requestId);
    }
  }, ['<all_urls>']);
  backgroundPage.webRequest.onErrorOccurred.addListener(requestDetails => {
    cookieService.onErrorOccurred(requestDetails);
    requestContextStorage.onRequestCompleted(requestDetails.requestId);
  }, ['<all_urls>']);
  /**
   * Handles redirect separately:
   * If a request is redirected to a data:// URL, onBeforeRedirect is the last reported event.
   * https://developer.chrome.com/extensions/webRequest#life_cycle
   */

  backgroundPage.webRequest.onBeforeRedirect.addListener(({
    requestId,
    redirectUrl
  }) => {
    if (redirectUrl && redirectUrl.indexOf('data:') === 0) {
      requestContextStorage.onRequestCompleted(requestId);
    }
  }, ['<all_urls>']);
  /**
   * Subscribe script is executed when onCommitted event fires,
   * because this event is the most reliable
   */

  backgroundPage.webNavigation.onCommitted.addListener(details => {
    const {
      tab,
      requestType,
      frameId
    } = details;

    if (requestType !== request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT && requestType !== request_types/* RequestTypes.SUBDOCUMENT */.l.SUBDOCUMENT || tab.tabId === BACKGROUND_TAB_ID) {
      return;
    } // load subscribe script on dom content load


    tabsApi.executeScriptFile(tab.tabId, {
      file: '/content-script/subscribe.js',
      frameId
    });
  });
};

const webrequest = {
  init: webrequestInit
};
;// CONCATENATED MODULE: ./Extension/src/background/filter/request-sanitizer.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */




/**
 * Request sanitizer helper
 * Removes track-able data from extension initiated requests
 */

const requestSanitizer = function () {
  /**
   * On before send headers listener
   *
   * @param req
   * @return {{requestHeaders: *}}
   */
  const safeFilter = req => {
    const {
      requestHeaders,
      initiator,
      tabId,
      originUrl
    } = req;

    if (tabId !== BACKGROUND_TAB_ID) {
      return;
    }

    let requestHeadersModified = false; // Chrome provides "initiator" and firefox "originUrl"

    const origin = initiator || originUrl;

    if (backgroundPage.app.isOwnRequest(origin)) {
      requestHeadersModified = browserUtils.removeHeader(requestHeaders, 'Cookie');
    }

    if (requestHeadersModified) {
      return {
        requestHeaders
      };
    }
  };

  const init = () => {
    // Firefox doesn't allow to use "extraHeaders" extra option,
    //  but chrome requires it in order to get access to "Cookie" header
    const onBeforeSendHeadersExtraInfoSpec = ['requestHeaders', 'blocking'];

    if (typeof extension_api_browser/* browser.webRequest.OnBeforeSendHeadersOptions */.X.webRequest.OnBeforeSendHeadersOptions !== 'undefined' && extension_api_browser/* browser.webRequest.OnBeforeSendHeadersOptions.hasOwnProperty */.X.webRequest.OnBeforeSendHeadersOptions.hasOwnProperty('EXTRA_HEADERS')) {
      onBeforeSendHeadersExtraInfoSpec.push('extraHeaders');
    }

    extension_api_browser/* browser.webRequest.onBeforeSendHeaders.addListener */.X.webRequest.onBeforeSendHeaders.addListener(safeFilter, {
      urls: ['<all_urls>'],
      tabId: BACKGROUND_TAB_ID
    }, onBeforeSendHeadersExtraInfoSpec);
  };

  return {
    init
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/filter/services/locale-detect.js
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */








/**
 * Initialize LocaleDetectService.
 *
 * This service is used to auto-enable language-specific filters.
 */

const localeDetect = function () {
  const browsingLanguages = [];
  const SUCCESS_HIT_COUNT = 3;
  const MAX_HISTORY_LENGTH = 10;
  const domainToLanguagesMap = {
    // Russian
    'ru': 'ru',
    'ua': 'ru',
    'by': 'ru',
    'kz': 'ru',
    // English
    'com': 'en',
    'au': 'en',
    'uk': 'en',
    'nz': 'en',
    // German
    'de': 'de',
    'at': 'de',
    // Japanese
    'jp': 'ja',
    // Dutch
    'nl': 'nl',
    // French
    'fr': 'fr',
    // Spanish
    'es': 'es',
    // Italian
    'it': 'it',
    // Portuguese
    'pt': 'pt',
    // Polish
    'pl': 'pl',
    // Czech
    'cz': 'cs',
    // Bulgarian
    'bg': 'bg',
    // Lithuanian
    'lt': 'lt',
    // Latvian
    'lv': 'lv',
    // Arabic
    'eg': 'ar',
    'dz': 'ar',
    'kw': 'ar',
    'ae': 'ar',
    // Slovakian
    'sk': 'sk',
    // Romanian
    'ro': 'ro',
    // Suomi
    'fi': 'fi',
    // Icelandic
    'is': 'is',
    // Norwegian
    'no': 'no',
    // Greek
    'gr': 'el',
    // Hungarian
    'hu': 'hu',
    // Hebrew
    'il': 'he',
    // Chinese
    'cn': 'zh',
    // Indonesian
    'id': 'id',
    // Turkish
    'tr': 'tr'
  };
  /**
   * Called when LocaleDetectorService has detected language-specific filters we can enable.
   *
   * @param filterIds List of detected language-specific filters identifiers
   * @private
   */

  async function onFilterDetectedByLocale(filterIds) {
    if (!filterIds) {
      return;
    }

    const enabledFilters = await application.addAndEnableFilters(filterIds, {
      forceGroupEnable: true
    });

    if (enabledFilters.length > 0) {
      listeners.notifyListeners(listeners.ENABLE_FILTER_SHOW_POPUP, enabledFilters);
    }
  }
  /**
   * Stores language in the special array containing languages of the last visited pages.
   * If user has visited enough pages with a specified language we call special callback
   * to auto-enable filter for this language
   *
   * @param language Page language
   * @private
   */


  function detectLanguage(language) {
    /**
     * For an unknown language "und" will be returned
     * https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/tabs/detectLanguage
     */
    if (!language || language === 'und') {
      return;
    }

    browsingLanguages.push({
      language,
      time: Date.now()
    });

    if (browsingLanguages.length > MAX_HISTORY_LENGTH) {
      browsingLanguages.shift();
    }

    const history = browsingLanguages.filter(h => {
      return h.language === language;
    });

    if (history.length >= SUCCESS_HIT_COUNT) {
      const filterIds = subscriptions.getFilterIdsForLanguage(language);
      onFilterDetectedByLocale(filterIds);
    }
  }
  /**
   * Detects language for the specified page
   * @param tab    Tab
   * @param url    Page URL
   */


  async function detectTabLanguage(tab, url) {
    if (!settings.isAutodetectFilters() || settings.isFilteringDisabled()) {
      return;
    } // Check language only for http://... tabs


    if (!utils.url.isHttpRequest(url)) {
      return;
    } // tabs.detectLanguage doesn't work in Opera
    // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/997


    if (!browserUtils.isOperaBrowser()) {
      if (tab.tabId && extension_api_browser/* browser.tabs */.X.tabs && extension_api_browser/* browser.tabs.detectLanguage */.X.tabs.detectLanguage) {
        // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/tabs/detectLanguage
        try {
          const language = await extension_api_browser/* browser.tabs.detectLanguage */.X.tabs.detectLanguage(tab.tabId);
          detectLanguage(language);
        } catch (e) {// do nothing
        }

        return;
      }
    } // Detecting language by top-level domain if extension API language detection is unavailable
    // Ignore hostnames which length is less or equal to 8
    // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1354


    const host = utils.url.getDomainName(url);

    if (host && host.length > 8) {
      const parts = host ? host.split('.') : [];
      const tld = parts[parts.length - 1];
      const lang = domainToLanguagesMap[tld];
      detectLanguage(lang);
    }
  }

  const init = () => {
    // Locale detect
    tabsApi.onUpdated.addListener(tab => {
      if (tab.status === 'complete') {
        detectTabLanguage(tab, tab.url);
      }
    });
  };

  return {
    init
  };
}();
;// CONCATENATED MODULE: ./Extension/src/background/fullscreen-user-rules-editor.js


/**
 * Module used to keep track of userrules editor opened in the fullscreen mode
 */

class FullscreenUserRulesEditor {
  constructor() {
    this.openPagesCount = 0;
  }

  onOpenPage() {
    this.openPagesCount += 1;
    this.onPagesCountChanged();
  }

  onClosePage() {
    if (this.openPagesCount <= 0) {
      return;
    }

    this.openPagesCount -= 1;
    this.onPagesCountChanged();
  }

  onPagesCountChanged() {
    listeners.notifyListeners(constants/* NOTIFIER_TYPES.FULLSCREEN_USER_RULES_EDITOR_UPDATED */.Qp.FULLSCREEN_USER_RULES_EDITOR_UPDATED, this.isOpen());
  }

  isOpen() {
    return this.openPagesCount > 0;
  }

}

const fullscreenUserRulesEditor = new FullscreenUserRulesEditor();
;// CONCATENATED MODULE: ./Extension/src/background/utils/editor-storage.js
/**
 * Module used to persist user rules editor content
 * during switches between common and fullscreen modes
 */
class EditorStorage {
  constructor() {
    this.content = null;

    this.setContent = content => {
      this.content = content;
    };

    this.getContent = () => {
      return this.content;
    };
  }

}

const editorStorage = new EditorStorage();
;// CONCATENATED MODULE: ./Extension/src/background/message-handler.js


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */


































const onPortConnection = port => {
  switch (true) {
    case port.name.startsWith(constants/* FILTERING_LOG */.du):
      {
        filtering_log_browsers.onOpenFilteringLogPage();
        break;
      }

    case port.name.startsWith(constants/* FULLSCREEN_USER_RULES_EDITOR */.Oi):
      {
        fullscreenUserRulesEditor.onOpenPage();
        break;
      }

    default:
      {
        throw new Error(`There is no such pages ${port.name}`);
      }
  }
};

const onPortDisconnection = port => {
  switch (true) {
    case port.name.startsWith(constants/* FILTERING_LOG */.du):
      {
        filtering_log_browsers.onCloseFilteringLogPage();
        break;
      }

    case port.name.startsWith(constants/* FULLSCREEN_USER_RULES_EDITOR */.Oi):
      {
        fullscreenUserRulesEditor.onClosePage();
        break;
      }

    default:
      {
        throw new Error(`There is no such pages ${port.name}`);
      }
  }
};
/**
 * This handler used to subscribe for notifications from popup page
 * https://developer.chrome.com/extensions/messaging#connect
 * We can't use simple one-time connections, because they can intercept each other
 * Causing issues like AG-2074
 */


const longLivedMessageHandler = port => {
  let listenerId;
  log/* log.info */.c.info(`Port: "${port.name}" connected`);
  onPortConnection(port);
  port.onMessage.addListener(message => {
    const {
      type,
      data
    } = message;

    if (type === constants/* MESSAGE_TYPES.ADD_LONG_LIVED_CONNECTION */.oK.ADD_LONG_LIVED_CONNECTION) {
      const {
        events
      } = data;
      listenerId = listeners.addSpecifiedListener(events, async (...data) => {
        const type = constants/* MESSAGE_TYPES.NOTIFY_LISTENERS */.oK.NOTIFY_LISTENERS;

        try {
          port.postMessage({
            type,
            data
          });
        } catch (e) {
          log/* log.error */.c.error(e.message);
        }
      });
    }
  });
  port.onDisconnect.addListener(() => {
    onPortDisconnection(port);
    listeners.removeListener(listenerId);
    log/* log.info */.c.info(`Port: "${port.name}" disconnected`);
  });
};

const createMessageHandler = () => {
  /**
   * Contains event listeners from content pages
   */
  const eventListeners = Object.create(null);
  /**
   * Adds event listener from content page
   * @param events
   * @param sender
   */

  function processAddEventListener(events, sender) {
    const listenerId = listeners.addSpecifiedListener(events, (...args) => {
      const sender = eventListeners[listenerId];

      if (sender) {
        tabsApi.sendMessage(sender.tab.tabId, {
          type: constants/* MESSAGE_TYPES.NOTIFY_LISTENERS */.oK.NOTIFY_LISTENERS,
          data: args
        });
      }
    });
    eventListeners[listenerId] = sender;
    return {
      listenerId
    };
  }
  /**
   * Constructs objects that uses on extension pages, like: options.html, thankyou.html etc
   */


  function processInitializeFrameScriptRequest() {
    const AntiBannerFiltersId = utils.filters.ids;
    const enabledFilters = {};
    Object.values(AntiBannerFiltersId).forEach(filterId => {
      const enabled = application.isFilterEnabled(filterId);

      if (enabled) {
        enabledFilters[filterId] = true;
      }
    });
    return {
      userSettings: settings.getAllSettings(),
      enabledFilters,
      filtersMetadata: subscriptions.getFilters(),
      requestFilterInfo: filteringApi.getRequestFilterInfo(),
      environmentOptions: {
        isMacOs: browserUtils.isMacOs(),
        canBlockWebRTC: stealthService.canBlockWebRTC(),
        isChrome: browserUtils.isChromeBrowser(),
        Prefs: {
          locale: backgroundPage.app.getLocale(),
          mobile: prefs.mobile || false
        },
        appVersion: backgroundPage.app.getVersion()
      },
      constants: {
        AntiBannerFiltersId: utils.filters.ids,
        EventNotifierTypes: listeners.events
      }
    };
  }
  /**
   * Saves css hits from content-script.
   * Message includes stats field. [{filterId: 1, ruleText: 'rule1'}, {filterId: 2, ruleText: 'rule2'}...]
   * @param tab
   * @param stats
   */


  function processSaveCssHitStats(tab, stats) {
    if (!webRequestService.isCollectingCosmeticRulesHits(tab)) {
      return;
    }

    const frameUrl = frames_frames.getMainFrameUrl(tab);

    for (let i = 0; i < stats.length; i += 1) {
      const stat = stats[i];
      const rule = new es/* CosmeticRule */.nR(stat.ruleText, stat.filterId);
      webRequestService.recordRuleHit(tab, rule, frameUrl);
      filtering_log_browsers.addCosmeticEvent({
        tab,
        element: stat.element,
        frameUrl: tab.url,
        requestType: request_types/* RequestTypes.DOCUMENT */.l.DOCUMENT,
        requestRule: rule,
        timestamp: Date.now()
      });
    }
  }

  const processGetOptionsData = () => {
    return {
      settings: settings.getAllSettings(),
      appVersion: backgroundPage.app.getVersion(),
      filtersMetadata: categories.getFiltersMetadata(),
      filtersInfo: antiBannerService.getRequestFilterInfo(),
      environmentOptions: {
        isChrome: browserUtils.isChromeBrowser()
      },
      constants: {
        AntiBannerFiltersId: utils.filters.ids
      },
      fullscreenUserRulesEditorIsOpen: fullscreenUserRulesEditor.isOpen()
    };
  };
  /**
   * For dangerous (which can change user rules) messages we also check their origin
   * @param message
   * @param sender
   * @return {boolean}
   */


  const isMessageAllowed = (message, sender) => {
    const OPTIONS_PAGE_DANGEROUS_MESSAGES = [constants/* MESSAGE_TYPES.SUBSCRIBE_TO_CUSTOM_FILTER */.oK.SUBSCRIBE_TO_CUSTOM_FILTER, constants/* MESSAGE_TYPES.SAVE_USER_RULES */.oK.SAVE_USER_RULES, constants/* MESSAGE_TYPES.APPLY_SETTINGS_JSON */.oK.APPLY_SETTINGS_JSON, constants/* MESSAGE_TYPES.FILTERING_LOG_ADD_USER_RULE */.oK.FILTERING_LOG_ADD_USER_RULE, constants/* MESSAGE_TYPES.DEVTOOLS_ADD_USER_RULE */.oK.DEVTOOLS_ADD_USER_RULE]; // Dangerous messages are allowed only from own pages (popup, options, filtering log, devtools)

    if (OPTIONS_PAGE_DANGEROUS_MESSAGES.includes(message === null || message === void 0 ? void 0 : message.type)) {
      var _sender$tab;

      // Allow empty sender. Empty sender can be in the messages from devtools and popup
      // There is always sender for messages sent by content script
      const isSenderEmpty = !sender || sender && Object.keys(sender).length === 0;

      if (isSenderEmpty) {
        return true;
      }

      const url = (_sender$tab = sender.tab) === null || _sender$tab === void 0 ? void 0 : _sender$tab.url;
      const isOwnUrl = url && backgroundPage.app.isOwnRequest(url);
      const isDevtoolsUrl = url && url.startsWith('devtools://');
      return isOwnUrl || isDevtoolsUrl;
    }

    return true;
  };
  /**
   * Main function for processing messages from content-scripts
   *
   * @param message
   * @param sender
   * @returns {*}
   */


  const handleMessage = async (message, sender) => {
    if (!isMessageAllowed(message, sender)) {
      log/* log.error */.c.error('Message: {0} is not allowed for the sender: {1} ', message, sender);
      return;
    }

    const {
      data,
      type
    } = message;

    switch (type) {
      case constants/* MESSAGE_TYPES.SCRIPTLET_CLOSE_WINDOW */.oK.SCRIPTLET_CLOSE_WINDOW:
        {
          const {
            tabId
          } = sender.tab;
          tabsApi.remove(tabId);
          break;
        }

      case constants/* MESSAGE_TYPES.GET_OPTIONS_DATA */.oK.GET_OPTIONS_DATA:
        {
          return processGetOptionsData();
        }

      case constants/* MESSAGE_TYPES.UN_ALLOWLIST_FRAME */.oK.UN_ALLOWLIST_FRAME:
        {
          const {
            frameInfo
          } = data;
          userrules.unAllowlistFrame(frameInfo);
          break;
        }

      case constants/* MESSAGE_TYPES.CREATE_EVENT_LISTENER */.oK.CREATE_EVENT_LISTENER:
        {
          const {
            events
          } = data;
          return processAddEventListener(events, sender);
        }

      case constants/* MESSAGE_TYPES.REMOVE_LISTENER */.oK.REMOVE_LISTENER:
        {
          const {
            listenerId
          } = data;
          listeners.removeListener(listenerId);
          delete eventListeners[listenerId];
          break;
        }

      case constants/* MESSAGE_TYPES.INITIALIZE_FRAME_SCRIPT */.oK.INITIALIZE_FRAME_SCRIPT:
        return processInitializeFrameScriptRequest();

      case constants/* MESSAGE_TYPES.CHANGE_USER_SETTING */.oK.CHANGE_USER_SETTING:
        settings.setProperty(message.key, message.value);
        break;

      case constants/* MESSAGE_TYPES.CHECK_REQUEST_FILTER_READY */.oK.CHECK_REQUEST_FILTER_READY:
        return {
          ready: filteringApi.isReady()
        };

      case constants/* MESSAGE_TYPES.ADD_AND_ENABLE_FILTER */.oK.ADD_AND_ENABLE_FILTER:
        {
          const {
            filterId
          } = data;
          return application.addAndEnableFilters([filterId], {
            forceRemote: true
          });
        }

      case constants/* MESSAGE_TYPES.DISABLE_ANTIBANNER_FILTER */.oK.DISABLE_ANTIBANNER_FILTER:
        {
          const {
            filterId,
            remove
          } = data;

          if (remove) {
            application.uninstallFilters([filterId]);
          } else {
            application.disableFilters([filterId]);
          }

          break;
        }

      case constants/* MESSAGE_TYPES.REMOVE_ANTIBANNER_FILTER */.oK.REMOVE_ANTIBANNER_FILTER:
        {
          const {
            filterId
          } = data;
          application.removeFilter(filterId);
          break;
        }

      case constants/* MESSAGE_TYPES.ENABLE_FILTERS_GROUP */.oK.ENABLE_FILTERS_GROUP:
        {
          const {
            groupId
          } = data;
          await categories.enableFiltersGroup(groupId);
          break;
        }

      case constants/* MESSAGE_TYPES.DISABLE_FILTERS_GROUP */.oK.DISABLE_FILTERS_GROUP:
        {
          const {
            groupId
          } = data;
          categories.disableFiltersGroup(groupId);
          break;
        }

      case constants/* MESSAGE_TYPES.GET_ALLOWLIST_DOMAINS */.oK.GET_ALLOWLIST_DOMAINS:
        {
          const allowlistDomains = allowlist.getAllowlistDomains();
          const appVersion = backgroundPage.app.getVersion();
          return {
            content: allowlistDomains.join('\r\n'),
            appVersion
          };
        }

      case constants/* MESSAGE_TYPES.SAVE_ALLOWLIST_DOMAINS */.oK.SAVE_ALLOWLIST_DOMAINS:
        {
          const {
            value
          } = data;
          const domains = value.split(/[\r\n]+/).map(string => string.trim()).filter(string => string.length > 0);
          allowlist.updateAllowlistDomains(domains);
          break;
        }

      case constants/* MESSAGE_TYPES.GET_USER_RULES */.oK.GET_USER_RULES:
        {
          const content = await userrules.getUserRulesText();
          const appVersion = backgroundPage.app.getVersion();
          return {
            content,
            appVersion
          };
        }

      case constants/* MESSAGE_TYPES.SAVE_USER_RULES */.oK.SAVE_USER_RULES:
        {
          const {
            value
          } = data;
          userrules.updateUserRulesText(value); // We are waiting until request filter is updated

          return new Promise(resolve => {
            const listenerId = listeners.addListener(event => {
              if (event === listeners.USER_FILTER_UPDATED) {
                listeners.removeListener(listenerId);
                resolve();
              }
            });
          });
        }

      case constants/* MESSAGE_TYPES.FILTERING_LOG_ADD_USER_RULE */.oK.FILTERING_LOG_ADD_USER_RULE:
        {
          const {
            ruleText
          } = data;
          userrules.addRules([ruleText]);
          break;
        }

      case constants/* MESSAGE_TYPES.DEVTOOLS_ADD_USER_RULE */.oK.DEVTOOLS_ADD_USER_RULE:
        {
          const {
            ruleText
          } = data;
          userrules.addRules([ruleText]);
          break;
        }

      case constants/* MESSAGE_TYPES.CONTENT_SCRIPT_ADD_USER_RULE */.oK.CONTENT_SCRIPT_ADD_USER_RULE:
        {
          const {
            ruleText,
            token
          } = data;
          const expectedToken = uiService.getAssistantToken(); // check for token to avoid possible vulnerabilities AG-12883
          // https://groups.google.com/a/chromium.org/g/chromium-extensions/c/0ei-UCHNm34/m/lDaXwQhzBAAJ?pli=1
          // https://bugs.chromium.org/p/chromium/issues/detail?id=982326

          if (token === expectedToken) {
            userrules.addRules([ruleText]);
          } else {
            log/* log.error */.c.error('Tokens for message {0} does not not match. Expected token: {1}. Received token: {2}', message, token, expectedToken);
          }

          break;
        }

      case constants/* MESSAGE_TYPES.REMOVE_USER_RULE */.oK.REMOVE_USER_RULE:
        {
          const {
            ruleText
          } = data;
          userrules.removeRule(ruleText);
          break;
        }

      case constants/* MESSAGE_TYPES.CHECK_ANTIBANNER_FILTERS_UPDATE */.oK.CHECK_ANTIBANNER_FILTERS_UPDATE:
        {
          const filters = await uiService.checkFiltersUpdates();
          return filters;
        }

      case constants/* MESSAGE_TYPES.LOAD_CUSTOM_FILTER_INFO */.oK.LOAD_CUSTOM_FILTER_INFO:
        try {
          const {
            url,
            title
          } = data;
          return application.loadCustomFilterInfo(url, {
            title
          });
        } catch (e) {
          return {};
        }

      case constants/* MESSAGE_TYPES.SUBSCRIBE_TO_CUSTOM_FILTER */.oK.SUBSCRIBE_TO_CUSTOM_FILTER:
        {
          const {
            customUrl,
            name,
            trusted
          } = data.filter;

          try {
            const filter = await application.loadCustomFilter(customUrl, {
              title: name,
              trusted
            });
            await application.addAndEnableFilters([filter.filterId]);
            return filter;
          } catch (e) {// do nothing
          }

          break;
        }

      case constants/* MESSAGE_TYPES.OPEN_THANKYOU_PAGE */.oK.OPEN_THANKYOU_PAGE:
        uiService.openThankYouPage();
        break;

      case constants/* MESSAGE_TYPES.OPEN_EXTENSION_STORE */.oK.OPEN_EXTENSION_STORE:
        uiService.openExtensionStore();
        break;

      case constants/* MESSAGE_TYPES.OPEN_COMPARE_PAGE */.oK.OPEN_COMPARE_PAGE:
        uiService.openComparePage();
        break;

      case constants/* MESSAGE_TYPES.OPEN_FILTERING_LOG */.oK.OPEN_FILTERING_LOG:
        uiService.openFilteringLog(message.tabId);
        break;

      case constants/* MESSAGE_TYPES.SET_FILTERING_LOG_WINDOW_STATE */.oK.SET_FILTERING_LOG_WINDOW_STATE:
        filteringLogWindowState.setState(data.windowState);
        break;

      case constants/* MESSAGE_TYPES.OPEN_FULLSCREEN_USER_RULES */.oK.OPEN_FULLSCREEN_USER_RULES:
        uiService.openFullscreenUserRules();
        break;

      case constants/* MESSAGE_TYPES.GET_FILTERING_LOG_DATA */.oK.GET_FILTERING_LOG_DATA:
        {
          return {
            filtersMetadata: subscriptions.getFilters(),
            settings: settings.getAllSettings(),
            preserveLogEnabled: filtering_log_browsers.isPreserveLogEnabled()
          };
        }

      case constants/* MESSAGE_TYPES.OPEN_SAFEBROWSING_TRUSTED */.oK.OPEN_SAFEBROWSING_TRUSTED:
        {
          const {
            url
          } = data;
          safebrowsing_browsers.addToSafebrowsingTrusted(url);
          const tab = await tabsApi.getActive();

          if (tab) {
            tabsApi.reload(tab.tabId, url);
          }

          break;
        }

      case constants/* MESSAGE_TYPES.OPEN_TAB */.oK.OPEN_TAB:
        {
          const {
            url,
            options
          } = data;
          return uiService.openTab(url, options);
        }

      case constants/* MESSAGE_TYPES.RESET_BLOCKED_ADS_COUNT */.oK.RESET_BLOCKED_ADS_COUNT:
        frames_frames.resetBlockedAdsCount();
        break;

      case constants/* MESSAGE_TYPES.RESET_SETTINGS */.oK.RESET_SETTINGS:
        return settingsProvider.applyDefaultSettings();

      case constants/* MESSAGE_TYPES.GET_SELECTORS_AND_SCRIPTS */.oK.GET_SELECTORS_AND_SCRIPTS:
        {
          let urlForSelectors; // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1498
          // when document url for iframe is about:blank then we use tab url

          if (!utils.url.isHttpOrWsRequest(message.documentUrl) && sender.frameId !== 0) {
            urlForSelectors = sender.tab.url;
          } else {
            urlForSelectors = message.documentUrl;
          } // force getting selectors and scripts during browser restart with already open tabs


          const response = webRequestService.processGetSelectorsAndScripts(sender.tab, urlForSelectors, filteringApi.shouldCollapseAllElements());
          return response || {};
        }

      case constants/* MESSAGE_TYPES.GET_COOKIE_RULES */.oK.GET_COOKIE_RULES:
        {
          if (!utils.url.isHttpOrWsRequest(message.documentUrl) && sender.frameId !== 0) {
            return {};
          }

          return {
            rulesData: getCookieRulesDataForContentScript(sender.tab, message.documentUrl, sender.tab.url)
          };
        }

      case constants/* MESSAGE_TYPES.SAVE_COOKIE_LOG_EVENT */.oK.SAVE_COOKIE_LOG_EVENT:
        {
          filtering_log_browsers.addCookieEvent({
            tabId: sender.tab.tabId,
            cookieName: data.cookieName,
            cookieDomain: data.cookieDomain,
            cookieRule: new es/* NetworkRule */.nC(data.ruleText, data.filterId),
            isModifyingCookieRule: false,
            thirdParty: data.thirdParty,
            timestamp: Date.now()
          });
          break;
        }

      case constants/* MESSAGE_TYPES.CHECK_PAGE_SCRIPT_WRAPPER_REQUEST */.oK.CHECK_PAGE_SCRIPT_WRAPPER_REQUEST:
        {
          const block = webRequestService.checkPageScriptWrapperRequest(sender.tab, message.elementUrl, message.documentUrl, message.requestType);
          return {
            block,
            requestId: message.requestId
          };
        }

      case constants/* MESSAGE_TYPES.PROCESS_SHOULD_COLLAPSE */.oK.PROCESS_SHOULD_COLLAPSE:
        {
          const collapse = webRequestService.processShouldCollapse(sender.tab, message.elementUrl, message.documentUrl, message.requestType);
          return {
            collapse,
            requestId: message.requestId
          };
        }

      case constants/* MESSAGE_TYPES.PROCESS_SHOULD_COLLAPSE_MANY */.oK.PROCESS_SHOULD_COLLAPSE_MANY:
        {
          const requests = webRequestService.processShouldCollapseMany(sender.tab, message.documentUrl, message.requests);
          return {
            requests
          };
        }

      case constants/* MESSAGE_TYPES.ON_OPEN_FILTERING_LOG_PAGE */.oK.ON_OPEN_FILTERING_LOG_PAGE:
        filtering_log_browsers.onOpenFilteringLogPage();
        break;

      case constants/* MESSAGE_TYPES.ON_CLOSE_FILTERING_LOG_PAGE */.oK.ON_CLOSE_FILTERING_LOG_PAGE:
        filtering_log_browsers.onCloseFilteringLogPage();
        break;

      case constants/* MESSAGE_TYPES.CLEAR_EVENTS_BY_TAB_ID */.oK.CLEAR_EVENTS_BY_TAB_ID:
        filtering_log_browsers.clearEventsByTabId(data.tabId, data.ignorePreserveLog);
        break;

      case constants/* MESSAGE_TYPES.REFRESH_PAGE */.oK.REFRESH_PAGE:
        filtering_log_browsers.clearEventsByTabId(data.tabId);
        await tabsApi.reload(data.tabId);
        break;

      case constants/* MESSAGE_TYPES.GET_TAB_FRAME_INFO_BY_ID */.oK.GET_TAB_FRAME_INFO_BY_ID:
        {
          if (data.tabId) {
            const frameInfo = frames_frames.getFrameInfo({
              tabId: data.tabId
            });
            return {
              frameInfo
            };
          }

          const tab = await tabsApi.getActive();

          if (tab) {
            const frameInfo = frames_frames.getFrameInfo(tab);
            return {
              frameInfo
            };
          }

          break;
        }

      case constants/* MESSAGE_TYPES.GET_FILTERING_INFO_BY_TAB_ID */.oK.GET_FILTERING_INFO_BY_TAB_ID:
        {
          const {
            tabId
          } = data;
          return filtering_log_browsers.getFilteringInfoByTabId(tabId);
        }

      case constants/* MESSAGE_TYPES.SYNCHRONIZE_OPEN_TABS */.oK.SYNCHRONIZE_OPEN_TABS:
        {
          return filtering_log_browsers.synchronizeOpenTabs();
        }

      case constants/* MESSAGE_TYPES.ADD_FILTERING_SUBSCRIPTION */.oK.ADD_FILTERING_SUBSCRIPTION:
        {
          const {
            url,
            title
          } = message;
          await uiService.openCustomFiltersModal(url, title);
          break;
        }
      // Popup methods

      case constants/* MESSAGE_TYPES.ADD_ALLOWLIST_DOMAIN_POPUP */.oK.ADD_ALLOWLIST_DOMAIN_POPUP:
        {
          const tab = await tabsApi.getActive(data.tabId);

          if (tab) {
            uiService.allowlistTab(tab);
          }

          break;
        }

      case constants/* MESSAGE_TYPES.REMOVE_ALLOWLIST_DOMAIN */.oK.REMOVE_ALLOWLIST_DOMAIN:
        {
          const tab = await tabsApi.getActive(data.tabId);

          if (tab) {
            uiService.unAllowlistTab(tab);
          }

          break;
        }

      case constants/* MESSAGE_TYPES.CHANGE_APPLICATION_FILTERING_DISABLED */.oK.CHANGE_APPLICATION_FILTERING_DISABLED:
        {
          const {
            state
          } = data;
          uiService.changeApplicationFilteringDisabled(state);
          break;
        }

      case constants/* MESSAGE_TYPES.OPEN_SITE_REPORT_TAB */.oK.OPEN_SITE_REPORT_TAB:
        {
          const {
            url
          } = data;
          uiService.openSiteReportTab(url);
          break;
        }

      case constants/* MESSAGE_TYPES.OPEN_ABUSE_TAB */.oK.OPEN_ABUSE_TAB:
        {
          const {
            url,
            from
          } = data;
          uiService.openAbuseTab(url, from);
          break;
        }

      case constants/* MESSAGE_TYPES.OPEN_SETTINGS_TAB */.oK.OPEN_SETTINGS_TAB:
        uiService.openSettingsTab();
        break;

      case constants/* MESSAGE_TYPES.OPEN_ASSISTANT */.oK.OPEN_ASSISTANT:
        uiService.openAssistant();
        break;

      case constants/* MESSAGE_TYPES.GET_TAB_INFO_FOR_POPUP */.oK.GET_TAB_INFO_FOR_POPUP:
        {
          const tab = await tabsApi.getActive(data.tabId); // There can't be data till localstorage is initialized

          const stats = storage_localStorage.isInitialized() ? pageStats.getStatisticsData() : {};

          if (tab) {
            const frameInfo = frames_frames.getFrameInfo(tab);
            return {
              frameInfo,
              stats,
              options: {
                showStatsSupported: true,
                isFirefoxBrowser: browserUtils.isFirefoxBrowser(),
                showInfoAboutFullVersion: settings.isShowInfoAboutAdguardFullVersion(),
                isMacOs: browserUtils.isMacOs(),
                isEdgeBrowser: browserUtils.isEdgeBrowser() || browserUtils.isEdgeChromiumBrowser(),
                notification: notifications.getCurrentNotification(),
                isDisableShowAdguardPromoInfo: settings.isDisableShowAdguardPromoInfo(),
                hasCustomRulesToReset: await userrules.hasRulesForUrl(frameInfo.url)
              },
              settings: settings.getAllSettings()
            };
          }

          break;
        }

      case constants/* MESSAGE_TYPES.SET_NOTIFICATION_VIEWED */.oK.SET_NOTIFICATION_VIEWED:
        notifications.setNotificationViewed(data.withDelay);
        break;

      case constants/* MESSAGE_TYPES.GET_STATISTICS_DATA */.oK.GET_STATISTICS_DATA:
        // There can't be data till localstorage is initialized
        if (!storage_localStorage.isInitialized()) {
          return {};
        }

        return {
          stats: pageStats.getStatisticsData()
        };

      case constants/* MESSAGE_TYPES.SAVE_CSS_HITS_STATS */.oK.SAVE_CSS_HITS_STATS:
        processSaveCssHitStats(sender.tab, message.stats);
        break;

      case constants/* MESSAGE_TYPES.LOAD_SETTINGS_JSON */.oK.LOAD_SETTINGS_JSON:
        {
          const appVersion = backgroundPage.app.getVersion();
          const json = await settingsProvider.loadSettingsBackup();
          return {
            content: json,
            appVersion
          };
        }

      case constants/* MESSAGE_TYPES.APPLY_SETTINGS_JSON */.oK.APPLY_SETTINGS_JSON:
        {
          const {
            json
          } = data;
          return settingsProvider.applySettingsBackup(json);
        }

      case constants/* MESSAGE_TYPES.ADD_URL_TO_TRUSTED */.oK.ADD_URL_TO_TRUSTED:
        {
          const {
            url
          } = data;
          await documentFilterService.addToTrusted(url);
          break;
        }

      case constants/* MESSAGE_TYPES.RESET_CUSTOM_RULES_FOR_PAGE */.oK.RESET_CUSTOM_RULES_FOR_PAGE:
        {
          const {
            url,
            tabId
          } = data;
          await userrules.removeRulesByUrl(url); // wait until request filter is updated

          await new Promise(resolve => {
            const listenerId = listeners.addListener(event => {
              if (event === listeners.REQUEST_FILTER_UPDATED) {
                listeners.removeListener(listenerId);
                resolve();
              }
            });
          }); // reload tab

          await tabsApi.reload(tabId, url);
          break;
        }

      case constants/* MESSAGE_TYPES.SET_PRESERVE_LOG_STATE */.oK.SET_PRESERVE_LOG_STATE:
        {
          const {
            state
          } = data;
          filtering_log_browsers.setPreserveLogState(state);
          break;
        }

      case constants/* MESSAGE_TYPES.GET_USER_RULES_EDITOR_DATA */.oK.GET_USER_RULES_EDITOR_DATA:
        {
          return {
            userRules: await userrules.getUserRulesText(),
            settings: settings.getAllSettings()
          };
        }

      case constants/* MESSAGE_TYPES.GET_EDITOR_STORAGE_CONTENT */.oK.GET_EDITOR_STORAGE_CONTENT:
        {
          return editorStorage.getContent();
        }

      case constants/* MESSAGE_TYPES.SET_EDITOR_STORAGE_CONTENT */.oK.SET_EDITOR_STORAGE_CONTENT:
        {
          const {
            content
          } = data;
          editorStorage.setContent(content);
          break;
        }

      case constants/* MESSAGE_TYPES.CONVERT_RULES_TEXT */.oK.CONVERT_RULES_TEXT:
        {
          const {
            content
          } = data;
          return es/* RuleConverter.convertRules */.cR.convertRules(content);
        }

      default:
        // Unhandled message
        throw new Error(`There is no such message type ${message.type}`);
    }

    return Promise.resolve();
  };

  return handleMessage;
};
/**
 *  Initialize Content => BackgroundPage messaging
 */


const init = () => {
  // Add event listener for messages from popup page, options page and content scripts
  backgroundPage.runtime.onMessage.addListener(createMessageHandler());
  backgroundPage.runtime.onConnect.addListener(longLivedMessageHandler);
};

const messageHandler = {
  init
};
;// CONCATENATED MODULE: ./Extension/pages/background/index.js








start();
webrequest.init();
requestSanitizer.init();
localeDetect.init();
messageHandler.init();
window.adguard = {
  tabs: tabsApi,
  filtersUpdate: filtersUpdate,
  userrules: userrules
};

/***/ }),

/***/ 92273:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X": () => (/* reexport default from dynamic */ webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default.a)
/* harmony export */ });
/* harmony import */ var webextension_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53679);
/* harmony import */ var webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webextension_polyfill__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _windows__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5802);


(0,_windows__WEBPACK_IMPORTED_MODULE_1__/* .patchWindows */ .x)((webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default()));


/***/ }),

/***/ 5802:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "x": () => (/* binding */ patchWindows)
/* harmony export */ });
/* eslint-disable no-unused-vars */

/**
 * This function patches if necessary browser.windows implementation for Firefox for Android
 */
const patchWindows = function (browser) {
  // Make compatible with Android WebExt
  if (typeof browser.windows === 'undefined') {
    browser.windows = function () {
      const defaultWindow = {
        id: 1,
        type: 'normal'
      };
      const emptyListener = {
        addListener() {// Doing nothing
        }

      };

      const create = function (createData) {
        return Promise.resolve(defaultWindow);
      };

      const update = function (windowId, data) {
        return Promise.resolve();
      };

      const getAll = function (query) {
        return Promise.resolve(defaultWindow);
      };

      const getLastFocused = function () {
        return Promise.resolve(defaultWindow);
      };

      return {
        onCreated: emptyListener,
        onRemoved: emptyListener,
        onFocusChanged: emptyListener,
        create,
        update,
        getAll,
        getLastFocused
      };
    }();
  }
};

/***/ }),

/***/ 80352:
/***/ ((module) => {

"use strict";
/**
 * DON'T EDIT THIS FILE
 * Module was generated automatically by ajv precompiler 
 * See '/tools/bundle/genValidators.js'
 */


module.exports = validate10;
module.exports["default"] = validate10;
const schema11 = {
  "$id": "settings.json",
  "type": "object",
  "properties": {
    "protocol-version": {
      "type": "string"
    },
    "general-settings": {
      "type": "object",
      "properties": {
        "app-language": {
          "type": "string"
        },
        "allow-acceptable-ads": {
          "type": "boolean"
        },
        "show-blocked-ads-count": {
          "type": "boolean"
        },
        "autodetect-filters": {
          "type": "boolean"
        },
        "safebrowsing-enabled": {
          "type": "boolean"
        },
        "filters-update-period": {
          "type": "integer"
        },
        "appearance-theme": {
          "type": "string"
        }
      },
      "required": ["allow-acceptable-ads", "show-blocked-ads-count", "autodetect-filters", "safebrowsing-enabled", "filters-update-period"]
    },
    "extension-specific-settings": {
      "type": "object",
      "properties": {
        "use-optimized-filters": {
          "type": "boolean"
        },
        "collect-hits-count": {
          "type": "boolean"
        },
        "show-context-menu": {
          "type": "boolean"
        },
        "show-info-about-adguard": {
          "type": "boolean"
        },
        "show-app-updated-info": {
          "type": "boolean"
        }
      },
      "required": ["use-optimized-filters", "collect-hits-count", "show-context-menu", "show-info-about-adguard", "show-app-updated-info"]
    },
    "filters": {
      "type": "object",
      "properties": {
        "enabled-groups": {
          "type": "array",
          "items": {
            "type": "integer"
          }
        },
        "enabled-filters": {
          "type": "array",
          "items": {
            "type": "integer"
          }
        },
        "custom-filters": {
          "type": "array",
          "items": {}
        },
        "user-filter": {
          "type": "object",
          "properties": {
            "rules": {
              "type": "string"
            },
            "disabled-rules": {
              "type": "string"
            },
            "enabled": {
              "type": "boolean"
            }
          },
          "required": ["rules", "disabled-rules"]
        },
        "whitelist": {
          "type": "object",
          "properties": {
            "inverted": {
              "type": "boolean"
            },
            "domains": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "inverted-domains": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "enabled": {
              "type": "boolean"
            }
          },
          "required": ["inverted", "domains", "inverted-domains"]
        }
      },
      "required": ["enabled-groups", "enabled-filters", "custom-filters", "user-filter", "whitelist"]
    },
    "stealth": {
      "type": "object",
      "properties": {
        "stealth_disable_stealth_mode": {
          "type": "boolean"
        },
        "stealth-hide-referrer": {
          "type": "boolean"
        },
        "stealth-hide-search-queries": {
          "type": "boolean"
        },
        "stealth-send-do-not-track": {
          "type": "boolean"
        },
        "stealth-block-webrtc": {
          "type": "boolean"
        },
        "stealth-block-third-party-cookies": {
          "type": "boolean"
        },
        "stealth-block-first-party-cookies": {
          "type": "boolean"
        },
        "block-known-trackers": {
          "type": "boolean"
        },
        "strip-tracking-parameters": {
          "type": "boolean"
        }
      },
      "required": ["stealth_disable_stealth_mode", "stealth-hide-referrer", "stealth-hide-search-queries", "stealth-send-do-not-track", "stealth-block-webrtc", "stealth-block-third-party-cookies", "stealth-block-first-party-cookies", "strip-tracking-parameters"]
    }
  },
  "required": ["protocol-version", "general-settings", "extension-specific-settings", "filters"]
};

function validate10(data, {
  instancePath = "",
  parentData,
  parentDataProperty,
  rootData = data
} = {}) {
  /*# sourceURL="settings.json" */
  ;
  let vErrors = null;
  let errors = 0;

  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;

      if (data["protocol-version"] === undefined && (missing0 = "protocol-version") || data["general-settings"] === undefined && (missing0 = "general-settings") || data["extension-specific-settings"] === undefined && (missing0 = "extension-specific-settings") || data.filters === undefined && (missing0 = "filters")) {
        validate10.errors = [{
          instancePath,
          schemaPath: "#/required",
          keyword: "required",
          params: {
            missingProperty: missing0
          },
          message: "must have required property '" + missing0 + "'"
        }];
        return false;
      } else {
        if (data["protocol-version"] !== undefined) {
          const _errs1 = errors;

          if (typeof data["protocol-version"] !== "string") {
            validate10.errors = [{
              instancePath: instancePath + "/protocol-version",
              schemaPath: "#/properties/protocol-version/type",
              keyword: "type",
              params: {
                type: "string"
              },
              message: "must be string"
            }];
            return false;
          }

          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }

        if (valid0) {
          if (data["general-settings"] !== undefined) {
            let data1 = data["general-settings"];
            const _errs3 = errors;

            if (errors === _errs3) {
              if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                let missing1;

                if (data1["allow-acceptable-ads"] === undefined && (missing1 = "allow-acceptable-ads") || data1["show-blocked-ads-count"] === undefined && (missing1 = "show-blocked-ads-count") || data1["autodetect-filters"] === undefined && (missing1 = "autodetect-filters") || data1["safebrowsing-enabled"] === undefined && (missing1 = "safebrowsing-enabled") || data1["filters-update-period"] === undefined && (missing1 = "filters-update-period")) {
                  validate10.errors = [{
                    instancePath: instancePath + "/general-settings",
                    schemaPath: "#/properties/general-settings/required",
                    keyword: "required",
                    params: {
                      missingProperty: missing1
                    },
                    message: "must have required property '" + missing1 + "'"
                  }];
                  return false;
                } else {
                  if (data1["app-language"] !== undefined) {
                    const _errs5 = errors;

                    if (typeof data1["app-language"] !== "string") {
                      validate10.errors = [{
                        instancePath: instancePath + "/general-settings/app-language",
                        schemaPath: "#/properties/general-settings/properties/app-language/type",
                        keyword: "type",
                        params: {
                          type: "string"
                        },
                        message: "must be string"
                      }];
                      return false;
                    }

                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }

                  if (valid1) {
                    if (data1["allow-acceptable-ads"] !== undefined) {
                      const _errs7 = errors;

                      if (typeof data1["allow-acceptable-ads"] !== "boolean") {
                        validate10.errors = [{
                          instancePath: instancePath + "/general-settings/allow-acceptable-ads",
                          schemaPath: "#/properties/general-settings/properties/allow-acceptable-ads/type",
                          keyword: "type",
                          params: {
                            type: "boolean"
                          },
                          message: "must be boolean"
                        }];
                        return false;
                      }

                      var valid1 = _errs7 === errors;
                    } else {
                      var valid1 = true;
                    }

                    if (valid1) {
                      if (data1["show-blocked-ads-count"] !== undefined) {
                        const _errs9 = errors;

                        if (typeof data1["show-blocked-ads-count"] !== "boolean") {
                          validate10.errors = [{
                            instancePath: instancePath + "/general-settings/show-blocked-ads-count",
                            schemaPath: "#/properties/general-settings/properties/show-blocked-ads-count/type",
                            keyword: "type",
                            params: {
                              type: "boolean"
                            },
                            message: "must be boolean"
                          }];
                          return false;
                        }

                        var valid1 = _errs9 === errors;
                      } else {
                        var valid1 = true;
                      }

                      if (valid1) {
                        if (data1["autodetect-filters"] !== undefined) {
                          const _errs11 = errors;

                          if (typeof data1["autodetect-filters"] !== "boolean") {
                            validate10.errors = [{
                              instancePath: instancePath + "/general-settings/autodetect-filters",
                              schemaPath: "#/properties/general-settings/properties/autodetect-filters/type",
                              keyword: "type",
                              params: {
                                type: "boolean"
                              },
                              message: "must be boolean"
                            }];
                            return false;
                          }

                          var valid1 = _errs11 === errors;
                        } else {
                          var valid1 = true;
                        }

                        if (valid1) {
                          if (data1["safebrowsing-enabled"] !== undefined) {
                            const _errs13 = errors;

                            if (typeof data1["safebrowsing-enabled"] !== "boolean") {
                              validate10.errors = [{
                                instancePath: instancePath + "/general-settings/safebrowsing-enabled",
                                schemaPath: "#/properties/general-settings/properties/safebrowsing-enabled/type",
                                keyword: "type",
                                params: {
                                  type: "boolean"
                                },
                                message: "must be boolean"
                              }];
                              return false;
                            }

                            var valid1 = _errs13 === errors;
                          } else {
                            var valid1 = true;
                          }

                          if (valid1) {
                            if (data1["filters-update-period"] !== undefined) {
                              let data7 = data1["filters-update-period"];
                              const _errs15 = errors;

                              if (!(typeof data7 == "number" && !(data7 % 1) && !isNaN(data7) && isFinite(data7))) {
                                validate10.errors = [{
                                  instancePath: instancePath + "/general-settings/filters-update-period",
                                  schemaPath: "#/properties/general-settings/properties/filters-update-period/type",
                                  keyword: "type",
                                  params: {
                                    type: "integer"
                                  },
                                  message: "must be integer"
                                }];
                                return false;
                              }

                              var valid1 = _errs15 === errors;
                            } else {
                              var valid1 = true;
                            }

                            if (valid1) {
                              if (data1["appearance-theme"] !== undefined) {
                                const _errs17 = errors;

                                if (typeof data1["appearance-theme"] !== "string") {
                                  validate10.errors = [{
                                    instancePath: instancePath + "/general-settings/appearance-theme",
                                    schemaPath: "#/properties/general-settings/properties/appearance-theme/type",
                                    keyword: "type",
                                    params: {
                                      type: "string"
                                    },
                                    message: "must be string"
                                  }];
                                  return false;
                                }

                                var valid1 = _errs17 === errors;
                              } else {
                                var valid1 = true;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                validate10.errors = [{
                  instancePath: instancePath + "/general-settings",
                  schemaPath: "#/properties/general-settings/type",
                  keyword: "type",
                  params: {
                    type: "object"
                  },
                  message: "must be object"
                }];
                return false;
              }
            }

            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }

          if (valid0) {
            if (data["extension-specific-settings"] !== undefined) {
              let data9 = data["extension-specific-settings"];
              const _errs19 = errors;

              if (errors === _errs19) {
                if (data9 && typeof data9 == "object" && !Array.isArray(data9)) {
                  let missing2;

                  if (data9["use-optimized-filters"] === undefined && (missing2 = "use-optimized-filters") || data9["collect-hits-count"] === undefined && (missing2 = "collect-hits-count") || data9["show-context-menu"] === undefined && (missing2 = "show-context-menu") || data9["show-info-about-adguard"] === undefined && (missing2 = "show-info-about-adguard") || data9["show-app-updated-info"] === undefined && (missing2 = "show-app-updated-info")) {
                    validate10.errors = [{
                      instancePath: instancePath + "/extension-specific-settings",
                      schemaPath: "#/properties/extension-specific-settings/required",
                      keyword: "required",
                      params: {
                        missingProperty: missing2
                      },
                      message: "must have required property '" + missing2 + "'"
                    }];
                    return false;
                  } else {
                    if (data9["use-optimized-filters"] !== undefined) {
                      const _errs21 = errors;

                      if (typeof data9["use-optimized-filters"] !== "boolean") {
                        validate10.errors = [{
                          instancePath: instancePath + "/extension-specific-settings/use-optimized-filters",
                          schemaPath: "#/properties/extension-specific-settings/properties/use-optimized-filters/type",
                          keyword: "type",
                          params: {
                            type: "boolean"
                          },
                          message: "must be boolean"
                        }];
                        return false;
                      }

                      var valid2 = _errs21 === errors;
                    } else {
                      var valid2 = true;
                    }

                    if (valid2) {
                      if (data9["collect-hits-count"] !== undefined) {
                        const _errs23 = errors;

                        if (typeof data9["collect-hits-count"] !== "boolean") {
                          validate10.errors = [{
                            instancePath: instancePath + "/extension-specific-settings/collect-hits-count",
                            schemaPath: "#/properties/extension-specific-settings/properties/collect-hits-count/type",
                            keyword: "type",
                            params: {
                              type: "boolean"
                            },
                            message: "must be boolean"
                          }];
                          return false;
                        }

                        var valid2 = _errs23 === errors;
                      } else {
                        var valid2 = true;
                      }

                      if (valid2) {
                        if (data9["show-context-menu"] !== undefined) {
                          const _errs25 = errors;

                          if (typeof data9["show-context-menu"] !== "boolean") {
                            validate10.errors = [{
                              instancePath: instancePath + "/extension-specific-settings/show-context-menu",
                              schemaPath: "#/properties/extension-specific-settings/properties/show-context-menu/type",
                              keyword: "type",
                              params: {
                                type: "boolean"
                              },
                              message: "must be boolean"
                            }];
                            return false;
                          }

                          var valid2 = _errs25 === errors;
                        } else {
                          var valid2 = true;
                        }

                        if (valid2) {
                          if (data9["show-info-about-adguard"] !== undefined) {
                            const _errs27 = errors;

                            if (typeof data9["show-info-about-adguard"] !== "boolean") {
                              validate10.errors = [{
                                instancePath: instancePath + "/extension-specific-settings/show-info-about-adguard",
                                schemaPath: "#/properties/extension-specific-settings/properties/show-info-about-adguard/type",
                                keyword: "type",
                                params: {
                                  type: "boolean"
                                },
                                message: "must be boolean"
                              }];
                              return false;
                            }

                            var valid2 = _errs27 === errors;
                          } else {
                            var valid2 = true;
                          }

                          if (valid2) {
                            if (data9["show-app-updated-info"] !== undefined) {
                              const _errs29 = errors;

                              if (typeof data9["show-app-updated-info"] !== "boolean") {
                                validate10.errors = [{
                                  instancePath: instancePath + "/extension-specific-settings/show-app-updated-info",
                                  schemaPath: "#/properties/extension-specific-settings/properties/show-app-updated-info/type",
                                  keyword: "type",
                                  params: {
                                    type: "boolean"
                                  },
                                  message: "must be boolean"
                                }];
                                return false;
                              }

                              var valid2 = _errs29 === errors;
                            } else {
                              var valid2 = true;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  validate10.errors = [{
                    instancePath: instancePath + "/extension-specific-settings",
                    schemaPath: "#/properties/extension-specific-settings/type",
                    keyword: "type",
                    params: {
                      type: "object"
                    },
                    message: "must be object"
                  }];
                  return false;
                }
              }

              var valid0 = _errs19 === errors;
            } else {
              var valid0 = true;
            }

            if (valid0) {
              if (data.filters !== undefined) {
                let data15 = data.filters;
                const _errs31 = errors;

                if (errors === _errs31) {
                  if (data15 && typeof data15 == "object" && !Array.isArray(data15)) {
                    let missing3;

                    if (data15["enabled-groups"] === undefined && (missing3 = "enabled-groups") || data15["enabled-filters"] === undefined && (missing3 = "enabled-filters") || data15["custom-filters"] === undefined && (missing3 = "custom-filters") || data15["user-filter"] === undefined && (missing3 = "user-filter") || data15.whitelist === undefined && (missing3 = "whitelist")) {
                      validate10.errors = [{
                        instancePath: instancePath + "/filters",
                        schemaPath: "#/properties/filters/required",
                        keyword: "required",
                        params: {
                          missingProperty: missing3
                        },
                        message: "must have required property '" + missing3 + "'"
                      }];
                      return false;
                    } else {
                      if (data15["enabled-groups"] !== undefined) {
                        let data16 = data15["enabled-groups"];
                        const _errs33 = errors;

                        if (errors === _errs33) {
                          if (Array.isArray(data16)) {
                            var valid4 = true;
                            const len0 = data16.length;

                            for (let i0 = 0; i0 < len0; i0++) {
                              let data17 = data16[i0];
                              const _errs35 = errors;

                              if (!(typeof data17 == "number" && !(data17 % 1) && !isNaN(data17) && isFinite(data17))) {
                                validate10.errors = [{
                                  instancePath: instancePath + "/filters/enabled-groups/" + i0,
                                  schemaPath: "#/properties/filters/properties/enabled-groups/items/type",
                                  keyword: "type",
                                  params: {
                                    type: "integer"
                                  },
                                  message: "must be integer"
                                }];
                                return false;
                              }

                              var valid4 = _errs35 === errors;

                              if (!valid4) {
                                break;
                              }
                            }
                          } else {
                            validate10.errors = [{
                              instancePath: instancePath + "/filters/enabled-groups",
                              schemaPath: "#/properties/filters/properties/enabled-groups/type",
                              keyword: "type",
                              params: {
                                type: "array"
                              },
                              message: "must be array"
                            }];
                            return false;
                          }
                        }

                        var valid3 = _errs33 === errors;
                      } else {
                        var valid3 = true;
                      }

                      if (valid3) {
                        if (data15["enabled-filters"] !== undefined) {
                          let data18 = data15["enabled-filters"];
                          const _errs37 = errors;

                          if (errors === _errs37) {
                            if (Array.isArray(data18)) {
                              var valid5 = true;
                              const len1 = data18.length;

                              for (let i1 = 0; i1 < len1; i1++) {
                                let data19 = data18[i1];
                                const _errs39 = errors;

                                if (!(typeof data19 == "number" && !(data19 % 1) && !isNaN(data19) && isFinite(data19))) {
                                  validate10.errors = [{
                                    instancePath: instancePath + "/filters/enabled-filters/" + i1,
                                    schemaPath: "#/properties/filters/properties/enabled-filters/items/type",
                                    keyword: "type",
                                    params: {
                                      type: "integer"
                                    },
                                    message: "must be integer"
                                  }];
                                  return false;
                                }

                                var valid5 = _errs39 === errors;

                                if (!valid5) {
                                  break;
                                }
                              }
                            } else {
                              validate10.errors = [{
                                instancePath: instancePath + "/filters/enabled-filters",
                                schemaPath: "#/properties/filters/properties/enabled-filters/type",
                                keyword: "type",
                                params: {
                                  type: "array"
                                },
                                message: "must be array"
                              }];
                              return false;
                            }
                          }

                          var valid3 = _errs37 === errors;
                        } else {
                          var valid3 = true;
                        }

                        if (valid3) {
                          if (data15["custom-filters"] !== undefined) {
                            const _errs41 = errors;

                            if (errors === _errs41) {
                              if (!Array.isArray(data15["custom-filters"])) {
                                validate10.errors = [{
                                  instancePath: instancePath + "/filters/custom-filters",
                                  schemaPath: "#/properties/filters/properties/custom-filters/type",
                                  keyword: "type",
                                  params: {
                                    type: "array"
                                  },
                                  message: "must be array"
                                }];
                                return false;
                              }
                            }

                            var valid3 = _errs41 === errors;
                          } else {
                            var valid3 = true;
                          }

                          if (valid3) {
                            if (data15["user-filter"] !== undefined) {
                              let data21 = data15["user-filter"];
                              const _errs43 = errors;

                              if (errors === _errs43) {
                                if (data21 && typeof data21 == "object" && !Array.isArray(data21)) {
                                  let missing4;

                                  if (data21.rules === undefined && (missing4 = "rules") || data21["disabled-rules"] === undefined && (missing4 = "disabled-rules")) {
                                    validate10.errors = [{
                                      instancePath: instancePath + "/filters/user-filter",
                                      schemaPath: "#/properties/filters/properties/user-filter/required",
                                      keyword: "required",
                                      params: {
                                        missingProperty: missing4
                                      },
                                      message: "must have required property '" + missing4 + "'"
                                    }];
                                    return false;
                                  } else {
                                    if (data21.rules !== undefined) {
                                      const _errs45 = errors;

                                      if (typeof data21.rules !== "string") {
                                        validate10.errors = [{
                                          instancePath: instancePath + "/filters/user-filter/rules",
                                          schemaPath: "#/properties/filters/properties/user-filter/properties/rules/type",
                                          keyword: "type",
                                          params: {
                                            type: "string"
                                          },
                                          message: "must be string"
                                        }];
                                        return false;
                                      }

                                      var valid6 = _errs45 === errors;
                                    } else {
                                      var valid6 = true;
                                    }

                                    if (valid6) {
                                      if (data21["disabled-rules"] !== undefined) {
                                        const _errs47 = errors;

                                        if (typeof data21["disabled-rules"] !== "string") {
                                          validate10.errors = [{
                                            instancePath: instancePath + "/filters/user-filter/disabled-rules",
                                            schemaPath: "#/properties/filters/properties/user-filter/properties/disabled-rules/type",
                                            keyword: "type",
                                            params: {
                                              type: "string"
                                            },
                                            message: "must be string"
                                          }];
                                          return false;
                                        }

                                        var valid6 = _errs47 === errors;
                                      } else {
                                        var valid6 = true;
                                      }

                                      if (valid6) {
                                        if (data21.enabled !== undefined) {
                                          const _errs49 = errors;

                                          if (typeof data21.enabled !== "boolean") {
                                            validate10.errors = [{
                                              instancePath: instancePath + "/filters/user-filter/enabled",
                                              schemaPath: "#/properties/filters/properties/user-filter/properties/enabled/type",
                                              keyword: "type",
                                              params: {
                                                type: "boolean"
                                              },
                                              message: "must be boolean"
                                            }];
                                            return false;
                                          }

                                          var valid6 = _errs49 === errors;
                                        } else {
                                          var valid6 = true;
                                        }
                                      }
                                    }
                                  }
                                } else {
                                  validate10.errors = [{
                                    instancePath: instancePath + "/filters/user-filter",
                                    schemaPath: "#/properties/filters/properties/user-filter/type",
                                    keyword: "type",
                                    params: {
                                      type: "object"
                                    },
                                    message: "must be object"
                                  }];
                                  return false;
                                }
                              }

                              var valid3 = _errs43 === errors;
                            } else {
                              var valid3 = true;
                            }

                            if (valid3) {
                              if (data15.whitelist !== undefined) {
                                let data25 = data15.whitelist;
                                const _errs51 = errors;

                                if (errors === _errs51) {
                                  if (data25 && typeof data25 == "object" && !Array.isArray(data25)) {
                                    let missing5;

                                    if (data25.inverted === undefined && (missing5 = "inverted") || data25.domains === undefined && (missing5 = "domains") || data25["inverted-domains"] === undefined && (missing5 = "inverted-domains")) {
                                      validate10.errors = [{
                                        instancePath: instancePath + "/filters/whitelist",
                                        schemaPath: "#/properties/filters/properties/whitelist/required",
                                        keyword: "required",
                                        params: {
                                          missingProperty: missing5
                                        },
                                        message: "must have required property '" + missing5 + "'"
                                      }];
                                      return false;
                                    } else {
                                      if (data25.inverted !== undefined) {
                                        const _errs53 = errors;

                                        if (typeof data25.inverted !== "boolean") {
                                          validate10.errors = [{
                                            instancePath: instancePath + "/filters/whitelist/inverted",
                                            schemaPath: "#/properties/filters/properties/whitelist/properties/inverted/type",
                                            keyword: "type",
                                            params: {
                                              type: "boolean"
                                            },
                                            message: "must be boolean"
                                          }];
                                          return false;
                                        }

                                        var valid7 = _errs53 === errors;
                                      } else {
                                        var valid7 = true;
                                      }

                                      if (valid7) {
                                        if (data25.domains !== undefined) {
                                          let data27 = data25.domains;
                                          const _errs55 = errors;

                                          if (errors === _errs55) {
                                            if (Array.isArray(data27)) {
                                              var valid8 = true;
                                              const len2 = data27.length;

                                              for (let i2 = 0; i2 < len2; i2++) {
                                                const _errs57 = errors;

                                                if (typeof data27[i2] !== "string") {
                                                  validate10.errors = [{
                                                    instancePath: instancePath + "/filters/whitelist/domains/" + i2,
                                                    schemaPath: "#/properties/filters/properties/whitelist/properties/domains/items/type",
                                                    keyword: "type",
                                                    params: {
                                                      type: "string"
                                                    },
                                                    message: "must be string"
                                                  }];
                                                  return false;
                                                }

                                                var valid8 = _errs57 === errors;

                                                if (!valid8) {
                                                  break;
                                                }
                                              }
                                            } else {
                                              validate10.errors = [{
                                                instancePath: instancePath + "/filters/whitelist/domains",
                                                schemaPath: "#/properties/filters/properties/whitelist/properties/domains/type",
                                                keyword: "type",
                                                params: {
                                                  type: "array"
                                                },
                                                message: "must be array"
                                              }];
                                              return false;
                                            }
                                          }

                                          var valid7 = _errs55 === errors;
                                        } else {
                                          var valid7 = true;
                                        }

                                        if (valid7) {
                                          if (data25["inverted-domains"] !== undefined) {
                                            let data29 = data25["inverted-domains"];
                                            const _errs59 = errors;

                                            if (errors === _errs59) {
                                              if (Array.isArray(data29)) {
                                                var valid9 = true;
                                                const len3 = data29.length;

                                                for (let i3 = 0; i3 < len3; i3++) {
                                                  const _errs61 = errors;

                                                  if (typeof data29[i3] !== "string") {
                                                    validate10.errors = [{
                                                      instancePath: instancePath + "/filters/whitelist/inverted-domains/" + i3,
                                                      schemaPath: "#/properties/filters/properties/whitelist/properties/inverted-domains/items/type",
                                                      keyword: "type",
                                                      params: {
                                                        type: "string"
                                                      },
                                                      message: "must be string"
                                                    }];
                                                    return false;
                                                  }

                                                  var valid9 = _errs61 === errors;

                                                  if (!valid9) {
                                                    break;
                                                  }
                                                }
                                              } else {
                                                validate10.errors = [{
                                                  instancePath: instancePath + "/filters/whitelist/inverted-domains",
                                                  schemaPath: "#/properties/filters/properties/whitelist/properties/inverted-domains/type",
                                                  keyword: "type",
                                                  params: {
                                                    type: "array"
                                                  },
                                                  message: "must be array"
                                                }];
                                                return false;
                                              }
                                            }

                                            var valid7 = _errs59 === errors;
                                          } else {
                                            var valid7 = true;
                                          }

                                          if (valid7) {
                                            if (data25.enabled !== undefined) {
                                              const _errs63 = errors;

                                              if (typeof data25.enabled !== "boolean") {
                                                validate10.errors = [{
                                                  instancePath: instancePath + "/filters/whitelist/enabled",
                                                  schemaPath: "#/properties/filters/properties/whitelist/properties/enabled/type",
                                                  keyword: "type",
                                                  params: {
                                                    type: "boolean"
                                                  },
                                                  message: "must be boolean"
                                                }];
                                                return false;
                                              }

                                              var valid7 = _errs63 === errors;
                                            } else {
                                              var valid7 = true;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  } else {
                                    validate10.errors = [{
                                      instancePath: instancePath + "/filters/whitelist",
                                      schemaPath: "#/properties/filters/properties/whitelist/type",
                                      keyword: "type",
                                      params: {
                                        type: "object"
                                      },
                                      message: "must be object"
                                    }];
                                    return false;
                                  }
                                }

                                var valid3 = _errs51 === errors;
                              } else {
                                var valid3 = true;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate10.errors = [{
                      instancePath: instancePath + "/filters",
                      schemaPath: "#/properties/filters/type",
                      keyword: "type",
                      params: {
                        type: "object"
                      },
                      message: "must be object"
                    }];
                    return false;
                  }
                }

                var valid0 = _errs31 === errors;
              } else {
                var valid0 = true;
              }

              if (valid0) {
                if (data.stealth !== undefined) {
                  let data32 = data.stealth;
                  const _errs65 = errors;

                  if (errors === _errs65) {
                    if (data32 && typeof data32 == "object" && !Array.isArray(data32)) {
                      let missing6;

                      if (data32.stealth_disable_stealth_mode === undefined && (missing6 = "stealth_disable_stealth_mode") || data32["stealth-hide-referrer"] === undefined && (missing6 = "stealth-hide-referrer") || data32["stealth-hide-search-queries"] === undefined && (missing6 = "stealth-hide-search-queries") || data32["stealth-send-do-not-track"] === undefined && (missing6 = "stealth-send-do-not-track") || data32["stealth-block-webrtc"] === undefined && (missing6 = "stealth-block-webrtc") || data32["stealth-block-third-party-cookies"] === undefined && (missing6 = "stealth-block-third-party-cookies") || data32["stealth-block-first-party-cookies"] === undefined && (missing6 = "stealth-block-first-party-cookies") || data32["strip-tracking-parameters"] === undefined && (missing6 = "strip-tracking-parameters")) {
                        validate10.errors = [{
                          instancePath: instancePath + "/stealth",
                          schemaPath: "#/properties/stealth/required",
                          keyword: "required",
                          params: {
                            missingProperty: missing6
                          },
                          message: "must have required property '" + missing6 + "'"
                        }];
                        return false;
                      } else {
                        if (data32.stealth_disable_stealth_mode !== undefined) {
                          const _errs67 = errors;

                          if (typeof data32.stealth_disable_stealth_mode !== "boolean") {
                            validate10.errors = [{
                              instancePath: instancePath + "/stealth/stealth_disable_stealth_mode",
                              schemaPath: "#/properties/stealth/properties/stealth_disable_stealth_mode/type",
                              keyword: "type",
                              params: {
                                type: "boolean"
                              },
                              message: "must be boolean"
                            }];
                            return false;
                          }

                          var valid10 = _errs67 === errors;
                        } else {
                          var valid10 = true;
                        }

                        if (valid10) {
                          if (data32["stealth-hide-referrer"] !== undefined) {
                            const _errs69 = errors;

                            if (typeof data32["stealth-hide-referrer"] !== "boolean") {
                              validate10.errors = [{
                                instancePath: instancePath + "/stealth/stealth-hide-referrer",
                                schemaPath: "#/properties/stealth/properties/stealth-hide-referrer/type",
                                keyword: "type",
                                params: {
                                  type: "boolean"
                                },
                                message: "must be boolean"
                              }];
                              return false;
                            }

                            var valid10 = _errs69 === errors;
                          } else {
                            var valid10 = true;
                          }

                          if (valid10) {
                            if (data32["stealth-hide-search-queries"] !== undefined) {
                              const _errs71 = errors;

                              if (typeof data32["stealth-hide-search-queries"] !== "boolean") {
                                validate10.errors = [{
                                  instancePath: instancePath + "/stealth/stealth-hide-search-queries",
                                  schemaPath: "#/properties/stealth/properties/stealth-hide-search-queries/type",
                                  keyword: "type",
                                  params: {
                                    type: "boolean"
                                  },
                                  message: "must be boolean"
                                }];
                                return false;
                              }

                              var valid10 = _errs71 === errors;
                            } else {
                              var valid10 = true;
                            }

                            if (valid10) {
                              if (data32["stealth-send-do-not-track"] !== undefined) {
                                const _errs73 = errors;

                                if (typeof data32["stealth-send-do-not-track"] !== "boolean") {
                                  validate10.errors = [{
                                    instancePath: instancePath + "/stealth/stealth-send-do-not-track",
                                    schemaPath: "#/properties/stealth/properties/stealth-send-do-not-track/type",
                                    keyword: "type",
                                    params: {
                                      type: "boolean"
                                    },
                                    message: "must be boolean"
                                  }];
                                  return false;
                                }

                                var valid10 = _errs73 === errors;
                              } else {
                                var valid10 = true;
                              }

                              if (valid10) {
                                if (data32["stealth-block-webrtc"] !== undefined) {
                                  const _errs75 = errors;

                                  if (typeof data32["stealth-block-webrtc"] !== "boolean") {
                                    validate10.errors = [{
                                      instancePath: instancePath + "/stealth/stealth-block-webrtc",
                                      schemaPath: "#/properties/stealth/properties/stealth-block-webrtc/type",
                                      keyword: "type",
                                      params: {
                                        type: "boolean"
                                      },
                                      message: "must be boolean"
                                    }];
                                    return false;
                                  }

                                  var valid10 = _errs75 === errors;
                                } else {
                                  var valid10 = true;
                                }

                                if (valid10) {
                                  if (data32["stealth-block-third-party-cookies"] !== undefined) {
                                    const _errs77 = errors;

                                    if (typeof data32["stealth-block-third-party-cookies"] !== "boolean") {
                                      validate10.errors = [{
                                        instancePath: instancePath + "/stealth/stealth-block-third-party-cookies",
                                        schemaPath: "#/properties/stealth/properties/stealth-block-third-party-cookies/type",
                                        keyword: "type",
                                        params: {
                                          type: "boolean"
                                        },
                                        message: "must be boolean"
                                      }];
                                      return false;
                                    }

                                    var valid10 = _errs77 === errors;
                                  } else {
                                    var valid10 = true;
                                  }

                                  if (valid10) {
                                    if (data32["stealth-block-first-party-cookies"] !== undefined) {
                                      const _errs79 = errors;

                                      if (typeof data32["stealth-block-first-party-cookies"] !== "boolean") {
                                        validate10.errors = [{
                                          instancePath: instancePath + "/stealth/stealth-block-first-party-cookies",
                                          schemaPath: "#/properties/stealth/properties/stealth-block-first-party-cookies/type",
                                          keyword: "type",
                                          params: {
                                            type: "boolean"
                                          },
                                          message: "must be boolean"
                                        }];
                                        return false;
                                      }

                                      var valid10 = _errs79 === errors;
                                    } else {
                                      var valid10 = true;
                                    }

                                    if (valid10) {
                                      if (data32["block-known-trackers"] !== undefined) {
                                        const _errs81 = errors;

                                        if (typeof data32["block-known-trackers"] !== "boolean") {
                                          validate10.errors = [{
                                            instancePath: instancePath + "/stealth/block-known-trackers",
                                            schemaPath: "#/properties/stealth/properties/block-known-trackers/type",
                                            keyword: "type",
                                            params: {
                                              type: "boolean"
                                            },
                                            message: "must be boolean"
                                          }];
                                          return false;
                                        }

                                        var valid10 = _errs81 === errors;
                                      } else {
                                        var valid10 = true;
                                      }

                                      if (valid10) {
                                        if (data32["strip-tracking-parameters"] !== undefined) {
                                          const _errs83 = errors;

                                          if (typeof data32["strip-tracking-parameters"] !== "boolean") {
                                            validate10.errors = [{
                                              instancePath: instancePath + "/stealth/strip-tracking-parameters",
                                              schemaPath: "#/properties/stealth/properties/strip-tracking-parameters/type",
                                              keyword: "type",
                                              params: {
                                                type: "boolean"
                                              },
                                              message: "must be boolean"
                                            }];
                                            return false;
                                          }

                                          var valid10 = _errs83 === errors;
                                        } else {
                                          var valid10 = true;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      validate10.errors = [{
                        instancePath: instancePath + "/stealth",
                        schemaPath: "#/properties/stealth/type",
                        keyword: "type",
                        params: {
                          type: "object"
                        },
                        message: "must be object"
                      }];
                      return false;
                    }
                  }

                  var valid0 = _errs65 === errors;
                } else {
                  var valid0 = true;
                }
              }
            }
          }
        }
      }
    } else {
      validate10.errors = [{
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {
          type: "object"
        },
        message: "must be object"
      }];
      return false;
    }
  }

  validate10.errors = vErrors;
  return errors === 0;
}

/***/ }),

/***/ 83485:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "O": () => (/* binding */ parseContentTypeFromUrlPath),
/* harmony export */   "l": () => (/* binding */ RequestTypes)
/* harmony export */ });
/* harmony import */ var _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68261);

/**
 * Request types enumeration
 */

const RequestTypes = {
  /**
   * Document that is loaded for a top-level frame
   */
  DOCUMENT: 'DOCUMENT',

  /**
   * Document that is loaded for an embedded frame (iframe)
   */
  SUBDOCUMENT: 'SUBDOCUMENT',
  SCRIPT: 'SCRIPT',
  STYLESHEET: 'STYLESHEET',
  OBJECT: 'OBJECT',
  IMAGE: 'IMAGE',
  XMLHTTPREQUEST: 'XMLHTTPREQUEST',
  MEDIA: 'MEDIA',
  FONT: 'FONT',
  WEBSOCKET: 'WEBSOCKET',
  WEBRTC: 'WEBRTC',
  OTHER: 'OTHER',
  CSP: 'CSP',
  COOKIE: 'COOKIE',
  PING: 'PING',
  CSP_REPORT: 'CSP_REPORT',

  /**
   * Transforms to TSUrlFilter.RequestType
   *
   * @param requestType
   * @return {number}
   */
  transformRequestType(requestType) {
    const contentTypes = RequestTypes;

    switch (requestType) {
      case contentTypes.DOCUMENT:
        return _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Document */ .x.Document;

      case contentTypes.SUBDOCUMENT:
        return _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Subdocument */ .x.Subdocument;

      case contentTypes.STYLESHEET:
        return _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Stylesheet */ .x.Stylesheet;

      case contentTypes.FONT:
        return _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Font */ .x.Font;

      case contentTypes.IMAGE:
        return _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Image */ .x.Image;

      case contentTypes.MEDIA:
        return _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Media */ .x.Media;

      case contentTypes.OBJECT:
        return _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Object */ .x.Object;

      case contentTypes.SCRIPT:
        return _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Script */ .x.Script;

      case contentTypes.XMLHTTPREQUEST:
        return _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.XmlHttpRequest */ .x.XmlHttpRequest;

      case contentTypes.WEBSOCKET:
        return _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Websocket */ .x.Websocket;

      case contentTypes.WEBRTC:
        return _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Webrtc */ .x.Webrtc;

      case contentTypes.PING:
        return _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Ping */ .x.Ping;

      default:
        return _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Other */ .x.Other;
    }
  },

  /**
   * Transforms from TSUrlFilter.RequestType
   *
   * @param requestType
   * @return {string}
   */
  transformRequestTypeFromTs(requestType) {
    const contentTypes = RequestTypes;

    switch (requestType) {
      case _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Document */ .x.Document:
        return contentTypes.DOCUMENT;

      case _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Subdocument */ .x.Subdocument:
        return contentTypes.SUBDOCUMENT;

      case _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Stylesheet */ .x.Stylesheet:
        return contentTypes.STYLESHEET;

      case _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Font */ .x.Font:
        return contentTypes.FONT;

      case _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Image */ .x.Image:
        return contentTypes.IMAGE;

      case _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Media */ .x.Media:
        return contentTypes.MEDIA;

      case _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Object */ .x.Object:
        return contentTypes.OBJECT;

      case _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Script */ .x.Script:
        return contentTypes.SCRIPT;

      case _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.XmlHttpRequest */ .x.XmlHttpRequest:
        return contentTypes.XMLHTTPREQUEST;

      case _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Websocket */ .x.Websocket:
        return contentTypes.WEBSOCKET;

      case _adguard_tsurlfilter_dist_es_request_type__WEBPACK_IMPORTED_MODULE_0__/* .RequestType.Ping */ .x.Ping:
        return contentTypes.PING;

      default:
        return contentTypes.OTHER;
    }
  }

};
/**
 * Parse content type from path
 * @param path Path
 * @returns {*} content type (RequestTypes.*) or null
 */

function parseContentTypeFromUrlPath(path) {
  const objectContentTypes = '.jar.swf.';
  const mediaContentTypes = '.mp4.flv.avi.m3u.webm.mpeg.3gp.3gpp.3g2.3gpp2.ogg.mov.qt.';
  const fontContentTypes = '.ttf.otf.woff.woff2.eot.';
  const imageContentTypes = '.ico.png.gif.jpg.jpeg.webp.';
  let ext = path.slice(-6);
  const pos = ext.lastIndexOf('.'); // Unable to parse extension from url

  if (pos === -1) {
    return null;
  }

  ext = `${ext.slice(pos)}.`;

  if (objectContentTypes.indexOf(ext) !== -1) {
    return RequestTypes.OBJECT;
  }

  if (mediaContentTypes.indexOf(ext) !== -1) {
    return RequestTypes.MEDIA;
  }

  if (fontContentTypes.indexOf(ext) !== -1) {
    return RequestTypes.FONT;
  }

  if (imageContentTypes.indexOf(ext) !== -1) {
    return RequestTypes.IMAGE;
  }

  return null;
}

/***/ }),

/***/ 71351:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VX": () => (/* binding */ runtimeImpl),
/* harmony export */   "ey": () => (/* binding */ addMinDurationTime)
/* harmony export */ });
/* unused harmony exports i18n, sleep, sleepIfNecessary */
/* harmony import */ var _background_extension_api_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92273);
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */

const runtimeImpl = (() => {
  return {
    onMessage: _background_extension_api_browser__WEBPACK_IMPORTED_MODULE_0__/* .browser.runtime.onMessage */ .X.runtime.onMessage,
    sendMessage: _background_extension_api_browser__WEBPACK_IMPORTED_MODULE_0__/* .browser.runtime.sendMessage */ .X.runtime.sendMessage
  };
})(); // eslint-disable-next-line prefer-destructuring

const i18n = _background_extension_api_browser__WEBPACK_IMPORTED_MODULE_0__/* .browser.i18n */ .X.i18n;
/**
 * Sleeps given period of time
 * @param wait
 * @returns {Promise<unknown>}
 */

const sleep = wait => {
  return new Promise(resolve => {
    setTimeout(resolve, wait);
  });
};
/**
 * Sleeps necessary period of time if minimum duration didn't pass since entry time
 * @param {number} entryTimeMs
 * @param {number} minDurationMs
 * @returns {Promise<void>}
 */

const sleepIfNecessary = async (entryTimeMs, minDurationMs) => {
  if (Date.now() - entryTimeMs < minDurationMs) {
    await sleep(minDurationMs - (Date.now() - entryTimeMs));
  }
};
/**
 * Executes async function with at least required time
 * @param fn
 * @param minDurationMs
 */

const addMinDurationTime = (fn, minDurationMs) => {
  return async (...args) => {
    const start = Date.now();

    try {
      const response = await fn(...args);
      await sleepIfNecessary(start, minDurationMs);
      return response;
    } catch (e) {
      await sleepIfNecessary(start, minDurationMs);
      throw e;
    }
  };
};

/***/ }),

/***/ 84568:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CI": () => (/* binding */ ANTIBANNER_GROUPS_ID),
/* harmony export */   "Jn": () => (/* binding */ STEALTH_ACTIONS),
/* harmony export */   "Oi": () => (/* binding */ FULLSCREEN_USER_RULES_EDITOR),
/* harmony export */   "Qp": () => (/* binding */ NOTIFIER_TYPES),
/* harmony export */   "TJ": () => (/* binding */ NAVIGATION_TAGS),
/* harmony export */   "VC": () => (/* binding */ CUSTOM_FILTERS_GROUP_DISPLAY_NUMBER),
/* harmony export */   "XR": () => (/* binding */ TRUSTED_TAG),
/* harmony export */   "XS": () => (/* binding */ WASTE_CHARACTERS),
/* harmony export */   "du": () => (/* binding */ FILTERING_LOG),
/* harmony export */   "gu": () => (/* binding */ ANTIBANNER_FILTERS_ID),
/* harmony export */   "ih": () => (/* binding */ CUSTOM_FILTERS_START_ID),
/* harmony export */   "nn": () => (/* binding */ SCROLLBAR_WIDTH),
/* harmony export */   "oK": () => (/* binding */ MESSAGE_TYPES)
/* harmony export */ });
/**
 * Filter ids used in the code on the background page and filtering log page
 */
const ANTIBANNER_FILTERS_ID = {
  STEALTH_MODE_FILTER_ID: -1,
  USER_FILTER_ID: 0,
  RUSSIAN_FILTER_ID: 1,
  ENGLISH_FILTER_ID: 2,
  TRACKING_FILTER_ID: 3,
  SOCIAL_FILTER_ID: 4,
  SEARCH_AND_SELF_PROMO_FILTER_ID: 10,
  URL_TRACKING_FILTER_ID: 17,
  ALLOWLIST_FILTER_ID: 100,
  EASY_PRIVACY: 118,
  FANBOY_ANNOYANCES: 122,
  FANBOY_SOCIAL: 123,
  FANBOY_ENHANCED: 215,
  MOBILE_ADS_FILTER_ID: 11
};
/**
 * Group ids used in the code on the multiple entry points
 */

const ANTIBANNER_GROUPS_ID = {
  // custom filters group identifier
  CUSTOM_FILTERS_GROUP_ID: 0,
  PRIVACY_FILTERS_GROUP_ID: 2,
  // other filters group identifier
  OTHER_FILTERS_GROUP_ID: 6,
  // language-specific group identifier
  LANGUAGE_FILTERS_GROUP_ID: 7
};
/**
 * Stealth action bitwise masks used o the background page and on the filtering log page
 */

const STEALTH_ACTIONS = {
  HIDE_REFERRER: 1 << 0,
  HIDE_SEARCH_QUERIES: 1 << 1,
  BLOCK_CHROME_CLIENT_DATA: 1 << 2,
  SEND_DO_NOT_TRACK: 1 << 3,
  STRIPPED_TRACKING_URL: 1 << 4,
  FIRST_PARTY_COOKIES: 1 << 5,
  THIRD_PARTY_COOKIES: 1 << 6
};
/**
 * Message types used for message passing between background page and
 * other pages (popup, filtering log, content scripts)
 */

const MESSAGE_TYPES = {
  SCRIPTLET_CLOSE_WINDOW: 'scriptletCloseWindow',
  CREATE_EVENT_LISTENER: 'createEventListener',
  REMOVE_LISTENER: 'removeListener',
  OPEN_EXTENSION_STORE: 'openExtensionStore',
  OPEN_COMPARE_PAGE: 'openComparePage',
  ADD_AND_ENABLE_FILTER: 'addAndEnableFilter',
  APPLY_SETTINGS_JSON: 'applySettingsJson',
  OPEN_FILTERING_LOG: 'openFilteringLog',
  SET_FILTERING_LOG_WINDOW_STATE: 'setFilteringLogWindowState',
  OPEN_FULLSCREEN_USER_RULES: 'openFullscreenUserRules',
  RESET_BLOCKED_ADS_COUNT: 'resetBlockedAdsCount',
  RESET_SETTINGS: 'resetSettings',
  GET_USER_RULES: 'getUserRules',
  SAVE_USER_RULES: 'saveUserRules',
  GET_ALLOWLIST_DOMAINS: 'getAllowlistDomains',
  SAVE_ALLOWLIST_DOMAINS: 'saveAllowlistDomains',
  CHECK_ANTIBANNER_FILTERS_UPDATE: 'checkAntiBannerFiltersUpdate',
  DISABLE_FILTERS_GROUP: 'disableFiltersGroup',
  DISABLE_ANTIBANNER_FILTER: 'disableAntiBannerFilter',
  LOAD_CUSTOM_FILTER_INFO: 'loadCustomFilterInfo',
  SUBSCRIBE_TO_CUSTOM_FILTER: 'subscribeToCustomFilter',
  REMOVE_ANTIBANNER_FILTER: 'removeAntiBannerFilter',
  GET_TAB_INFO_FOR_POPUP: 'getTabInfoForPopup',
  CHANGE_APPLICATION_FILTERING_DISABLED: 'changeApplicationFilteringDisabled',
  OPEN_SETTINGS_TAB: 'openSettingsTab',
  OPEN_ASSISTANT: 'openAssistant',
  OPEN_ABUSE_TAB: 'openAbuseTab',
  OPEN_SITE_REPORT_TAB: 'openSiteReportTab',
  RESET_CUSTOM_RULES_FOR_PAGE: 'resetCustomRulesForPage',
  REMOVE_ALLOWLIST_DOMAIN: 'removeAllowlistDomainPopup',
  ADD_ALLOWLIST_DOMAIN_POPUP: 'addAllowlistDomainPopup',
  GET_STATISTICS_DATA: 'getStatisticsData',
  ON_OPEN_FILTERING_LOG_PAGE: 'onOpenFilteringLogPage',
  GET_FILTERING_LOG_DATA: 'getFilteringLogData',
  INITIALIZE_FRAME_SCRIPT: 'initializeFrameScript',
  ON_CLOSE_FILTERING_LOG_PAGE: 'onCloseFilteringLogPage',
  GET_FILTERING_INFO_BY_TAB_ID: 'getFilteringInfoByTabId',
  SYNCHRONIZE_OPEN_TABS: 'synchronizeOpenTabs',
  CLEAR_EVENTS_BY_TAB_ID: 'clearEventsByTabId',
  REFRESH_PAGE: 'refreshPage',
  OPEN_TAB: 'openTab',
  CONTENT_SCRIPT_ADD_USER_RULE: 'contentScriptAddUserRule',
  FILTERING_LOG_ADD_USER_RULE: 'filteringLogAddUserRule',
  DEVTOOLS_ADD_USER_RULE: 'devtoolsAddUserRule',
  UN_ALLOWLIST_FRAME: 'unAllowlistFrame',
  REMOVE_USER_RULE: 'removeUserRule',
  GET_TAB_FRAME_INFO_BY_ID: 'getTabFrameInfoById',
  ENABLE_FILTERS_GROUP: 'enableFiltersGroup',
  NOTIFY_LISTENERS: 'notifyListeners',
  ADD_LONG_LIVED_CONNECTION: 'addLongLivedConnection',
  GET_OPTIONS_DATA: 'getOptionsData',
  CHANGE_USER_SETTING: 'changeUserSetting',
  CHECK_REQUEST_FILTER_READY: 'checkRequestFilterReady',
  OPEN_THANKYOU_PAGE: 'openThankYouPage',
  OPEN_SAFEBROWSING_TRUSTED: 'openSafebrowsingTrusted',
  GET_SELECTORS_AND_SCRIPTS: 'getSelectorsAndScripts',
  CHECK_PAGE_SCRIPT_WRAPPER_REQUEST: 'checkPageScriptWrapperRequest',
  PROCESS_SHOULD_COLLAPSE: 'processShouldCollapse',
  PROCESS_SHOULD_COLLAPSE_MANY: 'processShouldCollapseMany',
  ADD_FILTERING_SUBSCRIPTION: 'addFilterSubscription',
  SET_NOTIFICATION_VIEWED: 'setNotificationViewed',
  SAVE_CSS_HITS_STATS: 'saveCssHitStats',
  GET_COOKIE_RULES: 'getCookieRules',
  SAVE_COOKIE_LOG_EVENT: 'saveCookieRuleEvent',
  LOAD_SETTINGS_JSON: 'loadSettingsJson',
  ADD_URL_TO_TRUSTED: 'addUrlToTrusted',
  SET_PRESERVE_LOG_STATE: 'setPreserveLogState',
  GET_USER_RULES_EDITOR_DATA: 'getUserRulesEditorData',
  GET_EDITOR_STORAGE_CONTENT: 'getEditorStorageContent',
  SET_EDITOR_STORAGE_CONTENT: 'setEditorStorageContent',
  CONVERT_RULES_TEXT: 'convertRulesText'
};
const NOTIFIER_TYPES = {
  ADD_RULES: 'event.add.rules',
  REMOVE_RULE: 'event.remove.rule',
  UPDATE_FILTER_RULES: 'event.update.filter.rules',
  FILTER_GROUP_ENABLE_DISABLE: 'filter.group.enable.disable',
  // enabled or disabled filter group
  FILTER_ENABLE_DISABLE: 'event.filter.enable.disable',
  // Enabled or disabled
  FILTER_ADD_REMOVE: 'event.filter.add.remove',
  // Added or removed
  ADS_BLOCKED: 'event.ads.blocked',
  START_DOWNLOAD_FILTER: 'event.start.download.filter',
  SUCCESS_DOWNLOAD_FILTER: 'event.success.download.filter',
  ERROR_DOWNLOAD_FILTER: 'event.error.download.filter',
  ENABLE_FILTER_SHOW_POPUP: 'event.enable.filter.show.popup',
  LOG_EVENT: 'event.log.track',
  UPDATE_TAB_BUTTON_STATE: 'event.update.tab.button.state',
  REQUEST_FILTER_UPDATED: 'event.request.filter.updated',
  APPLICATION_INITIALIZED: 'event.application.initialized',
  APPLICATION_UPDATED: 'event.application.updated',
  CHANGE_PREFS: 'event.change.prefs',
  UPDATE_FILTERS_SHOW_POPUP: 'event.update.filters.show.popup',
  USER_FILTER_UPDATED: 'event.user.filter.updated',
  UPDATE_ALLOWLIST_FILTER_RULES: 'event.update.allowlist.filter.rules',
  SETTING_UPDATED: 'event.update.setting.value',
  FILTERS_UPDATE_CHECK_READY: 'event.update.filters.check',
  // Log events
  TAB_ADDED: 'log.tab.added',
  TAB_CLOSE: 'log.tab.close',
  TAB_UPDATE: 'log.tab.update',
  TAB_RESET: 'log.tab.reset',
  LOG_EVENT_ADDED: 'log.event.added',
  // Sync events
  SETTINGS_UPDATED: 'event.sync.finished',
  // Fullscreen user rules events
  FULLSCREEN_USER_RULES_EDITOR_UPDATED: 'event.user.rules.editor.updated'
};
const FULLSCREEN_USER_RULES_EDITOR = 'fullscreen_user_rules_editor';
const FILTERING_LOG = 'filtering-log';
const NAVIGATION_TAGS = {
  REGULAR: 'regular',
  PARTY: 'party'
};
/**
 * Trusted tag for custom filters
 */

const TRUSTED_TAG = 'trusted';
/**
 * Custom filters group display number
 *
 * @type {number}
 */

const CUSTOM_FILTERS_GROUP_DISPLAY_NUMBER = 99;
/**
 * Custom filters identifiers starts from this number
 *
 * @type {number}
 */

const CUSTOM_FILTERS_START_ID = 1000; // Unnecessary characters that will be replaced

const WASTE_CHARACTERS = /[.*+?^${}()|[\]\\]/g; // Custom scrollbar width

const SCROLLBAR_WIDTH = 12;

/***/ }),

/***/ 9224:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": () => (/* binding */ log)
/* harmony export */ });
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard Browser Extension. If not, see <http://www.gnu.org/licenses/>.
 */

/* eslint-disable no-console */

/**
 * Simple logger with log levels
 */
const log = (() => {
  // Redefine if you need it
  const CURRENT_LEVEL = 'INFO';
  const LEVELS = {
    ERROR: 1,
    WARN: 2,
    INFO: 3,
    DEBUG: 4
  };
  /**
   * Pretty-print javascript error
   */

  const errorToString = function (error) {
    return `${error.toString()}\nStack trace:\n${error.stack}`;
  };

  const getLocalTimeString = date => {
    const ONE_MINUTE_MS = 60 * 1000;
    const timeZoneOffsetMs = date.getTimezoneOffset() * ONE_MINUTE_MS;
    const localTime = new Date(date - timeZoneOffsetMs);
    return localTime.toISOString().replace('Z', '');
  };
  /**
   * Prints log message
   */


  const print = function (level, method, args) {
    // check log level
    if (LEVELS[CURRENT_LEVEL] < LEVELS[level]) {
      return;
    }

    if (!args || args.length === 0 || !args[0]) {
      return;
    }

    const str = `${args[0]}`;
    args = Array.prototype.slice.call(args, 1);
    let formatted = str.replace(/{(\d+)}/g, (match, number) => {
      if (typeof args[number] !== 'undefined') {
        let value = args[number];

        if (value instanceof Error) {
          value = errorToString(value);
        } else if (value && value.message) {
          value = value.message;
        } else if (typeof value === 'object') {
          value = JSON.stringify(value);
        }

        return value;
      }

      return match;
    });
    formatted = `${getLocalTimeString(new Date())}: ${formatted}`;
    console[method](formatted);
  };
  /**
   * Expose public API
   */


  return {
    debug(...args) {
      print('DEBUG', 'log', args);
    },

    info(...args) {
      print('INFO', 'info', args);
    },

    warn(...args) {
      print('WARN', 'info', args);
    },

    error(...args) {
      print('ERROR', 'error', args);
    }

  };
})();

/***/ }),

/***/ 39100:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j": () => (/* binding */ strings)
/* harmony export */ });
/**
 * Util class for work with strings
 */
const strings = (() => {
  const StringUtils = {
    isEmpty(str) {
      return !str || str.trim().length === 0;
    },

    startWith(str, prefix) {
      return str && str.indexOf(prefix) === 0;
    },

    endsWith(str, postfix) {
      return str.endsWith(postfix);
    },

    substringAfter(str, separator) {
      if (!str) {
        return str;
      }

      const index = str.indexOf(separator);
      return index < 0 ? '' : str.substring(index + separator.length);
    },

    substringBefore(str, separator) {
      if (!str || !separator) {
        return str;
      }

      const index = str.indexOf(separator);
      return index < 0 ? str : str.substring(0, index);
    },

    contains(str, searchString) {
      return str && str.indexOf(searchString) >= 0;
    },

    containsIgnoreCase(str, searchString) {
      return str && searchString && str.toUpperCase().indexOf(searchString.toUpperCase()) >= 0;
    },

    replaceAll(str, find, replace) {
      if (!str) {
        return str;
      }

      return str.split(find).join(replace);
    },

    join(array, separator, startIndex, endIndex) {
      if (!array) {
        return null;
      }

      if (!startIndex) {
        startIndex = 0;
      }

      if (!endIndex) {
        endIndex = array.length;
      }

      if (startIndex >= endIndex) {
        return '';
      }

      const buf = [];

      for (let i = startIndex; i < endIndex; i += 1) {
        buf.push(array[i]);
      }

      return buf.join(separator);
    },

    /**
     * Get string before regexp first match
     * @param {string} str
     * @param {RegExp} rx
     */
    getBeforeRegExp(str, rx) {
      const index = str.search(rx);
      return str.substring(0, index);
    },

    /**
     * Look for any symbol from "chars" array starting at "start" index or from the start of the string
     *
     * @param str   String to search
     * @param chars Chars to search for
     * @param start Start index (optional, inclusive)
     * @return int Index of the element found or null
     */
    indexOfAny(str, chars, start) {
      start = start || 0;

      if (typeof str === 'string' && str.length <= start) {
        return -1;
      }

      for (let i = start; i < str.length; i += 1) {
        const c = str.charAt(i);

        if (chars.indexOf(c) > -1) {
          return i;
        }
      }

      return -1;
    },

    /**
     * Splits string by a delimiter, ignoring escaped delimiters
     * @param str               String to split
     * @param delimiter         Delimiter
     * @param escapeCharacter   Escape character
     * @param preserveAllTokens If true - preserve empty entries.
     */
    splitByDelimiterWithEscapeCharacter(str, delimiter, escapeCharacter, preserveAllTokens) {
      const parts = [];

      if (this.isEmpty(str)) {
        return parts;
      }

      let sb = [];

      for (let i = 0; i < str.length; i += 1) {
        const c = str.charAt(i);

        if (c === delimiter) {
          if (i === 0) {// Ignore
          } else if (str.charAt(i - 1) === escapeCharacter) {
            sb.splice(sb.length - 1, 1);
            sb.push(c);
          } else if (preserveAllTokens || sb.length > 0) {
            const part = sb.join('');
            parts.push(part);
            sb = [];
          }
        } else {
          sb.push(c);
        }
      }

      if (preserveAllTokens || sb.length > 0) {
        parts.push(sb.join(''));
      }

      return parts;
    },

    /**
     * Serialize HTML element
     * @param element
     */
    elementToString(element) {
      const s = [];
      s.push('<');
      s.push(element.localName);
      const {
        attributes
      } = element;

      for (let i = 0; i < attributes.length; i += 1) {
        const attr = attributes[i];
        s.push(' ');
        s.push(attr.name);
        s.push('="');
        const value = attr.value === null ? '' : attr.value.replace(/"/g, '\\"');
        s.push(value);
        s.push('"');
      }

      s.push('>');
      return s.join('');
    },

    /**
     * Checks if the specified string starts with a substr at the specified index.
     * @param str - String to check
     * @param startIndex - Index to start checking from
     * @param substr - Substring to check
     * @return boolean true if it does start
     */
    startsAtIndexWith(str, startIndex, substr) {
      if (str.length - startIndex < substr.length) {
        return false;
      }

      for (let i = 0; i < substr.length; i += 1) {
        if (str.charAt(startIndex + i) !== substr.charAt(i)) {
          return false;
        }
      }

      return true;
    },

    /**
     * Checks if str has unquoted substr
     * @param str
     * @param substr
     */
    hasUnquotedSubstring(str, substr) {
      const quotes = ['"', "'", '/'];
      const stack = [];

      for (let i = 0; i < str.length; i += 1) {
        const cursor = str[i];

        if (stack.length === 0) {
          if (this.startsAtIndexWith(str, i, substr)) {
            return true;
          }
        }

        if (quotes.indexOf(cursor) >= 0 && (i === 0 || str[i - 1] !== '\\')) {
          const last = stack.pop();

          if (!last) {
            stack.push(cursor);
          } else if (last !== cursor) {
            stack.push(last);
            stack.push(cursor);
          }
        }
      }

      return false;
    }

  };
  return StringUtils;
})();

/***/ }),

/***/ 57122:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "a": () => (/* binding */ i18n)
/* harmony export */ });
/* harmony import */ var webextension_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53679);
/* harmony import */ var webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webextension_polyfill__WEBPACK_IMPORTED_MODULE_0__);

const i18n = {
  getMessage: (webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().i18n.getMessage),
  getUILanguage: (webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().i18n.getUILanguage),
  getBaseMessage: key => key,
  getBaseUILanguage: () => 'en'
};

/***/ }),

/***/ 99875:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "O": () => (/* binding */ translator)
/* harmony export */ });
/* harmony import */ var _adguard_translate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58396);
/* harmony import */ var _i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57122);


/**
 * Retrieves localised message by key, formats it and converts into string
 */

const translator = _adguard_translate__WEBPACK_IMPORTED_MODULE_0__/* .translate.createTranslator */ .Iu.createTranslator(_i18n__WEBPACK_IMPORTED_MODULE_1__/* .i18n */ .a);

/***/ }),

/***/ 3702:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CA": () => (/* binding */ isWindowsOs),
/* harmony export */   "CE": () => (/* binding */ chromeVersion),
/* harmony export */   "Dt": () => (/* binding */ isAndroid),
/* harmony export */   "Q5": () => (/* binding */ isMacOs),
/* harmony export */   "f0": () => (/* binding */ isOpera),
/* harmony export */   "kD": () => (/* binding */ isEdgeChromium),
/* harmony export */   "rI": () => (/* binding */ firefoxVersion),
/* harmony export */   "un": () => (/* binding */ isEdge),
/* harmony export */   "vU": () => (/* binding */ isFirefox),
/* harmony export */   "vs": () => (/* binding */ isYaBrowser)
/* harmony export */ });
/* unused harmony export isChrome */
/**
 * Check if current browser is as given
 * @param {string} browserName
 * @returns {boolean}
 */
const isTargetBrowser = browserName => {
  var _navigator$userAgentD;

  let brand;
  let uaStringName;

  if (browserName === 'Chrome') {
    brand = 'Google Chrome';
    uaStringName = 'Chrome';
  } else if (browserName === 'Firefox') {
    uaStringName = 'Firefox';
  } else if (browserName === 'Safari') {
    uaStringName = 'Safari';
  } else if (browserName === 'Opera') {
    brand = 'Opera';
    uaStringName = 'OPR';
  } else if (browserName === 'YaBrowser') {
    brand = 'Yandex';
    uaStringName = 'YaBrowser';
  } else if (browserName === 'Edge') {
    uaStringName = 'edge';
  } else if (browserName === 'EdgeChromium') {
    brand = 'Microsoft Edge';
    uaStringName = 'edg';
  }

  const brandsData = (_navigator$userAgentD = navigator.userAgentData) === null || _navigator$userAgentD === void 0 ? void 0 : _navigator$userAgentD.brands;

  if (!brandsData || !brand) {
    return navigator.userAgent.indexOf(uaStringName) >= 0;
  } // eslint-disable-next-line no-restricted-syntax


  for (const data of brandsData) {
    if (data.brand === brand) {
      return true;
    }
  }

  return false;
};
/**
 * Check if current platform is as given
 * @param {string} platformName
 * @returns
 */


const isTargetPlatform = platformName => {
  var _navigator$userAgentD2;

  const platformString = (_navigator$userAgentD2 = navigator.userAgentData) === null || _navigator$userAgentD2 === void 0 ? void 0 : _navigator$userAgentD2.platform;
  return platformString ? platformString.toUpperCase().indexOf(platformName) >= 0 : navigator.userAgent.toUpperCase().indexOf(platformName) >= 0;
};
/**
 * Get browser version by name
 * @param {string} browserName
 * @returns {number|null}
 */


const getBrowserVersion = browserName => {
  var _navigator$userAgentD3;

  let brand;
  let uaStringMask;

  if (browserName === 'Chrome') {
    brand = 'Google Chrome';
    uaStringMask = /\sChrome\/(\d+)\./;
  } else if (browserName === 'Firefox') {
    uaStringMask = /\sFirefox\/(\d+)\./;
  }

  const brandsData = (_navigator$userAgentD3 = navigator.userAgentData) === null || _navigator$userAgentD3 === void 0 ? void 0 : _navigator$userAgentD3.brands;

  if (!brandsData || !brand) {
    const match = uaStringMask.exec(navigator.userAgent);
    return match === null ? null : Number.parseInt(match[1], 10);
  } // eslint-disable-next-line no-restricted-syntax


  for (const data of brandsData) {
    if (data.brand === brand) {
      const {
        version
      } = data;
      return Number.parseInt(version, 10);
    }
  }

  return null;
};

const isChrome = isTargetBrowser('Chrome');
const isFirefox = isTargetBrowser('Firefox');
const isOpera = isTargetBrowser('Opera');
const isYaBrowser = isTargetBrowser('YaBrowser');
const isEdge = isTargetBrowser('Edge');
const isEdgeChromium = isTargetBrowser('EdgeChromium');
const chromeVersion = getBrowserVersion('Chrome');
const firefoxVersion = getBrowserVersion('Firefox');
const isMacOs = isTargetPlatform('MAC');
const isWindowsOs = isTargetPlatform('WIN');
const isAndroid = isTargetPlatform('ANDROID');

/***/ }),

/***/ 32155:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "D2": () => (/* binding */ CHANGELOG_URL),
/* harmony export */   "Kd": () => (/* binding */ GITHUB_URL),
/* harmony export */   "Sb": () => (/* binding */ PRIVACY_URL),
/* harmony export */   "Y0": () => (/* binding */ GLOBAL_PRIVACY_CONTROL_URL),
/* harmony export */   "YH": () => (/* binding */ ACKNOWLEDGMENTS_URL),
/* harmony export */   "Z5": () => (/* binding */ DO_NOT_TRACK_URL),
/* harmony export */   "cC": () => (/* binding */ APPEARANCE_THEMES),
/* harmony export */   "eN": () => (/* binding */ DEFAULT_THIRD_PARTY_COOKIES_SELF_DESTRUCT_MIN),
/* harmony export */   "l7": () => (/* binding */ HOW_TO_CREATE_RULES_URL),
/* harmony export */   "o6": () => (/* binding */ WEBSITE_URL),
/* harmony export */   "pR": () => (/* binding */ COMPARE_URL),
/* harmony export */   "sn": () => (/* binding */ DISCUSS_URL),
/* harmony export */   "uj": () => (/* binding */ DEFAULT_FIRST_PARTY_COOKIES_SELF_DESTRUCT_MIN),
/* harmony export */   "wk": () => (/* binding */ BROWSER_ADDON_STORE_LINKS)
/* harmony export */ });
/* eslint-disable max-len */
const PRIVACY_URL = 'https://link.adtidy.org/forward.html?action=privacy&from=options_screen&app=browser_extension';
const ACKNOWLEDGMENTS_URL = 'https://link.adtidy.org/forward.html?action=acknowledgments&from=options_screen&app=browser_extension';
const GITHUB_URL = 'https://link.adtidy.org/forward.html?action=github_options&from=options_screen&app=browser_extension';
const WEBSITE_URL = 'https://link.adtidy.org/forward.html?action=adguard_site&from=options_screen_footer&app=browser_extension';
const DISCUSS_URL = 'https://link.adtidy.org/forward.html?action=discuss&from=options_screen&app=browser_extension';
const COMPARE_URL = 'https://link.adtidy.org/forward.html?action=compare&from=options_screen&app=browser_extension';
const CHANGELOG_URL = 'https://link.adtidy.org/forward.html?action=github_version_popup&from=options_screen&app=browser_extension';
const GLOBAL_PRIVACY_CONTROL_URL = 'https://link.adtidy.org/forward.html?action=global_privacy_control&from=options_screen&app=browser_extension';
const DO_NOT_TRACK_URL = 'https://link.adtidy.org/forward.html?action=do_not_track&from=options_screen&app=browser_extension';
const HOW_TO_CREATE_RULES_URL = 'https://link.adtidy.org/forward.html?action=userfilter_description&from=options&app=browser_extension';
const DEFAULT_FIRST_PARTY_COOKIES_SELF_DESTRUCT_MIN = 4320;
const DEFAULT_THIRD_PARTY_COOKIES_SELF_DESTRUCT_MIN = 2880;
const APPEARANCE_THEMES = {
  SYSTEM: 'system',
  DARK: 'dark',
  LIGHT: 'light'
};
const BROWSER_ADDON_STORE_LINKS = {
  CHROME: 'https://agrd.io/extension_chrome',
  FIREFOX: 'https://agrd.io/extension_firefox',
  OPERA: 'https://agrd.io/extension_opera',
  EDGE: 'https://agrd.io/extension_edge'
};

/***/ }),

/***/ 73800:
/***/ ((module) => {

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * As it is not possible to use one library in node and browser environments,
 * we have to implementation of simple file download interface.
 * The one for node uses axios, the one for browser XMLHttpRequest.
 *
 * @type {{getLocalFile, getExternalFile}}
 */
module.exports = (() => {
    'use strict';

    /**
     * If url protocol is not http or https return true, else false
     * @param url
     * @returns {boolean}
     */
    const isLocal = (url) => {
        const parsedUrl = new URL(url);
        const protocols = ['http:', 'https:'];
        return !protocols.includes(parsedUrl.protocol);
    };

    /**
     * Executes async request via fetch
     * fetch doesn't allow to download urls with file:// scheme
     *
     * @param url Url
     * @param contentType Content type
     * @returns {Promise}
     */
    const executeRequestAsyncFetch = async (url, contentType) => {
        const response = await fetch(url, {
            cache: 'no-cache',
            headers: {
                Pragma: 'no-cache',
                'Content-Type': contentType,
            }
        });

        if (response.status !== 200 && response.status !== 0) {
            throw new Error(`Response status for url ${url} is invalid: ${response.status}`);
        }

        // Don't check response headers if url is local,
        // because edge extension doesn't provide headers for such url
        if (!isLocal(response.url)) {
            const responseContentType = response.headers.get('Content-Type');
            if (!responseContentType || !responseContentType.includes(contentType)) {
                throw new Error(`Response content type should be: "${contentType}"`);
            }
        }

        const responseText = await response.text();

        return responseText.trim().split(/[\r\n]+/);
    };

    /**
     * Executes async request via XMLHttpRequest
     * XMLHttpRequest is undefined in the service worker
     *
     * @param {string} url Url
     * @param {string} contentType Content type
     * @returns {Promise}
     */
    const executeRequestAsyncXhr = (url, contentType) => {
        return new Promise((resolve, reject) => {
            const onRequestLoad = (response) => {
                if (response.status !== 200 && response.status !== 0) {
                    reject(new Error(`Response status for url ${url} is invalid: ${response.status}`));
                }

                const responseText = response.responseText ? response.responseText : response.data;

                // Don't check response headers if url is local,
                // because edge extension doesn't provide headers for such url
                if (!isLocal(response.responseURL)) {
                    const responseContentType = response.getResponseHeader('Content-Type');
                    if (!responseContentType || !responseContentType.includes(contentType)) {
                        reject(new Error(`Response content type should be: "${contentType}"`));
                    }
                }
                const lines = responseText.trim().split(/[\r\n]+/);
                resolve(lines);
            };

            const request = new XMLHttpRequest();

            try {
                request.open('GET', url);
                request.setRequestHeader('Pragma', 'no-cache');
                request.overrideMimeType(contentType);
                request.mozBackgroundRequest = true;
                request.onload = function () {
                    onRequestLoad(request);
                };
                request.onerror = () => reject(new Error(`Request error happened: ${request.statusText || 'status text empty'}`));
                request.onabort = () => reject(new Error(`Request was aborted with status text: ${request.statusText}`));
                request.ontimeout = () => reject(new Error(`Request timed out with status text: ${request.statusText}`));

                request.send(null);
            } catch (ex) {
                reject(ex);
            }
        });
    };

    /**
     * Downloads filter rules from external url
     *
     * @param {string} url Filter file absolute URL or relative path
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const getExternalFile = (url) => {
        return executeRequestAsyncFetch(url, 'text/plain');
    };

    /**
     * Get filter rules from local path
     *
     * @param {string} url local path
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const getLocalFile = (url) => {
        if (typeof XMLHttpRequest !== 'undefined') {
            return executeRequestAsyncXhr(url, 'text/plain');
        }
        if (typeof fetch !== 'undefined') {
            return executeRequestAsyncFetch(url, 'text/plain');
        }
        throw new Error('XMLHttpRequest or fetch are undefined, getting local files inside service worker is not working');
    };

    return {
        getLocalFile: getLocalFile,
        getExternalFile: getExternalFile,
    };
})();


/***/ }),

/***/ 70652:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * The utility tool resolves preprocessor directives in filter content.
 *
 * Directives syntax:
 * !#if, !#endif - filters maintainers can use these conditions to supply different rules depending on the ad blocker type.
 * condition - just like in some popular programming languages, pre-processor conditions are based on constants declared by ad blockers. Ad blocker authors define on their own what exact constants do they declare.
 * !#include - this directive allows to include contents of a specified file into the filter.
 *
 * Condition constants should be declared in FilterCompilerConditionsConstants
 *
 * More details:
 * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/917
 */
const FiltersDownloaderCreator = (FileDownloadWrapper) => {
    "use strict";

    const CONDITION_DIRECTIVE_START = "!#if";
    const CONDITION_DIRECTIVE_END = "!#endif";

    const CONDITION_OPERATOR_NOT = "!";
    const CONDITION_OPERATOR_AND = "&&";
    const CONDITION_OPERATOR_OR = "||";
    const CONDITION_BRACKET_OPEN_CHAR = "(";
    const CONDITION_BRACKET_CLOSE_CHAR = ")";

    const INCLUDE_DIRECTIVE = "!#include";

    const REGEXP_ABSOLUTE_URL = /^([a-z]+:\/\/|\/\/)/i;
    const REGEXP_EXTERNAL_ABSOLUTE_URL = /^((?!file)[a-z]+:\/\/|\/\/)/i;

    /**
     * Checks brackets in string
     *
     * @param str
     */
    const checkBracketsBalance = (str) => {
        let depth = 0;
        for (let i in str) {
            if (str[i] === CONDITION_BRACKET_OPEN_CHAR) {
                // if the char is an opening parenthesis then we increase the depth
                depth++;
            } else if (str[i] === CONDITION_BRACKET_CLOSE_CHAR) {
                // if the char is an closing parenthesis then we decrease the depth
                depth--;
            }
            //  if the depth is negative we have a closing parenthesis
            //  before any matching opening parenthesis
            if (depth < 0) {
                return false;
            }
        }
        // If the depth is not null then a closing parenthesis is missing
        if (depth > 0) {
            return false;
        }

        return true;
    };

    /**
     * Finds end of condition block started with startIndex
     *
     * @param rules
     * @param startIndex
     */
    const findConditionEnd = (rules, startIndex) => {
        const stack = [];
        for (let j = startIndex; j < rules.length; j++) {
            let internalRule = rules[j];

            if (internalRule.startsWith(CONDITION_DIRECTIVE_START)) {
                stack.push(CONDITION_DIRECTIVE_START);

            } else if (internalRule.startsWith(CONDITION_DIRECTIVE_END)) {
                if (stack.length > 0) {
                    stack.pop();
                } else {
                    return j;
                }
            }
        }

        return -1;
    };

    /**
     * Resolves constant expression
     *
     * @param expression
     * @param definedProperties
     */
    const resolveConditionConstant = (expression, definedProperties) => {
        if (!expression) {
            throw new Error('Invalid directives: Empty condition');
        }

        let trim = expression.trim();
        return trim === "true" || definedProperties[trim];
    };

    /**
     * Calculates conditional expression
     *
     * @param expression
     * @param definedProperties
     */
    const resolveExpression = (expression, definedProperties) => {
        if (!expression) {
            throw new Error('Invalid directives: Empty condition');
        }

        expression = expression.trim();

        if (!checkBracketsBalance(expression)) {
            throw new Error('Invalid directives: Incorrect brackets: ' + expression);
        }

        //Replace bracketed expressions
        const openBracketIndex = expression.lastIndexOf(CONDITION_BRACKET_OPEN_CHAR);
        if (openBracketIndex !== -1) {
            const endBracketIndex = expression.indexOf(CONDITION_BRACKET_CLOSE_CHAR, openBracketIndex);
            const innerExpression = expression.substring(openBracketIndex + 1, endBracketIndex);
            const innerResult = resolveExpression(innerExpression, definedProperties);
            const resolvedInner = expression.substring(0, openBracketIndex) +
                innerResult + expression.substring(endBracketIndex + 1);

            return resolveExpression(resolvedInner, definedProperties);
        }

        let result;

        // Resolve logical operators
        const indexOfAndOperator = expression.indexOf(CONDITION_OPERATOR_AND);
        const indexOfOrOperator = expression.indexOf(CONDITION_OPERATOR_OR);
        const indexOfNotOperator = expression.indexOf(CONDITION_OPERATOR_NOT);

        if (indexOfOrOperator !== -1) {
            result = resolveExpression(expression.substring(0, indexOfOrOperator - 1), definedProperties) ||
                resolveExpression(expression.substring(indexOfOrOperator + CONDITION_OPERATOR_OR.length, expression.length), definedProperties);
        } else if (indexOfAndOperator !== -1) {
            result = resolveExpression(expression.substring(0, indexOfAndOperator - 1), definedProperties) &&
                resolveExpression(expression.substring(indexOfAndOperator + CONDITION_OPERATOR_AND.length, expression.length), definedProperties);
        } else if (indexOfNotOperator === 0) {
            result = !resolveExpression(expression.substring(CONDITION_OPERATOR_NOT.length), definedProperties);
        } else {
            result = resolveConditionConstant(expression, definedProperties);
        }

        return result;
    };

    /**
     * Validates and resolves condition directive
     *
     * @param directive
     * @param definedProperties
     */
    const resolveCondition = (directive, definedProperties) => {
        const expression = directive.substring(CONDITION_DIRECTIVE_START.length).trim();

        return resolveExpression(expression, definedProperties);
    };

    /**
     * Resolves conditions directives
     *
     * @param rules
     * @param definedProperties
     */
    const resolveConditions = (rules, definedProperties) => {
        if (!definedProperties) {
            return rules;
        }

        let result = [];

        for (let i = 0; i < rules.length; i++) {
            let rule = rules[i];

            if (rule.indexOf(CONDITION_DIRECTIVE_START) === 0) {
                let endLineIndex = findConditionEnd(rules, i + 1);
                if (endLineIndex === -1) {
                    throw new Error('Invalid directives: Condition end not found: ' + rule);
                }

                let conditionValue = resolveCondition(rule, definedProperties);
                if (conditionValue) {
                    let rulesUnderCondition = rules.slice(i + 1, endLineIndex);
                    // Resolve inner conditions in recursion
                    result = result.concat(resolveConditions(rulesUnderCondition, definedProperties));
                }

                // Skip to the end of block
                i = endLineIndex;
            } else if (rule.indexOf(CONDITION_DIRECTIVE_END) === 0) {
                // Found condition end without start
                throw new Error('Invalid directives: Found unexpected condition end: ' + rule);
            } else {
                result.push(rule);
            }
        }

        return result;
    };

    /**
     * Validates url to be the same origin with original filterUrl
     *
     * @param url
     * @param filterUrlOrigin
     */
    const validateUrl = function (url, filterUrlOrigin) {
        if (filterUrlOrigin) {
            if (REGEXP_ABSOLUTE_URL.test(url)) {

                // Include url is absolute
                const urlOrigin = parseURL(url).origin;
                const filterOrigin = parseURL(filterUrlOrigin).origin;
                if (urlOrigin !== filterOrigin) {
                    throw new Error('Include url is rejected with origin: ' + urlOrigin);
                }
            }
        }
    };

    /**
     * Validates and resolves include directive
     *
     * @param {string} line
     * @param {?string} filterOrigin Filter file URL origin or null
     * @param {?object} definedProperties An object with the defined properties. These properties might be used in pre-processor directives (`#if`, etc)
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const resolveInclude = function (line, filterOrigin, definedProperties) {
        if (line.indexOf(INCLUDE_DIRECTIVE) !== 0) {
            return Promise.resolve(line);
        } else {
            const url = line.substring(INCLUDE_DIRECTIVE.length).trim();
            validateUrl(url, filterOrigin);
            return downloadFilterRules(url, filterOrigin, definedProperties);
        }
    };

    /**
     * Resolves include directives
     *
     * @param {Array} rules   array of rules
     * @param {?string} filterOrigin Filter file URL origin or null
     * @param {?object} definedProperties An object with the defined properties. These properties might be used in pre-processor directives (`#if`, etc)
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const resolveIncludes = (rules, filterOrigin, definedProperties) => {
        const dfds = [];

        for (let rule of rules) {
            dfds.push(resolveInclude(rule, filterOrigin, definedProperties));
        }

        return Promise.all(dfds).then((values) => {
            let result = [];

            values.forEach(function (v) {
                if (Array.isArray(v)) {
                    result = result.concat(v);
                } else {
                    result.push(v);
                }
            });

            return result;
        });
    };

    /**
     * Compiles filter content
     *
     * @param {Array} rules Array of strings
     * @param {?string} filterUrlOrigin Filter file URL origin or null
     * @param {?object} definedProperties An object with the defined properties. These properties might be used in pre-processor directives (`#if`, etc)
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const compile = (rules, filterOrigin, definedProperties) => {
        try {
            // Resolve 'if' conditions
            const resolvedConditionsResult = resolveConditions(rules, definedProperties);

            // Resolve 'includes' directives
            return resolveIncludes(resolvedConditionsResult, filterOrigin, definedProperties);
        } catch (ex) {
            return Promise.reject(ex);
        }
    };

    /**
     * Downloads filter rules from url
     *
     * @param {string} url Filter file URL
     * @param {?string} filterUrlOrigin Filter file URL origin or null
     * @param {?object} definedProperties An object with the defined properties. These properties might be used in pre-processor directives (`#if`, etc)
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const downloadFilterRules = (url, filterUrlOrigin, definedProperties) => {
        if (REGEXP_EXTERNAL_ABSOLUTE_URL.test(url) || REGEXP_EXTERNAL_ABSOLUTE_URL.test(filterUrlOrigin)) {
            return externalDownload(url, filterUrlOrigin, definedProperties);
        } else {
            return getLocalFile(url, filterUrlOrigin, definedProperties);
        }
    };

    /**
     * Downloads filter rules from external url
     *
     * @param {string} url Filter file absolute URL or relative path
     * @param {?string} filterUrlOrigin Filter file URL origin or null
     * @param {?object} definedProperties An object with the defined properties. These properties might be used in pre-processor directives (`#if`, etc)
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const externalDownload = (url, filterUrlOrigin, definedProperties) => {

        // getting absolute url for external file with relative url
        if (!REGEXP_ABSOLUTE_URL.test(url) && REGEXP_ABSOLUTE_URL.test(filterUrlOrigin)) {
            url = `${filterUrlOrigin}/${url}`;
        }

        return FileDownloadWrapper.getExternalFile(url, filterUrlOrigin, definedProperties).then((lines) => {
            // Filter origin could change in case url contains subdirectories
            // https://github.com/AdguardTeam/FiltersRegistry/pull/256
            filterUrlOrigin = getFilterUrlOrigin(url, null);

            // Resolve 'if' conditions and 'includes' directives
            const resolvedConditionsResult = resolveConditions(lines, definedProperties);
            return resolveIncludes(resolvedConditionsResult, filterUrlOrigin, definedProperties);
        });
    };

    /**
     * Get filter rules from local path
     *
     * @param {string} url local path
     * @param {?string} filterUrlOrigin origin path
     * @param {?object} definedProperties An object with the defined properties
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const getLocalFile = (url, filterUrlOrigin, definedProperties) => {
        if (filterUrlOrigin) {
            url = `${filterUrlOrigin}/${url}`;
        }

        filterUrlOrigin = getFilterUrlOrigin(url, filterUrlOrigin);

        return FileDownloadWrapper.getLocalFile(url, filterUrlOrigin, definedProperties).then((lines) => {
            filterUrlOrigin = getFilterUrlOrigin(url, null);

            // Resolve 'if' conditions and 'includes' directives
            const resolvedConditionsResult = resolveConditions(lines, definedProperties);
            return resolveIncludes(resolvedConditionsResult, filterUrlOrigin, definedProperties);
        });
    };

    /**
     * Get the `filterUrlOrigin` from url for relative path resolve
     *
     * @param {string} url Filter file URL
     * @param {string|null} filterUrlOrigin  existing origin url
     * @returns {string} valid origin url
     */
    const getFilterUrlOrigin = (url, filterUrlOrigin) => {
        if (filterUrlOrigin) {
            return filterUrlOrigin;
        } else {
            return url.substring(0, url.lastIndexOf('/'));
        }
    };

    /**
     * Downloads a specified filter and interpretes all the pre-processor directives from there.
     *
     * @param {string} url Filter file URL
     * @param {Object} definedProperties An object with the defined properties. These properties might be used in pre-processor directives (`#if`, etc)
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const download = async (url, definedProperties) => {
        try {
            let filterUrlOrigin;
            if (url && REGEXP_EXTERNAL_ABSOLUTE_URL.test(url)) {
                filterUrlOrigin = getFilterUrlOrigin(url)
            }

            const response = await downloadFilterRules(url, filterUrlOrigin, definedProperties);

            // only included filters can be empty
            if (response && response.join().trim() == '') {
                throw new Error("Response is empty");
            }

            return response;
        } catch (ex) {
            return Promise.reject(ex);
        }
    };

    /**
     * Parse url
     *
     * @param {string} url
     * @returns {object}  parsed url data
     */
    const parseURL = (url) => {
        if (typeof URL !== 'undefined') {
            return new URL(url);
        } else {
            let URL = (__webpack_require__(83548).URL);
            return new URL(url);
        }
    };

    return {
        compile: compile,
        download: download,
        resolveConditions: resolveConditions,
        resolveIncludes: resolveIncludes,
        getFilterUrlOrigin: getFilterUrlOrigin
    };
};

module.exports = FiltersDownloaderCreator;


/***/ }),

/***/ 39317:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// This file replaces `index.js` in bundlers like webpack or Rollup,
// according to `browser` config in `package.json`.

const filtersDownloaderCreator = __webpack_require__(70652);
const FileDownloadWrapper = __webpack_require__(73800);

const FiltersDownloader = filtersDownloaderCreator(FileDownloadWrapper);

module.exports = FiltersDownloader;


/***/ }),

/***/ 68782:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
/**
 * AdGuard Scriptlets
 * Version 1.9.7
 */

(function (factory) {
     true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) :
    0;
})((function () {
    /**
     * Concat dependencies to scriptlet code
     *
     * @param {string} scriptlet string view of scriptlet
     * @returns {string} string view of scriptlet with attached dependencies
     */
    function attachDependencies(scriptlet) {
      const _scriptlet$injections = scriptlet.injections,
        injections = _scriptlet$injections === void 0 ? [] : _scriptlet$injections;
      return injections.reduce(function (accum, dep) {
        return "".concat(accum, "\n").concat(dep.toString());
      }, scriptlet.toString());
    }

    /**
     * Add scriptlet call to existing code
     *
     * @param {Function} scriptlet scriptlet func
     * @param {string} code scriptlet's string representation
     * @returns {string} wrapped scriptlet call
     */
    function addCall(scriptlet, code) {
      return "".concat(code, "\n    const updatedArgs = args ? [].concat(source).concat(args) : [source];\n    try {\n        ").concat(scriptlet.name, ".apply(this, updatedArgs);\n    } catch (e) {\n        console.log(e);\n    }");
    }

    /**
     * Wrap function into IIFE (Immediately invoked function expression)
     *
     * @example
     * const source = {
     *      args: ["aaa", "bbb"],
     *      name: 'noeval',
     * };
     * const code = "function noeval(source, args) { alert(source); } noeval.apply(this, args);"
     * const result = wrapInIIFE(source, code);
     *
     * // result
     * `(function(source, args) {
     *      function noeval(source) { alert(source); }
     *      noeval.apply(this, args);
     * )({"args": ["aaa", "bbb"], "name":"noeval"}, ["aaa", "bbb"])`
     * @param {Object} source - object with scriptlet properties
     * @param {string} code - scriptlet source code with dependencies
     * @param {boolean} redirect if function is redirect
     * @returns {string} full scriptlet code
     */
    function passSourceAndProps(source, code) {
      let redirect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (source.hit) {
        source.hit = source.hit.toString();
      }
      const sourceString = JSON.stringify(source);
      const argsString = source.args ? "[".concat(source.args.map(JSON.stringify), "]") : undefined;
      const params = argsString ? "".concat(sourceString, ", ").concat(argsString) : sourceString;
      if (redirect) {
        return "(function(source, args){\n".concat(code, "\n})(").concat(params, ");");
      }
      return "(".concat(code, ")(").concat(params, ");");
    }

    /**
     * Wrap code in no name function
     *
     * @param {string} code which must be wrapped
     * @returns {string} wrapped code
     */
    function wrapInNonameFunc(code) {
      return "function(source, args){\n".concat(code, "\n}");
    }

    /**
     * Converts object to array of pairs.
     * Object.entries() polyfill because it is not supported by IE
     * https://caniuse.com/?search=Object.entries
     *
     * @param {Object} object arbitrary object
     * @returns {Array} array of pairs
     */
    const getObjectEntries = function getObjectEntries(object) {
      const keys = Object.keys(object);
      const entries = [];
      keys.forEach(function (key) {
        return entries.push([key, object[key]]);
      });
      return entries;
    };

    /**
     * Converts array of pairs to object.
     * Object.fromEntries() polyfill because it is not supported by IE
     * https://caniuse.com/?search=Object.fromEntries
     *
     * @param {Array} entries - array of pairs
     * @returns {Object} result object
     */
    const getObjectFromEntries = function getObjectFromEntries(entries) {
      const output = entries.reduce(function (acc, el) {
        const key = el[0];
        const value = el[1];
        acc[key] = value;
        return acc;
      }, {});
      return output;
    };

    /**
     * Checks whether the obj is an empty object
     *
     * @param {Object} obj arbitrary object
     * @returns {boolean} if object is empty
     */
    const isEmptyObject = function isEmptyObject(obj) {
      return Object.keys(obj).length === 0 && !obj.prototype;
    };

    /**
     * Safely retrieve property descriptor
     *
     * @param {Object} obj target object
     * @param {string} prop target property
     * @returns {object|null} descriptor or null if it's not available or non-configurable
     */
    const safeGetDescriptor = function safeGetDescriptor(obj, prop) {
      const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      if (descriptor && descriptor.configurable) {
        return descriptor;
      }
      return null;
    };

    /**
     * Set getter and setter to property if it's configurable
     *
     * @param {Object} object target object with property
     * @param {string} property property name
     * @param {Object} descriptor contains getter and setter functions
     * @returns {boolean} is operation successful
     */
    function setPropertyAccess(object, property, descriptor) {
      const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
      if (currentDescriptor && !currentDescriptor.configurable) {
        return false;
      }
      Object.defineProperty(object, property, descriptor);
      return true;
    }

    /**
     * Determines whether the passed value is NaN
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN
     *
     * @param {any} num arbitrary value
     * @returns {boolean} if provided value is NaN
     */
    const nativeIsNaN = function nativeIsNaN(num) {
      // eslint-disable-next-line no-restricted-properties
      const native = Number.isNaN || window.isNaN;
      return native(num);
    };

    /**
     * Determines whether the passed value is a finite number
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite
     *
     * @param {any} num arbitrary value
     * @returns {boolean} if provided value is finite
     */
    const nativeIsFinite = function nativeIsFinite(num) {
      // eslint-disable-next-line no-restricted-properties
      const native = Number.isFinite || window.isFinite;
      return native(num);
    };

    /**
     * Parses string for a number, if possible, otherwise returns null.
     *
     * @param {any} rawString arbitrary string
     * @returns {number|null} number or null if string not parsable
     */
    const getNumberFromString = function getNumberFromString(rawString) {
      const parsedDelay = parseInt(rawString, 10);
      const validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
      return validDelay;
    };

    /**
     * Generate a random integer between two values, inclusive
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random#getting_a_random_integer_between_two_values_inclusive
     *
     * @param {number} min range minimum
     * @param {number} max range maximum
     * @returns {number} random number
     */
    function getRandomIntInclusive(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min + 1) + min);
    }

    /**
     * String.prototype.replaceAll polyfill
     *
     * @param {string} input input string
     * @param {string} substr to look for
     * @param {string} newSubstr replacement
     * @returns {string} result string
     */
    const replaceAll = function replaceAll(input, substr, newSubstr) {
      return input.split(substr).join(newSubstr);
    };

    /**
     * Escapes special chars in string
     *
     * @param {string} str raw string
     * @returns {string} string with escaped special characters
     */
    const escapeRegExp = function escapeRegExp(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    };

    /**
     * A literal string or regexp pattern wrapped in forward slashes.
     * For example, 'simpleStr' or '/adblock|_0x/'.
     *
     * @typedef {string} RawStrPattern
     */

    /**
     * Converts string to the regexp
     * TODO think about nested dependencies, but be careful with dependency loops
     *
     * @param {RawStrPattern} [input=''] literal string or regexp pattern; defaults to '' (empty string)
     * @returns {RegExp} regular expression; defaults to /.?/
     * @throws {SyntaxError} Throw an error for invalid regex pattern
     */
    const toRegExp = function toRegExp() {
      let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      const DEFAULT_VALUE = '.?';
      const FORWARD_SLASH = '/';
      if (input === '') {
        return new RegExp(DEFAULT_VALUE);
      }
      if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
        return new RegExp(input.slice(1, -1));
      }
      const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      return new RegExp(escaped);
    };

    /**
     * Checks whether the input string can be converted to regexp
     *
     * @param {RawStrPattern} input literal string or regexp pattern
     * @returns {boolean} if input can be converted to regexp
     */
    const isValidStrPattern = function isValidStrPattern(input) {
      const FORWARD_SLASH = '/';
      let str = escapeRegExp(input);
      if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
        str = input.slice(1, -1);
      }
      let isValid;
      try {
        isValid = new RegExp(str);
        isValid = true;
      } catch (e) {
        isValid = false;
      }
      return isValid;
    };

    /**
     * Get string before regexp first match
     *
     * @param {string} str input string
     * @param {RegExp} rx find pattern
     * @returns {string} result string
     */
    const getBeforeRegExp = function getBeforeRegExp(str, rx) {
      const index = str.search(rx);
      return str.substring(0, index);
    };

    /**
     * Checks whether the string starts with the substring
     *
     * @param {string} str full string
     * @param {string} prefix substring
     * @returns {boolean} if string start with the substring
     */
    const startsWith$1 = function startsWith(str, prefix) {
      // if str === '', (str && false) will return ''
      // that's why it has to be !!str
      return !!str && str.indexOf(prefix) === 0;
    };

    /**
     * Checks whether the string ends with the substring
     *
     * @param {string} str full string
     * @param {string} ending substring
     * @returns {boolean} string ends with the substring
     */
    const endsWith = function endsWith(str, ending) {
      // if str === '', (str && false) will return ''
      // that's why it has to be !!str
      return !!str && str.lastIndexOf(ending) === str.length - ending.length;
    };
    const substringAfter$1 = function substringAfter(str, separator) {
      if (!str) {
        return str;
      }
      const index = str.indexOf(separator);
      return index < 0 ? '' : str.substring(index + separator.length);
    };
    const substringBefore = function substringBefore(str, separator) {
      if (!str || !separator) {
        return str;
      }
      const index = str.indexOf(separator);
      return index < 0 ? str : str.substring(0, index);
    };

    /**
     * Wrap str in single quotes and replaces single quotes to double one
     *
     * @param {string} str input string
     * @returns {string} string with swapped quotes
     */
    const wrapInSingleQuotes = function wrapInSingleQuotes(str) {
      if (str[0] === '\'' && str[str.length - 1] === '\'' || str[0] === '"' && str[str.length - 1] === '"') {
        str = str.substring(1, str.length - 1);
      }
      // eslint-disable-next-line no-useless-escape
      str = str.replace(/\'/g, '"');
      return "'".concat(str, "'");
    };

    /**
     * Returns substring enclosed in the widest braces
     *
     * @param {string} str input string
     * @returns {string} substring
     */
    const getStringInBraces = function getStringInBraces(str) {
      const firstIndex = str.indexOf('(');
      const lastIndex = str.lastIndexOf(')');
      return str.substring(firstIndex + 1, lastIndex);
    };

    /**
     * Prepares RTCPeerConnection config as string for proper logging
     *
     * @param {any} config RTC config
     * @returns {string} stringified config
     */
    const convertRtcConfigToString = function convertRtcConfigToString(config) {
      const UNDEF_STR = 'undefined';
      let str = UNDEF_STR;
      if (config === null) {
        str = 'null';
      } else if (config instanceof Object) {
        const SERVERS_PROP_NAME = 'iceServers';
        const URLS_PROP_NAME = 'urls';
        /*
            const exampleConfig = {
                'iceServers': [
                    'urls': ['stun:35.66.206.188:443'],
                ],
            };
        */
        if (Object.prototype.hasOwnProperty.call(config, SERVERS_PROP_NAME) && Object.prototype.hasOwnProperty.call(config[SERVERS_PROP_NAME][0], URLS_PROP_NAME) && !!config[SERVERS_PROP_NAME][0][URLS_PROP_NAME]) {
          str = config[SERVERS_PROP_NAME][0][URLS_PROP_NAME].toString();
        }
      }
      return str;
    };

    /**
     * Checks whether the match input string can be converted to regexp,
     * used for match inputs with possible negation
     *
     * @param {string} match literal string or regexp pattern
     * @returns {boolean} true if input can be converted to regexp
     */
    const isValidMatchStr = function isValidMatchStr(match) {
      const INVERT_MARKER = '!';
      let str = match;
      if (startsWith$1(match, INVERT_MARKER)) {
        str = match.slice(1);
      }
      return isValidStrPattern(str);
    };

    /**
     * Validates the match input number,
     * used for match inputs with possible negation
     *
     * @param {string} match string of match number
     * @returns {boolean} if match number is valid
     */
    const isValidMatchNumber = function isValidMatchNumber(match) {
      const INVERT_MARKER = '!';
      let str = match;
      if (startsWith$1(match, INVERT_MARKER)) {
        str = match.slice(1);
      }
      const num = parseFloat(str);
      return !nativeIsNaN(num) && nativeIsFinite(num);
    };

    /**
     * @typedef {Object} MatchData
     * @property {boolean} isInvertedMatch if matching should be inverted
     * @property {RegExp} matchRegexp match value parsed into regex
     */

    /**
     * Parses match arg with possible negation for no matching.
     * Needed for prevent-setTimeout, prevent-setInterval,
     * prevent-requestAnimationFrame and prevent-window-open
     *
     * @param {string} match matching arg
     * @returns {MatchData} data prepared for matching
     */
    const parseMatchArg = function parseMatchArg(match) {
      const INVERT_MARKER = '!';
      // In case if "match" is "undefined" return "false"
      const isInvertedMatch = match ? match.startsWith(INVERT_MARKER) : false;
      const matchValue = isInvertedMatch ? match.slice(1) : match;
      const matchRegexp = toRegExp(matchValue);
      return {
        isInvertedMatch,
        matchRegexp,
        matchValue
      };
    };

    /**
     * @typedef {Object} DelayData
     * @property {boolean} isInvertedDelayMatch if matching should be inverted
     * @property {number|null} delayMatch parsed delay or null if delay is invalid
     */

    /**
     * Parses delay arg with possible negation for no matching.
     * Needed for prevent-setTimeout and prevent-setInterval
     *
     * @param {string} delay scriptlet's delay arg
     * @returns {DelayData} parsed delay data
     */
    const parseDelayArg = function parseDelayArg(delay) {
      const INVERT_MARKER = '!';
      const isInvertedDelayMatch = startsWith$1(delay, INVERT_MARKER);
      let delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;
      delayValue = parseInt(delayValue, 10);
      const delayMatch = nativeIsNaN(delayValue) ? null : delayValue;
      return {
        isInvertedDelayMatch,
        delayMatch
      };
    };

    /**
     * Converts object to string for logging
     *
     * @param {Object} obj data object
     * @returns {string} object's string representation
     */
    const objectToString = function objectToString(obj) {
      // In case if the type of passed obj is different than Object
      // https://github.com/AdguardTeam/Scriptlets/issues/282
      if (!obj || typeof obj !== 'object') {
        return String(obj);
      }
      return isEmptyObject(obj) ? '{}' : getObjectEntries(obj).map(function (pair) {
        const key = pair[0];
        const value = pair[1];
        let recordValueStr = value;
        if (value instanceof Object) {
          recordValueStr = "{ ".concat(objectToString(value), " }");
        }
        return "".concat(key, ":\"").concat(recordValueStr, "\"");
      }).join(' ');
    };

    /**
     * Converts types into a string
     *
     * @param {any} value input value type
     * @returns {string} type's string representation
     */
    const convertTypeToString = function convertTypeToString(value) {
      let output;
      if (typeof value === 'undefined') {
        output = 'undefined';
      } else if (typeof value === 'object') {
        if (value === null) {
          output = 'null';
        } else {
          output = objectToString(value);
        }
      } else {
        output = value.toString();
      }
      return output;
    };

    /**
     * Generate a random string, a length of the string is provided as an argument
     *
     * @param {number} length output's length
     * @returns {string} random string
     */
    function getRandomStrByLength(length) {
      let result = '';
      const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+=~';
      const charactersLength = characters.length;
      for (let i = 0; i < length; i += 1) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
      }
      return result;
    }

    /**
     * Generate a random string
     *
     * @param {string} customResponseText response text to include in output
     * @returns {string|null} random string or null if passed argument is invalid
     */
    function generateRandomResponse(customResponseText) {
      let customResponse = customResponseText;
      if (customResponse === 'true') {
        // Generate random alphanumeric string of 10 symbols
        customResponse = Math.random().toString(36).slice(-10);
        return customResponse;
      }
      customResponse = customResponse.replace('length:', '');
      const rangeRegex = /^\d+-\d+$/;
      // Return empty string if range is invalid
      if (!rangeRegex.test(customResponse)) {
        return null;
      }
      let rangeMin = getNumberFromString(customResponse.split('-')[0]);
      let rangeMax = getNumberFromString(customResponse.split('-')[1]);
      if (!nativeIsFinite(rangeMin) || !nativeIsFinite(rangeMax)) {
        return null;
      }

      // If rangeMin > rangeMax, swap variables
      if (rangeMin > rangeMax) {
        const temp = rangeMin;
        rangeMin = rangeMax;
        rangeMax = temp;
      }
      const LENGTH_RANGE_LIMIT = 500 * 1000;
      if (rangeMax > LENGTH_RANGE_LIMIT) {
        return null;
      }
      const length = getRandomIntInclusive(rangeMin, rangeMax);
      customResponse = getRandomStrByLength(length);
      return customResponse;
    }

    /**
     * Infers value from string argument
     * Inferring goes from more specific to more ambiguous options
     * Arrays, objects and strings are parsed via JSON.parse
     *
     * @param {string} value arbitrary string
     * @returns {any} converted value
     * @throws an error on unexpected input
     */
    function inferValue(value) {
      if (value === 'undefined') {
        return undefined;
      }
      if (value === 'false') {
        return false;
      }
      if (value === 'true') {
        return true;
      }
      if (value === 'null') {
        return null;
      }
      if (value === 'NaN') {
        return NaN;
      }

      // Number class constructor works 2 times faster than JSON.parse
      // and wont interpret mixed inputs like '123asd' as parseFloat would
      const MAX_ALLOWED_NUM = 32767;
      const numVal = Number(value);
      if (!nativeIsNaN(numVal)) {
        if (Math.abs(numVal) > MAX_ALLOWED_NUM) {
          throw new Error('number values bigger than 32767 are not allowed');
        }
        return numVal;
      }
      let errorMessage = "'".concat(value, "' value type can't be inferred");
      try {
        // Parse strings, arrays and objects represented as JSON strings
        // '[1,2,3,"string"]' > [1, 2, 3, 'string']
        // '"arbitrary string"' > 'arbitrary string'
        const parsableVal = JSON.parse(value);
        if (parsableVal instanceof Object || typeof parsableVal === 'string') {
          return parsableVal;
        }
      } catch (e) {
        errorMessage += ": ".concat(e);
      }
      throw new TypeError(errorMessage);
    }

    /**
     * Iterate over iterable argument and evaluate current state with transitions
     *
     * @param {Array|string} iterable rule or list or rules
     * @param {Object} transitions transtion functions
     * @param {string} init first transition name
     * @param {any} args arguments which should be passed to transition functions
     * @returns {string} state
     */
    function iterateWithTransitions(iterable, transitions, init, args) {
      let state = init || Object.keys(transitions)[0];
      for (let i = 0; i < iterable.length; i += 1) {
        state = transitions[state](iterable, i, args);
      }
      return state;
    }

    /**
     * AdGuard scriptlet rule mask
     */
    const ADG_SCRIPTLET_MASK = '#//scriptlet';

    /**
     * Helper to accumulate an array of strings char by char
     *
     * @returns {Object} object with helper methods
     */
    const wordSaver = function wordSaver() {
      let str = '';
      const strings = [];
      const saveSymb = function saveSymb(s) {
        str += s;
        return str;
      };
      const saveStr = function saveStr() {
        strings.push(str);
        str = '';
      };
      const getAll = function getAll() {
        return [...strings];
      };
      return {
        saveSymb,
        saveStr,
        getAll
      };
    };
    const substringAfter = function substringAfter(str, separator) {
      if (!str) {
        return str;
      }
      const index = str.indexOf(separator);
      return index < 0 ? '' : str.substring(index + separator.length);
    };

    /**
     * Parses scriptlet rule and validates its syntax.
     *
     * @param {string} ruleText Rule string
     *
     * @returns {{name: string, args: Array<string>}} Parsed rule data.
     * @throws An error on invalid rule syntax.
     */
    const parseRule = function parseRule(ruleText) {
      ruleText = substringAfter(ruleText, ADG_SCRIPTLET_MASK);
      /**
       * Transition names
       */
      const TRANSITION = {
        OPENED: 'opened',
        PARAM: 'param',
        CLOSED: 'closed'
      };

      /**
       * Transition function: the current index position in start, end or between params
       *
       * @param {string} rule rule string
       * @param {number} index index
       * @param {Object} Object helper object
       * @param {Object} Object.sep contains prop symb with current separator char
       * @throws {string} throws if given rule is not a scriptlet
       * @returns {string} transition
       */
      const opened = function opened(rule, index, _ref) {
        let sep = _ref.sep;
        const char = rule[index];
        let transition;
        switch (char) {
          case ' ':
          case '(':
          case ',':
            {
              transition = TRANSITION.OPENED;
              break;
            }
          case '\'':
          case '"':
            {
              sep.symb = char;
              transition = TRANSITION.PARAM;
              break;
            }
          case ')':
            {
              transition = index === rule.length - 1 ? TRANSITION.CLOSED : TRANSITION.OPENED;
              break;
            }
          default:
            {
              throw new Error('The rule is not a scriptlet');
            }
        }
        return transition;
      };
      /**
       * Transition function: the current index position inside param
       *
       * @param {string} rule rule string
       * @param {number} index index
       * @param {Object} Object helper object
       * @param {Object} Object.sep contains prop `symb` with current separator char
       * @param {Object} Object.saver helper which allow to save strings by car by char
       * @returns {void}
       */
      const param = function param(rule, index, _ref2) {
        let saver = _ref2.saver,
          sep = _ref2.sep;
        const char = rule[index];
        switch (char) {
          case '\'':
          case '"':
            {
              const preIndex = index - 1;
              const before = rule[preIndex];
              if (char === sep.symb && before !== '\\') {
                sep.symb = null;
                saver.saveStr();
                return TRANSITION.OPENED;
              }
            }
          // eslint-disable-next-line no-fallthrough
          default:
            {
              saver.saveSymb(char);
              return TRANSITION.PARAM;
            }
        }
      };
      const transitions = {
        [TRANSITION.OPENED]: opened,
        [TRANSITION.PARAM]: param,
        [TRANSITION.CLOSED]: function () {}
      };
      const sep = {
        symb: null
      };
      const saver = wordSaver();
      const state = iterateWithTransitions(ruleText, transitions, TRANSITION.OPENED, {
        sep,
        saver
      });
      if (state !== 'closed') {
        throw new Error("Invalid scriptlet rule ".concat(ruleText));
      }
      const args = saver.getAll();
      return {
        name: args[0],
        args: args.slice(1)
      };
    };

    /**
     * Validates event type
     *
     * @param {any} type event type
     * @returns {boolean} if type is valid
     */
    const validateType = function validateType(type) {
      // https://github.com/AdguardTeam/Scriptlets/issues/125
      return typeof type !== 'undefined';
    };

    /**
     * Validates event listener
     *
     * @param {any} listener event listener
     * @returns {boolean} if listener callback is valid
     */
    const validateListener = function validateListener(listener) {
      // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters
      return typeof listener !== 'undefined' && (typeof listener === 'function' || typeof listener === 'object'
      // https://github.com/AdguardTeam/Scriptlets/issues/76
      && listener !== null && typeof listener.handleEvent === 'function');
    };

    /**
     * @typedef {object|Function|null} EventListener
     */

    /**
     * Serialize valid event listener
     * https://developer.mozilla.org/en-US/docs/Web/API/EventListener
     *
     * @param {EventListener} listener valid listener
     * @returns {string} listener string
     */
    const listenerToString = function listenerToString(listener) {
      return typeof listener === 'function' ? listener.toString() : listener.handleEvent.toString();
    };

    const shouldMatchAnyDelay = function shouldMatchAnyDelay(delay) {
      return delay === '*';
    };

    /**
     * Handles input delay value
     *
     * @param {any} delay matchDelay argument of adjust-* scriptlets
     * @returns {number} proper number delay value
     */
    const getMatchDelay = function getMatchDelay(delay) {
      const DEFAULT_DELAY = 1000;
      const parsedDelay = parseInt(delay, 10);
      const delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY // default scriptlet value
      : parsedDelay;
      return delayMatch;
    };

    /**
     * Checks delay match condition
     *
     * @param {any} inputDelay matchDelay argument of adjust-* scriptlets
     * @param {number} realDelay delay argument of setTimeout/setInterval
     * @returns {boolean} if given delays match
     */
    const isDelayMatched = function isDelayMatched(inputDelay, realDelay) {
      return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);
    };

    /**
     * Handles input boost value
     *
     * @param {any} boost boost argument of adjust-* scriptlets
     * @returns {number} proper number boost multiplier value
     */
    const getBoostMultiplier = function getBoostMultiplier(boost) {
      const DEFAULT_MULTIPLIER = 0.05;
      // https://github.com/AdguardTeam/Scriptlets/issues/262
      const MIN_MULTIPLIER = 0.001;
      const MAX_MULTIPLIER = 50;
      const parsedBoost = parseFloat(boost);
      let boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER // default scriptlet value
      : parsedBoost;
      if (boostMultiplier < MIN_MULTIPLIER) {
        boostMultiplier = MIN_MULTIPLIER;
      }
      if (boostMultiplier > MAX_MULTIPLIER) {
        boostMultiplier = MAX_MULTIPLIER;
      }
      return boostMultiplier;
    };

    /**
     * Some browsers do not support Array.prototype.flat()
     * for example, Opera 42 which is used for browserstack tests
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat
     *
     * @param {Array} input arbitrary array
     * @returns {Array} flattened array
     */
    const flatten = function flatten(input) {
      const stack = [];
      input.forEach(function (el) {
        return stack.push(el);
      });
      const res = [];
      while (stack.length) {
        // pop value from stack
        const next = stack.pop();
        if (Array.isArray(next)) {
          // push back array items, won't modify the original input
          next.forEach(function (el) {
            return stack.push(el);
          });
        } else {
          res.push(next);
        }
      }
      // reverse to restore input order
      return res.reverse();
    };

    /**
     * Predicate method to check if the array item exists
     *
     * @param {any} item arbitrary
     * @returns {boolean} if item is truthy or not
     */
    const isExisting = function isExisting(item) {
      return !!item;
    };

    /**
     * Checks whether the input path is supported
     *
     * @param {string} rawPath input path
     * @returns {boolean} if cookie path is valid
     */
    const isValidCookiePath = function isValidCookiePath(rawPath) {
      return rawPath === '/' || rawPath === 'none';
    };

    /**
     * Returns 'path=/' if rawPath is '/'
     * or empty string '' for other cases, `rawPath === 'none'` included
     *
     * @param {string} rawPath path argument of *set-cookie-* scriptlets
     * @returns {string} cookie path
     */
    const getCookiePath = function getCookiePath(rawPath) {
      if (rawPath === '/') {
        return 'path=/';
      }
      // otherwise do not set path as invalid
      // the same for pathArg === 'none'
      return '';
    };

    /**
     * Combines input cookie name, value, and path into string.
     *
     * @param {string} rawName name argument of *set-cookie-* scriptlets
     * @param {string} rawValue value argument of *set-cookie-* scriptlets
     * @param {string} rawPath path argument of *set-cookie-* scriptlets
     * @returns {string|null} string OR `null` if path is not supported
     */
    const concatCookieNameValuePath = function concatCookieNameValuePath(rawName, rawValue, rawPath) {
      // eslint-disable-next-line max-len
      return "".concat(encodeURIComponent(rawName), "=").concat(encodeURIComponent(rawValue), "; ").concat(getCookiePath(rawPath), ";");
    };

    /**
     * Gets supported cookie value
     *
     * @param {string} value input cookie value
     * @returns {string|null} valid cookie string if ok OR null if not
     */
    const getLimitedCookieValue = function getLimitedCookieValue(value) {
      if (!value) {
        return null;
      }
      let validValue;
      if (value === 'true') {
        validValue = 'true';
      } else if (value === 'True') {
        validValue = 'True';
      } else if (value === 'false') {
        validValue = 'false';
      } else if (value === 'False') {
        validValue = 'False';
      } else if (value === 'yes') {
        validValue = 'yes';
      } else if (value === 'Yes') {
        validValue = 'Yes';
      } else if (value === 'Y') {
        validValue = 'Y';
      } else if (value === 'no') {
        validValue = 'no';
      } else if (value === 'ok') {
        validValue = 'ok';
      } else if (value === 'OK') {
        validValue = 'OK';
      } else if (/^\d+$/.test(value)) {
        validValue = parseFloat(value);
        if (nativeIsNaN(validValue)) {
          return null;
        }
        if (Math.abs(validValue) < 0 || Math.abs(validValue) > 15) {
          return null;
        }
      } else {
        return null;
      }
      return validValue;
    };

    /**
     * Parses cookie string into object
     *
     * @param {string} cookieString string that conforms to document.cookie format
     * @returns {Object} key:value object that corresponds with incoming cookies keys and values
     */
    const parseCookieString = function parseCookieString(cookieString) {
      const COOKIE_DELIMITER = '=';
      const COOKIE_PAIRS_DELIMITER = ';';

      // Get raw cookies
      const cookieChunks = cookieString.split(COOKIE_PAIRS_DELIMITER);
      const cookieData = {};
      cookieChunks.forEach(function (singleCookie) {
        let cookieKey;
        let cookieValue;
        const delimiterIndex = singleCookie.indexOf(COOKIE_DELIMITER);
        if (delimiterIndex === -1) {
          cookieKey = singleCookie.trim();
        } else {
          cookieKey = singleCookie.slice(0, delimiterIndex).trim();
          cookieValue = singleCookie.slice(delimiterIndex + 1);
        }
        // Save cookie key=value data with null instead of empty ('') values
        cookieData[cookieKey] = cookieValue || null;
      });
      return cookieData;
    };

    /**
     * Check if cookie with specified name and value is present in a cookie string
     *
     * @param {string} cookieString 'document.cookie'-like string
     * @param {string} name name argument of *set-cookie-* scriptlets
     * @param {string} value value argument of *set-cookie-* scriptlets
     * @returns {boolean} if cookie is already set
     */
    const isCookieSetWithValue = function isCookieSetWithValue(cookieString, name, value) {
      return cookieString.split(';').some(function (cookieStr) {
        const pos = cookieStr.indexOf('=');
        if (pos === -1) {
          return false;
        }
        const cookieName = cookieStr.slice(0, pos).trim();
        const cookieValue = cookieStr.slice(pos + 1).trim();
        return name === cookieName && value === cookieValue;
      });
    };

    /**
     * Returns parsed offset expired number of ms or null if `offsetExpiresSec` is invalid
     *
     * @param {string} offsetExpiresSec input offset param in seconds
     * @returns {number|null} number is milliseconds OR null
     */
    const getTrustedCookieOffsetMs = function getTrustedCookieOffsetMs(offsetExpiresSec) {
      const ONE_YEAR_EXPIRATION_KEYWORD = '1year';
      const ONE_DAY_EXPIRATION_KEYWORD = '1day';
      const MS_IN_SEC = 1000;
      const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
      const SECONDS_IN_DAY = 24 * 60 * 60;
      let parsedSec;
      // Set predefined expire value if corresponding keyword was passed
      if (offsetExpiresSec === ONE_YEAR_EXPIRATION_KEYWORD) {
        parsedSec = SECONDS_IN_YEAR;
      } else if (offsetExpiresSec === ONE_DAY_EXPIRATION_KEYWORD) {
        parsedSec = SECONDS_IN_DAY;
      } else {
        parsedSec = Number.parseInt(offsetExpiresSec, 10);
        // If offsetExpiresSec has been parsed to NaN - do not set cookie at all
        if (Number.isNaN(parsedSec)) {
          return null;
        }
      }
      return parsedSec * MS_IN_SEC;
    };

    /**
     * Noop function
     *
     * @returns {undefined} undefined
     */
    const noopFunc = function noopFunc() {};

    /**
     * Function returns noopFunc
     *
     * @returns {Function} noopFunc
     */
    const noopCallbackFunc = function noopCallbackFunc() {
      return noopFunc;
    };

    /**
     * Function returns null
     *
     * @returns {null} null
     */
    const noopNull = function noopNull() {
      return null;
    };

    /**
     * Function returns true
     *
     * @returns {boolean} true
     */
    const trueFunc = function trueFunc() {
      return true;
    };

    /**
     * Function returns false
     *
     * @returns {boolean} false
     */
    const falseFunc = function falseFunc() {
      return false;
    };

    /**
     * Function returns this
     *
     * @returns {this} this object
     */
    function noopThis() {
      return this;
    }

    /**
     * Function returns empty string
     *
     * @returns {string} empty string
     */
    const noopStr = function noopStr() {
      return '';
    };

    /**
     * Function returns empty array
     *
     * @returns {Array} empty array
     */
    const noopArray = function noopArray() {
      return [];
    };

    /**
     * Function returns empty object
     *
     * @returns {Object} empty object
     */
    const noopObject = function noopObject() {
      return {};
    };

    /**
     * Function throws an error
     *
     * @throws
     */
    const throwFunc = function throwFunc() {
      throw new Error();
    };

    /**
     * Function returns Promise.reject()
     *
     * @returns {Promise} rejected Promise
     */
    const noopPromiseReject = function noopPromiseReject() {
      return Promise.reject();
    };

    /**
     * Returns Promise object that is resolved with specified props
     *
     * @param {string} [responseBody='{}'] value to set as responseBody
     * @param {string} [responseUrl=''] value to set as responseUrl
     * @param {string} [responseType='default'] value to set as responseType
     * @returns {Promise<Response>|undefined} resolved Promise or undefined if Response interface is not available
     */
    const noopPromiseResolve = function noopPromiseResolve() {
      let responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '{}';
      let responseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      let responseType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';
      if (typeof Response === 'undefined') {
        return;
      }
      const response = new Response(responseBody, {
        status: 200,
        statusText: 'OK'
      });

      // Mock response' url & type to avoid adb checks
      // https://github.com/AdguardTeam/Scriptlets/issues/216
      Object.defineProperties(response, {
        url: {
          value: responseUrl
        },
        type: {
          value: responseType
        }
      });

      // eslint-disable-next-line consistent-return
      return Promise.resolve(response);
    };

    /**
     * Determines if type of script is inline or injected
     * and when it's one of them then return true, otherwise false
     * https://github.com/AdguardTeam/Scriptlets/issues/201
     *
     * @param {string|undefined} stackMatch - input stack value to match
     * @param {string} stackTrace - script error stack trace
     * @returns {boolean} if stacks match
     */
    const shouldAbortInlineOrInjectedScript = function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
      const INLINE_SCRIPT_STRING = 'inlineScript';
      const INJECTED_SCRIPT_STRING = 'injectedScript';
      const INJECTED_SCRIPT_MARKER = '<anonymous>';
      const isInlineScript = function isInlineScript(stackMatch) {
        return stackMatch.indexOf(INLINE_SCRIPT_STRING) > -1;
      };
      const isInjectedScript = function isInjectedScript(stackMatch) {
        return stackMatch.indexOf(INJECTED_SCRIPT_STRING) > -1;
      };
      if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
        return false;
      }
      let documentURL = window.location.href;
      const pos = documentURL.indexOf('#');
      // Remove URL hash
      // in Chrome, URL in stackTrace doesn't contain hash
      // so, it's necessary to remove it, otherwise location.href
      // will not match with location from stackTrace
      if (pos !== -1) {
        documentURL = documentURL.slice(0, pos);
      }
      const stackSteps = stackTrace.split('\n').slice(2).map(function (line) {
        return line.trim();
      });
      const stackLines = stackSteps.map(function (line) {
        let stack;
        // Get stack trace URL
        // in Firefox stack trace looks like this: advanceTaskQueue@http://127.0.0.1:8080/scriptlets/tests/dist/qunit.js:1834:20
        // in Chrome like this: at Assert.throws (http://127.0.0.1:8080/scriptlets/tests/dist/qunit.js:3178:16)
        // so, first group "(.*?@)" is required for Firefox, second group contains URL
        const getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
        if (getStackTraceURL) {
          let stackURL = getStackTraceURL[2];
          if (startsWith$1(stackURL, '(')) {
            stackURL = stackURL.slice(1);
          }
          if (startsWith$1(stackURL, INJECTED_SCRIPT_MARKER)) {
            stackURL = INJECTED_SCRIPT_STRING;
            let stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
            if (startsWith$1(stackFunction, 'at')) {
              stackFunction = stackFunction.slice(2).trim();
            }
            stack = "".concat(stackFunction, " ").concat(stackURL).trim();
          } else {
            stack = stackURL;
          }
        } else {
          stack = line;
        }
        return stack;
      });
      if (stackLines) {
        for (let index = 0; index < stackLines.length; index += 1) {
          if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
            return true;
          }
          if (isInjectedScript(stackMatch) && startsWith$1(stackLines[index], INJECTED_SCRIPT_STRING)) {
            return true;
          }
        }
      }
      return false;
    };

    /**
     * Finds shadow-dom host (elements with shadowRoot property) in DOM of rootElement.
     *
     * @param {HTMLElement} rootElement shadow dom root
     * @returns {HTMLElement[]} shadow-dom hosts
     */
    const findHostElements = function findHostElements(rootElement) {
      const hosts = [];
      // Element.querySelectorAll() returns list of elements
      // which are defined in DOM of Element.
      // Meanwhile, inner DOM of the element with shadowRoot property
      // is absolutely another DOM and which can not be reached by querySelectorAll('*')
      const domElems = rootElement.querySelectorAll('*');
      domElems.forEach(function (el) {
        if (el.shadowRoot) {
          hosts.push(el);
        }
      });
      return hosts;
    };

    /**
     * A collection of nodes.
     *
     * @external NodeList
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/NodeList NodeList}
     */

    /**
     * @typedef {Object} PierceData
     * @property {HTMLElement[]} targets found elements that match the specified selector
     * @property {HTMLElement[]} innerHosts inner shadow-dom hosts
     */

    /**
     * Pierces open shadow-dom in order to find:
     * - elements by 'selector' matching
     * - inner shadow-dom hosts
     *
     * @param {string} selector DOM elements selector
     * @param {HTMLElement[]|external:NodeList} hostElements shadow-dom hosts
     * @returns {PierceData} object with found elements and shadow-dom hosts
     */
    const pierceShadowDom = function pierceShadowDom(selector, hostElements) {
      let targets = [];
      const innerHostsAcc = [];

      // it's possible to get a few hostElements found by baseSelector on the page
      hostElements.forEach(function (host) {
        // check presence of selector element inside base element if it's not in shadow-dom
        const simpleElems = host.querySelectorAll(selector);
        targets = targets.concat([].slice.call(simpleElems));
        const shadowRootElem = host.shadowRoot;
        const shadowChildren = shadowRootElem.querySelectorAll(selector);
        targets = targets.concat([].slice.call(shadowChildren));

        // find inner shadow-dom hosts inside processing shadow-dom
        innerHostsAcc.push(findHostElements(shadowRootElem));
      });

      // if there were more than one host element,
      // innerHostsAcc is an array of arrays and should be flatten
      const innerHosts = flatten(innerHostsAcc);
      return {
        targets,
        innerHosts
      };
    };

    /**
     * Checks whether the passed arg is proper callback
     *
     * @param {any} callback arbitrary callback
     * @returns {boolean} if callback is valid
     */
    const isValidCallback = function isValidCallback(callback) {
      return callback instanceof Function
      // passing string as 'code' arg is not recommended
      // but it is possible and not restricted
      // https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#parameters
      || typeof callback === 'string';
    };

    /**
     * Parses delay argument of setTimeout / setInterval methods into
     * rounded down number for number/string values or passes on for other types.
     * Needed for prevent-setTimeout and prevent-setInterval
     *
     * @param {any} delay native method delay arg
     * @returns {any} number as parsed delay or any input type if `delay` is not parsable
     */
    const parseRawDelay = function parseRawDelay(delay) {
      const parsedDelay = Math.floor(parseInt(delay, 10));
      return typeof parsedDelay === 'number' && !nativeIsNaN(parsedDelay) ? parsedDelay : delay;
    };

    /**
     * Checks whether 'callback' and 'delay' are matching
     * by given parameters 'matchCallback' and 'matchDelay'.
     * Used for prevent-setTimeout and prevent-setInterval.
     *
     * @param {Object} preventData set of data to determine if scriptlet should match
     * @param {Function} preventData.callback method's callback arg
     * @param {any} preventData.delay method's delay arg
     * @param {string} preventData.matchCallback scriptlets's callback arg
     * @param {string} preventData.matchDelay scriptlets's delay arg
     * @returns {boolean} if scriptlet should match
     */
    const isPreventionNeeded = function isPreventionNeeded(_ref) {
      let callback = _ref.callback,
        delay = _ref.delay,
        matchCallback = _ref.matchCallback,
        matchDelay = _ref.matchDelay;
      // if callback is has not valid type
      // scriptlet can not prevent it
      // so no need for more checking and do not call hit() later
      if (!isValidCallback(callback)) {
        return false;
      }
      if (!isValidMatchStr(matchCallback) || matchDelay && !isValidMatchNumber(matchDelay)) {
        return false;
      }
      const _parseMatchArg = parseMatchArg(matchCallback),
        isInvertedMatch = _parseMatchArg.isInvertedMatch,
        matchRegexp = _parseMatchArg.matchRegexp;
      const _parseDelayArg = parseDelayArg(matchDelay),
        isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,
        delayMatch = _parseDelayArg.delayMatch;

      // Parse delay for decimal, string and non-number values
      // https://github.com/AdguardTeam/Scriptlets/issues/247
      const parsedDelay = parseRawDelay(delay);
      let shouldPrevent = false;
      // https://github.com/AdguardTeam/Scriptlets/issues/105
      const callbackStr = String(callback);
      if (delayMatch === null) {
        shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch;
      } else if (!matchCallback) {
        shouldPrevent = parsedDelay === delayMatch !== isInvertedDelayMatch;
      } else {
        shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch && parsedDelay === delayMatch !== isInvertedDelayMatch;
      }
      return shouldPrevent;
    };

    const handleOldReplacement = function handleOldReplacement(replacement) {
      let result;
      // defaults to return noopFunc instead of window.open
      if (!replacement) {
        result = noopFunc;
      } else if (replacement === 'trueFunc') {
        result = trueFunc;
      } else if (replacement.indexOf('=') > -1) {
        // We should return noopFunc instead of window.open
        // but with some property if website checks it (examples 5, 6)
        // https://github.com/AdguardTeam/Scriptlets/issues/71
        const isProp = startsWith$1(replacement, '{') && endsWith(replacement, '}');
        if (isProp) {
          const propertyPart = replacement.slice(1, -1);
          const propertyName = substringBefore(propertyPart, '=');
          const propertyValue = substringAfter$1(propertyPart, '=');
          if (propertyValue === 'noopFunc') {
            result = {};
            result[propertyName] = noopFunc;
          }
        }
      }
      return result;
    };
    const createDecoy = function createDecoy(args) {
      const OBJECT_TAG_NAME = 'object';
      const OBJECT_URL_PROP_NAME = 'data';
      const IFRAME_TAG_NAME = 'iframe';
      const IFRAME_URL_PROP_NAME = 'src';
      const replacement = args.replacement,
        url = args.url,
        delay = args.delay;
      let tag;
      let urlProp;
      if (replacement === 'obj') {
        tag = OBJECT_TAG_NAME;
        urlProp = OBJECT_URL_PROP_NAME;
      } else {
        tag = IFRAME_TAG_NAME;
        urlProp = IFRAME_URL_PROP_NAME;
      }
      const decoy = document.createElement(tag);
      decoy[urlProp] = url;
      decoy.style.setProperty('height', '1px', 'important');
      decoy.style.setProperty('position', 'fixed', 'important');
      decoy.style.setProperty('top', '-1px', 'important');
      decoy.style.setProperty('width', '1px', 'important');
      document.body.appendChild(decoy);
      setTimeout(function () {
        return decoy.remove();
      }, delay * 1000);
      return decoy;
    };
    const getPreventGetter = function getPreventGetter(nativeGetter) {
      const preventGetter = function preventGetter(target, prop) {
        if (prop && prop === 'closed') {
          return false;
        }
        if (typeof nativeGetter === 'function') {
          return noopFunc;
        }
        return prop && target[prop];
      };
      return preventGetter;
    };

    const getNativeRegexpTest = function getNativeRegexpTest() {
      return Object.getOwnPropertyDescriptor(RegExp.prototype, 'test').value;
    };

    /**
     * Returns array of request props that are supported by fetch/xhr scriptlets.
     * Includes common 'url' and 'method' props and all other fetch-specific props
     *
     * @returns {string[]} list of request props
     */
    const getRequestProps = function getRequestProps() {
      return ['url', 'method', 'headers', 'body', 'mode', 'credentials', 'cache', 'redirect', 'referrer', 'referrerPolicy', 'integrity', 'keepalive', 'signal'];
    };

    /**
     * Collects Request options to object
     *
     * @param {Request} request Request instance to collect properties from
     * @returns {Object} data object
     */
    const getRequestData = function getRequestData(request) {
      const requestInitOptions = getRequestProps();
      const entries = requestInitOptions.map(function (key) {
        // if request has no such option, value will be undefined
        const value = request[key];
        return [key, value];
      });
      return getObjectFromEntries(entries);
    };

    /**
     * Collects fetch args to object
     *
     * @param {any} args fetch args
     * @returns {Object} data object
     */
    const getFetchData = function getFetchData(args) {
      const fetchPropsObj = {};
      let fetchUrl;
      let fetchInit;
      if (args[0] instanceof Request) {
        // if Request passed to fetch, it will be in array
        const requestData = getRequestData(args[0]);
        fetchUrl = requestData.url;
        fetchInit = requestData;
      } else {
        fetchUrl = args[0]; // eslint-disable-line prefer-destructuring
        fetchInit = args[1]; // eslint-disable-line prefer-destructuring
      }

      fetchPropsObj.url = fetchUrl;
      if (fetchInit instanceof Object) {
        Object.keys(fetchInit).forEach(function (prop) {
          fetchPropsObj[prop] = fetchInit[prop];
        });
      }
      return fetchPropsObj;
    };

    /**
     * Collect xhr.open arguments to object
     *
     * @param {string} method request method
     * @param {string} url request url
     * @param {string} async request async prop
     * @param {string} user request user prop
     * @param {string} password request password prop
     * @returns {Object} aggregated request data
     */
    const getXhrData = function getXhrData(method, url, async, user, password) {
      return {
        method,
        url,
        async,
        user,
        password
      };
    };

    /**
     * Parse propsToMatch input string into object;
     * used for prevent-fetch and prevent-xhr
     *
     * @param {string} propsToMatchStr string of space-separated request properties to match
     * @returns {Object} object where 'key' is prop name and 'value' is prop value
     */
    const parseMatchProps = function parseMatchProps(propsToMatchStr) {
      const PROPS_DIVIDER = ' ';
      const PAIRS_MARKER = ':';
      const LEGAL_MATCH_PROPS = getRequestProps();
      const propsObj = {};
      const props = propsToMatchStr.split(PROPS_DIVIDER);
      props.forEach(function (prop) {
        const dividerInd = prop.indexOf(PAIRS_MARKER);
        const key = prop.slice(0, dividerInd);
        const hasLegalMatchProp = LEGAL_MATCH_PROPS.indexOf(key) !== -1;
        if (hasLegalMatchProp) {
          const value = prop.slice(dividerInd + 1);
          propsObj[key] = value;
        } else {
          // Escape multiple colons in prop
          // i.e regex value and/or url with protocol specified, with or without 'url:' match prop
          // https://github.com/AdguardTeam/Scriptlets/issues/216#issuecomment-1178591463
          propsObj.url = prop;
        }
      });
      return propsObj;
    };

    /**
     * Validates parsed data values
     *
     * @param {Object} data request data
     * @returns {boolean} if data is valid
     */
    const validateParsedData = function validateParsedData(data) {
      return Object.values(data).every(function (value) {
        return isValidStrPattern(value);
      });
    };

    /**
     * Converts valid parsed data to data obj for further matching
     *
     * @param {Object} data parsed request data
     * @returns {Object} data obj ready for matching
     */
    const getMatchPropsData = function getMatchPropsData(data) {
      const matchData = {};
      Object.keys(data).forEach(function (key) {
        matchData[key] = toRegExp(data[key]);
      });
      return matchData;
    };

    /**
     * Conditionally logs message to console.
     * Convention is to log messages by source.verbose if such log
     * is not a part of scriptlet's functionality, eg on invalid input,
     * and use 'forced' argument otherwise.
     *
     * @param {Object} source required, scriptlet properties
     * @param {any} message required, message to log
     * @param {boolean} [forced=false] to log message unconditionally
     * @param {boolean} [convertMessageToString=true] to convert message to string
     */
    const logMessage = function logMessage(source, message) {
      let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      const name = source.name,
        ruleText = source.ruleText,
        verbose = source.verbose;
      if (!forced && !verbose) {
        return;
      }

      // eslint-disable-next-line no-console
      const nativeConsole = console.log;
      if (!convertMessageToString) {
        // Template literals convert object to string,
        // so 'message' should not be passed to template literals
        // as it will not be logged correctly
        nativeConsole("".concat(name, ":"), message);
        return;
      }
      let messageStr = "".concat(name, ": ").concat(message);

      // Extract scriptlet part from rule text
      if (ruleText) {
        const RULE_MARKER = '#%#//scriptlet';
        const markerIdx = ruleText.indexOf(RULE_MARKER);
        if (markerIdx > -1) {
          const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
          messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
        }
      }
      nativeConsole(messageStr);
    };

    /**
     * Sets item to a specified storage, if storage isn't full.
     *
     * @param {Object} source scriptlet's configuration
     * @param {Storage} storage storage instance to set item into
     * @param {string} key storage key
     * @param {string} value staroge value
     */
    const setStorageItem = function setStorageItem(source, storage, key, value) {
      // setItem() may throw an exception if the storage is full.
      try {
        storage.setItem(key, value);
      } catch (e) {
        const message = "Unable to set sessionStorage item due to: ".concat(e.message);
        logMessage(source, message);
      }
    };

    /**
     * Gets supported storage item value
     *
     * @param {string} value input item value
     * @returns {string|null|undefined|boolean} valid item value if ok OR null if not
     */
    const getLimitedStorageItemValue = function getLimitedStorageItemValue(value) {
      if (typeof value !== 'string') {
        throw new Error('Invalid value');
      }
      let validValue;
      if (value === 'undefined') {
        validValue = undefined;
      } else if (value === 'false') {
        validValue = false;
      } else if (value === 'true') {
        validValue = true;
      } else if (value === 'null') {
        validValue = null;
      } else if (value === 'emptyArr') {
        validValue = '[]';
      } else if (value === 'emptyObj') {
        validValue = '{}';
      } else if (value === '') {
        validValue = '';
      } else if (/^\d+$/.test(value)) {
        validValue = parseFloat(value);
        if (nativeIsNaN(validValue)) {
          throw new Error('Invalid value');
        }
        if (Math.abs(validValue) > 32767) {
          throw new Error('Invalid value');
        }
      } else if (value === 'yes') {
        validValue = 'yes';
      } else if (value === 'no') {
        validValue = 'no';
      } else {
        throw new Error('Invalid value');
      }
      return validValue;
    };

    /**
     * Generates function which silents global errors on page generated by scriptlet
     * If error doesn't belong to our error we transfer it to the native onError handler
     *
     * @param {string} rid - unique identifier of scriptlet
     * @returns {Function} window.onerror handler
     */
    function createOnErrorHandler(rid) {
      // eslint-disable-next-line consistent-return
      const nativeOnError = window.onerror;
      return function onError(error) {
        if (typeof error === 'string' && error.indexOf(rid) !== -1) {
          return true;
        }
        if (nativeOnError instanceof Function) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          return nativeOnError.apply(this, [error, ...args]);
        }
        return false;
      };
    }

    /**
     * Generate random seven symbols id
     *
     * @returns {string} randomized id
     */
    function randomId() {
      return Math.random().toString(36).slice(2, 9);
    }

    /**
     * Prevents infinite loops when trapping props that could be used by scriptlet's own helpers
     * Example: window.RegExp, that is used by matchStackTrace > toRegExp
     *
     * https://github.com/AdguardTeam/Scriptlets/issues/251
     * https://github.com/AdguardTeam/Scriptlets/issues/226
     * https://github.com/AdguardTeam/Scriptlets/issues/232
     *
     * @returns {Object} descriptor addon
     */
    function getDescriptorAddon() {
      return {
        isAbortingSuspended: false,
        isolateCallback(cb) {
          this.isAbortingSuspended = true;
          // try...catch is required in case there are more than one inline scripts
          // which should be aborted,
          // so after the first successful abortion, `cb(...args);` will throw error,
          // and we should not stop on that and continue to abort other scripts
          try {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            const result = cb(...args);
            this.isAbortingSuspended = false;
            return result;
          } catch (_unused) {
            const rid = randomId();
            this.isAbortingSuspended = false;
            // It's necessary to throw error
            // otherwise script will be not aborted
            throw new ReferenceError(rid);
          }
        }
      };
    }

    /**
     * @typedef ChainInfo
     * @property {Object} base current chain base
     * @property {string} prop current chain prop
     * @property {string} [chain] string representation
     */

    /**
     * Check if the property exists in the base object (recursively)
     *
     * If property doesn't exist in base object,
     * defines this property as 'undefined'
     * and returns base, property name and remaining part of property chain
     *
     * @param {Object} base object that owns chain
     * @param {string} chain chain of owner properties
     * @returns {ChainInfo} chain info object
     */
    function getPropertyInChain(base, chain) {
      const pos = chain.indexOf('.');
      if (pos === -1) {
        return {
          base,
          prop: chain
        };
      }
      const prop = chain.slice(0, pos);

      // https://github.com/AdguardTeam/Scriptlets/issues/128
      if (base === null) {
        // if base is null, return 'null' as base.
        // it's needed for triggering the reason logging while debugging
        return {
          base,
          prop,
          chain
        };
      }
      const nextBase = base[prop];
      chain = chain.slice(pos + 1);
      if ((base instanceof Object || typeof base === 'object') && isEmptyObject(base)) {
        // for empty objects in chain
        return {
          base,
          prop,
          chain
        };
      }
      if (nextBase === null) {
        return {
          base,
          prop,
          chain
        };
      }
      if (nextBase !== undefined) {
        return getPropertyInChain(nextBase, chain);
      }
      Object.defineProperty(base, prop, {
        configurable: true
      });
      return {
        base,
        prop,
        chain
      };
    }

    /**
     * @typedef ChainInfo
     * @property {Object} base current chain base
     * @property {string} prop current chain prop
     * @property {string} [chain] string representation
     */

    /**
     * Check if the property exists in the base object (recursively).
     * Similar to getPropertyInChain but upgraded for json-prune:
     * handle wildcard properties and does not define nonexistent base property as 'undefined'
     *
     * @param {Object} base object that owns chain
     * @param {string} chain chain of owner properties
     * @param {boolean} [lookThrough=false]
     * should the method look through it's props in order to wildcard
     * @param {Array} [output=[]] result acc
     * @returns {ChainInfo[]} array of objects
     */
    function getWildcardPropertyInChain(base, chain) {
      let lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      let output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      const pos = chain.indexOf('.');
      if (pos === -1) {
        // for paths like 'a.b.*' every final nested prop should be processed
        if (chain === '*' || chain === '[]') {
          // eslint-disable-next-line no-restricted-syntax
          for (const key in base) {
            // to process each key in base except inherited ones
            if (Object.prototype.hasOwnProperty.call(base, key)) {
              output.push({
                base,
                prop: key
              });
            }
          }
        } else {
          output.push({
            base,
            prop: chain
          });
        }
        return output;
      }
      const prop = chain.slice(0, pos);
      const shouldLookThrough = prop === '[]' && Array.isArray(base) || prop === '*' && base instanceof Object;
      if (shouldLookThrough) {
        const nextProp = chain.slice(pos + 1);
        const baseKeys = Object.keys(base);

        // if there is a wildcard prop in input chain (e.g. 'ad.*.src' for 'ad.0.src ad.1.src'),
        // each one of base keys should be considered as a potential chain prop in final path
        baseKeys.forEach(function (key) {
          const item = base[key];
          getWildcardPropertyInChain(item, nextProp, lookThrough, output);
        });
      }
      const nextBase = base[prop];
      chain = chain.slice(pos + 1);
      if (nextBase !== undefined) {
        getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
      }
      return output;
    }

    /* eslint-disable no-console, no-underscore-dangle */

    /**
     * Hit used only for debug purposes now
     *
     * @param {Object} source scriptlet properties
     * use LOG_MARKER = 'log: ' at the start of a message
     * for logging scriptlets
     */
    const hit = function hit(source) {
      if (source.verbose !== true) {
        return;
      }
      try {
        const log = console.log.bind(console);
        const trace = console.trace.bind(console);
        let prefix = source.ruleText || '';
        if (source.domainName) {
          const AG_SCRIPTLET_MARKER = '#%#//';
          const UBO_SCRIPTLET_MARKER = '##+js';
          let ruleStartIndex;
          if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
            ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
          } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
            ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
          }
          // delete all domains from ruleText and leave just rule part
          const rulePart = source.ruleText.slice(ruleStartIndex);
          // prepare applied scriptlet rule for specific domain
          prefix = "".concat(source.domainName).concat(rulePart);
        }
        log("".concat(prefix, " trace start"));
        if (trace) {
          trace();
        }
        log("".concat(prefix, " trace end"));
      } catch (e) {
        // try catch for Edge 15
        // In according to this issue https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/14495220/
        // console.log throws an error
      }

      // This is necessary for unit-tests only!
      if (typeof window.__debug === 'function') {
        window.__debug(source);
      }
    };

    /**
     * Checks if given propsToMatch string matches with given request data
     * This is used by prevent-xhr, prevent-fetch, trusted-replace-xhr-response
     * and  trusted-replace-fetch-response scriptlets
     *
     * @param {Object} source scriptlet properties
     * @param {string} propsToMatch string of space-separated request properties to match
     * @param {Object} requestData object with standard properties of fetch/xhr like url, method etc
     * @returns {boolean} if request properties match
     */
    const matchRequestProps = function matchRequestProps(source, propsToMatch, requestData) {
      if (propsToMatch === '' || propsToMatch === '*') {
        return true;
      }
      let isMatched;
      const parsedData = parseMatchProps(propsToMatch);
      if (!validateParsedData(parsedData)) {
        logMessage(source, "Invalid parameter: ".concat(propsToMatch));
        isMatched = false;
      } else {
        const matchData = getMatchPropsData(parsedData);
        // prevent only if all props match
        isMatched = Object.keys(matchData).every(function (matchKey) {
          const matchValue = matchData[matchKey];
          return Object.prototype.hasOwnProperty.call(requestData, matchKey) && matchValue.test(requestData[matchKey]);
        });
      }
      return isMatched;
    };

    /**
     * Checks if the stackTrace contains stackRegexp
     * https://github.com/AdguardTeam/Scriptlets/issues/82
     *
     * @param {string|undefined} stackMatch - input stack value to match
     * @param {string} stackTrace - script error stack trace
     * @returns {boolean} if the stackTrace contains stackRegexp
     */
    const matchStackTrace = function matchStackTrace(stackMatch, stackTrace) {
      if (!stackMatch || stackMatch === '') {
        return true;
      }
      if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
        return true;
      }
      const stackRegexp = toRegExp(stackMatch);
      const refinedStackTrace = stackTrace.split('\n').slice(2) // get rid of our own functions in the stack trace
      .map(function (line) {
        return line.trim();
      }) // trim the lines
      .join('\n');
      return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
    };

    /**
     * Returns a wrapper, passing the call to 'method' at maximum once per 'delay' milliseconds.
     * Those calls that fall into the "cooldown" period, are ignored
     *
     * @param {Function} cb callback
     * @param {number} delay - milliseconds
     * @returns {Function} throttled callback
     */
    const throttle = function throttle(cb, delay) {
      let wait = false;
      let savedArgs;
      const wrapper = function wrapper() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (wait) {
          savedArgs = args;
          return;
        }
        cb(...args);
        wait = true;
        setTimeout(function () {
          wait = false;
          if (savedArgs) {
            // "savedArgs" might contains few arguments, so it's necessary to use spread operator
            // https://github.com/AdguardTeam/Scriptlets/issues/284#issuecomment-1419464354
            wrapper(...savedArgs);
            savedArgs = null;
          }
        }, delay);
      };
      return wrapper;
    };

    /**
     * DOM tree changes observer. Used for 'remove-attr' and 'remove-class' scriptlets
     *
     * @param {Function} callback function to call on each mutation
     * @param {boolean} [observeAttrs] if observer should observe attributes changes
     * @param {Array} [attrsToObserve] list of attributes to observe
     */
    const observeDOMChanges = function observeDOMChanges(callback) {
      let observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      let attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      /**
       * 'delay' in milliseconds for 'throttle' method
       */
      const THROTTLE_DELAY_MS = 20;
      /**
       * Used for remove-class
       */
      // eslint-disable-next-line no-use-before-define
      const observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
      const connect = function connect() {
        if (attrsToObserve.length > 0) {
          observer.observe(document.documentElement, {
            childList: true,
            subtree: true,
            attributes: observeAttrs,
            attributeFilter: attrsToObserve
          });
        } else {
          observer.observe(document.documentElement, {
            childList: true,
            subtree: true,
            attributes: observeAttrs
          });
        }
      };
      const disconnect = function disconnect() {
        observer.disconnect();
      };

      /**
       * Callback wrapper to prevent loops
       * when callback tinkers with attributes
       */
      function callbackWrapper() {
        disconnect();
        callback();
        connect();
      }
      connect();
    };

    /**
     * @typedef {Object} FlagsData object that holds info about valid flags
     * and provides method for easy access
     * @property {string} ASAP asap flag string
     * @property {string} COMPLETE complete flag string
     * @property {string} STAY stay flag string
     * @property {Function} hasFlag to check if given flag is present
     */

    /**
     * Behaviour flags string parser
     *
     * @param {string} flags required, 'applying' argument string
     * @returns {FlagsData} object with parsed flags
     */
    const parseFlags = function parseFlags(flags) {
      const FLAGS_DIVIDER = ' ';
      const ASAP_FLAG = 'asap';
      const COMPLETE_FLAG = 'complete';
      const STAY_FLAG = 'stay';
      const VALID_FLAGS = [STAY_FLAG, ASAP_FLAG, COMPLETE_FLAG];
      const passedFlags = flags.trim().split(FLAGS_DIVIDER).filter(function (f) {
        return VALID_FLAGS.indexOf(f) !== -1;
      });
      return {
        ASAP: ASAP_FLAG,
        COMPLETE: COMPLETE_FLAG,
        STAY: STAY_FLAG,
        hasFlag(flag) {
          return passedFlags.indexOf(flag) !== -1;
        }
      };
    };

    /**
     * Modifies passed keyword value according to its purpose.
     * Returns initial value if it's not a keyword.
     *
     * Supported keywords:
     *   - '$now$' - returns current time in ms, e.g 1667915146503
     *   - '$currentDate$' - returns current date e.g 'Tue Nov 08 2022 13:53:19 GMT+0300'
     *
     * @param {string} rawValue keyword
     * @returns {string} parsed value
     */
    const parseKeywordValue = function parseKeywordValue(rawValue) {
      const NOW_VALUE_KEYWORD = '$now$';
      const CURRENT_DATE_KEYWORD = '$currentDate$';
      let parsedValue = rawValue;
      if (rawValue === NOW_VALUE_KEYWORD) {
        // Set to current time in ms, e.g 1667915146503
        parsedValue = Date.now().toString();
      } else if (rawValue === CURRENT_DATE_KEYWORD) {
        // Set to current date e.g 'Tue Nov 08 2022 13:53:19 GMT+0300'
        parsedValue = Date();
      }
      return parsedValue;
    };

    /**
     * Makes arbitrary operations on shadow root element,
     * to be passed as callback to hijackAttachShadow
     *
     * @callback attachShadowCallback
     * @param {HTMLElement} shadowRoot
     * @returns {void}
     */

    /**
     * Overrides attachShadow method of Element API on a given context
     * to pass retrieved shadowRoots to callback
     *
     * @param {Object} context e.g global window object or contentWindow of an iframe
     * @param {string} hostSelector selector to determine if callback should be called on current shadow subtree
     * @param {attachShadowCallback} callback callback to call on shadow root
     */
    const hijackAttachShadow = function hijackAttachShadow(context, hostSelector, callback) {
      const handlerWrapper = function handlerWrapper(target, thisArg, args) {
        const shadowRoot = Reflect.apply(target, thisArg, args);
        if (thisArg && thisArg.matches(hostSelector || '*')) {
          callback(shadowRoot);
        }
        return shadowRoot;
      };
      const attachShadowHandler = {
        apply: handlerWrapper
      };
      context.Element.prototype.attachShadow = new Proxy(context.Element.prototype.attachShadow, attachShadowHandler);
    };

    /* eslint-disable max-len */
    /**
     * @trustedScriptlet trusted-click-element
     * @description
     * Clicks selected elements in a strict sequence, ordered by selectors passed, and waiting for them to render in the DOM first.
     * Deactivates after all elements have been clicked or by 10s timeout.
     *
     * **Syntax**
     * ```
     * example.com#%#//scriptlet('trusted-click-element', selectors[, extraMatch[, delay]])
     * ```
     *
     * - `selectors`  required, string with query selectors delimited by comma
     * - `extraMatch`  optional, extra condition to check on a page; allows to match `cookie` and `localStorage`; can be set as `name:key[=value]` where `value` is optional.
     * If `cookie`/`localStorage` starts with `!` then the element will only be clicked if specified cookie/localStorage item does not exist.
     * Multiple conditions are allowed inside one `extraMatch` but they should be delimited by comma and each of them should match the syntax. Possible `name`s:
     *    - `cookie` - test string or regex against cookies on a page
     *    - `localStorage` - check if localStorage item is present
     * - `delay`  optional, time in ms to delay scriptlet execution, defaults to instant execution.
     *
     * **Examples**
     * 1. Click single element by selector
     * ```
     * example.com#%#//scriptlet('trusted-click-element', 'button[name="agree"]')
     * ```
     *
     * 2. Delay click execution by 500ms
     * ```
     * example.com#%#//scriptlet('trusted-click-element', 'button[name="agree"]', '', '500')
     * ```
     *
     * 3. Click multiple elements by selector with a delay
     * ```
     * example.com#%#//scriptlet('trusted-click-element', 'button[name="agree"], button[name="check"], input[type="submit"][value="akkoord"]', '', '500')
     * ```
     *
     * 4. Match cookies by keys using regex and string
     * ```
     * example.com#%#//scriptlet('trusted-click-element', 'button[name="agree"]', 'cookie:userConsentCommunity, cookie:/cmpconsent|cmp/')
     * ```
     *
     * 5. Match by cookie key=value pairs using regex and string
     * ```
     * example.com#%#//scriptlet('trusted-click-element', 'button[name="agree"]', 'cookie:userConsentCommunity=true, cookie:/cmpconsent|cmp/=/[a-z]{1,5}/')
     * ```
     *
     * 6. Match by localStorage item 'promo' key
     * ```
     * example.com#%#//scriptlet('trusted-click-element', 'button[name="agree"]', 'localStorage:promo')
     * ```
     *
     * 7. Click multiple elements with delay and matching by both cookie string and localStorage item
     * ```
     * example.com#%#//scriptlet('trusted-click-element', 'button[name="agree"], input[type="submit"][value="akkoord"]', 'cookie:cmpconsent, localStorage:promo', '250')
     * ```
     *
     * 8. Click element only if cookie with name `cmpconsent` does not exist
     * ```
     * example.com#%#//scriptlet('trusted-click-element', 'button[name="agree"]', '!cookie:cmpconsent')
     * ```
     *
     * 9. Click element only if specified cookie string and localStorage item does not exist
     * ```
     * example.com#%#//scriptlet('trusted-click-element', 'button[name="agree"]', '!cookie:cmpconsent, !localStorage:promo')
     * ```
     */
    /* eslint-enable max-len */
    function trustedClickElement$1(source, selectors) {
      let extraMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      let delay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NaN;
      if (!selectors) {
        return;
      }
      const OBSERVER_TIMEOUT_MS = 10000;
      const THROTTLE_DELAY_MS = 20;
      const STATIC_CLICK_DELAY_MS = 150;
      const COOKIE_MATCH_MARKER = 'cookie:';
      const LOCAL_STORAGE_MATCH_MARKER = 'localStorage:';
      const SELECTORS_DELIMITER = ',';
      const COOKIE_STRING_DELIMITER = ';';
      // Regex to split match pairs by commas, avoiding the ones included in regexes
      const EXTRA_MATCH_DELIMITER = /(,\s*){1}(?=!?cookie:|!?localStorage:)/;
      const sleep = function sleep(delayMs) {
        return new Promise(function (resolve) {
          return setTimeout(resolve, delayMs);
        });
      };
      let parsedDelay;
      if (delay) {
        parsedDelay = parseInt(delay, 10);
        const isValidDelay = !Number.isNaN(parsedDelay) || parsedDelay < OBSERVER_TIMEOUT_MS;
        if (!isValidDelay) {
          // eslint-disable-next-line max-len
          const message = "Passed delay '".concat(delay, "' is invalid or bigger than ").concat(OBSERVER_TIMEOUT_MS, " ms");
          logMessage(source, message);
          return;
        }
      }
      let canClick = !parsedDelay;
      const cookieMatches = [];
      const localStorageMatches = [];
      let isInvertedMatchCookie = false;
      let isInvertedMatchLocalStorage = false;
      if (extraMatch) {
        // Get all match marker:value pairs from argument
        const parsedExtraMatch = extraMatch.split(EXTRA_MATCH_DELIMITER).map(function (matchStr) {
          return matchStr.trim();
        });

        // Filter match pairs by marker
        parsedExtraMatch.forEach(function (matchStr) {
          if (matchStr.indexOf(COOKIE_MATCH_MARKER) > -1) {
            const _parseMatchArg = parseMatchArg(matchStr),
              isInvertedMatch = _parseMatchArg.isInvertedMatch,
              matchValue = _parseMatchArg.matchValue;
            isInvertedMatchCookie = isInvertedMatch;
            const cookieMatch = matchValue.replace(COOKIE_MATCH_MARKER, '');
            cookieMatches.push(cookieMatch);
          }
          if (matchStr.indexOf(LOCAL_STORAGE_MATCH_MARKER) > -1) {
            const _parseMatchArg2 = parseMatchArg(matchStr),
              isInvertedMatch = _parseMatchArg2.isInvertedMatch,
              matchValue = _parseMatchArg2.matchValue;
            isInvertedMatchLocalStorage = isInvertedMatch;
            const localStorageMatch = matchValue.replace(LOCAL_STORAGE_MATCH_MARKER, '');
            localStorageMatches.push(localStorageMatch);
          }
        });
      }
      if (cookieMatches.length > 0) {
        const parsedCookieMatches = parseCookieString(cookieMatches.join(COOKIE_STRING_DELIMITER));
        const parsedCookies = parseCookieString(document.cookie);
        const cookieKeys = Object.keys(parsedCookies);
        if (cookieKeys.length === 0) {
          return;
        }
        const cookiesMatched = Object.keys(parsedCookieMatches).every(function (key) {
          // Avoid getting /.?/ result from toRegExp on undefined
          // as cookie may be set without value,
          // on which cookie parsing will return cookieKey:undefined pair
          const valueMatch = parsedCookieMatches[key] ? toRegExp(parsedCookieMatches[key]) : null;
          const keyMatch = toRegExp(key);
          return cookieKeys.some(function (key) {
            const keysMatched = keyMatch.test(key);
            if (!keysMatched) {
              return false;
            }

            // Key matching is enough if cookie value match is not specified
            if (!valueMatch) {
              return true;
            }
            return valueMatch.test(parsedCookies[key]);
          });
        });
        const shouldRun = cookiesMatched !== isInvertedMatchCookie;
        if (!shouldRun) {
          return;
        }
      }
      if (localStorageMatches.length > 0) {
        const localStorageMatched = localStorageMatches.every(function (str) {
          const itemValue = window.localStorage.getItem(str);
          return itemValue || itemValue === '';
        });
        const shouldRun = localStorageMatched !== isInvertedMatchLocalStorage;
        if (!shouldRun) {
          return;
        }
      }

      /**
       * Create selectors array and swap selectors to null on finding it's element
       *
       * Selectors / nulls should not be (re)moved from array to:
       * - keep track of selectors order
       * - always know on what index corresponding element should be put
       * - prevent selectors from being queried multiple times
       */
      let selectorsSequence = selectors.split(SELECTORS_DELIMITER).map(function (selector) {
        return selector.trim();
      });
      const createElementObj = function createElementObj(element) {
        return {
          element: element || null,
          clicked: false
        };
      };
      const elementsSequence = Array(selectorsSequence.length).fill(createElementObj());

      /**
       * Go through elementsSequence from left to right, clicking on found elements
       *
       * Element should not be clicked if it is already clicked,
       * or a previous element is not found or clicked yet
       */
      const clickElementsBySequence = async function clickElementsBySequence() {
        for (let i = 0; i < elementsSequence.length; i += 1) {
          const elementObj = elementsSequence[i];
          // Add a delay between clicks to every element except the first one
          // https://github.com/AdguardTeam/Scriptlets/issues/284
          if (i >= 1) {
            await sleep(STATIC_CLICK_DELAY_MS);
          }
          // Stop clicking if that pos element is not found yet
          if (!elementObj.element) {
            break;
          }
          // Skip already clicked elements
          if (!elementObj.clicked) {
            elementObj.element.click();
            elementObj.clicked = true;
          }
        }
        const allElementsClicked = elementsSequence.every(function (elementObj) {
          return elementObj.clicked === true;
        });
        if (allElementsClicked) {
          // At this stage observer is already disconnected
          hit(source);
        }
      };
      const handleElement = function handleElement(element, i) {
        const elementObj = createElementObj(element);
        elementsSequence[i] = elementObj;
        if (canClick) {
          clickElementsBySequence();
        }
      };

      /**
       * Query all selectors from queue on each mutation
       * Each selector is swapped to null in selectorsSequence on founding corresponding element
       *
       * We start looking for elements before possible delay is over, to avoid cases
       * when delay is getting off after the last mutation took place.
       *
       */
      const findElements = function findElements(mutations, observer) {
        const fulfilledSelectors = [];
        selectorsSequence.forEach(function (selector, i) {
          if (!selector) {
            return;
          }
          const element = document.querySelector(selector);
          if (!element) {
            return;
          }
          handleElement(element, i);
          fulfilledSelectors.push(selector);
        });

        // selectorsSequence should be modified after the loop to not break loop indexation
        selectorsSequence = selectorsSequence.map(function (selector) {
          return fulfilledSelectors.indexOf(selector) === -1 ? selector : null;
        });

        // Disconnect observer after finding all elements
        const allSelectorsFulfilled = selectorsSequence.every(function (selector) {
          return selector === null;
        });
        if (allSelectorsFulfilled) {
          observer.disconnect();
        }
      };
      const observer = new MutationObserver(throttle(findElements, THROTTLE_DELAY_MS));
      observer.observe(document.documentElement, {
        attributes: true,
        childList: true,
        subtree: true
      });
      if (parsedDelay) {
        setTimeout(function () {
          // Click previously collected elements
          clickElementsBySequence();
          canClick = true;
        }, parsedDelay);
      }
      setTimeout(function () {
        return observer.disconnect();
      }, OBSERVER_TIMEOUT_MS);
    }
    trustedClickElement$1.names = ['trusted-click-element'
    // trusted scriptlets support no aliases
    ];

    trustedClickElement$1.injections = [hit, toRegExp, parseCookieString, throttle, logMessage, parseMatchArg];

    /* eslint-disable max-len */
    /**
     * @scriptlet abort-on-property-read
     * @description
     * Aborts a script when it attempts to **read** the specified property.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-readjs-
     *
     * Related ABP source:
     * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L864
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('abort-on-property-read', property)
     * ```
     *
     * - `property`  required, path to a property (joined with `.` if needed). The property must be attached to `window`
     *
     * **Examples**
     * ```
     * ! Aborts script when it tries to access `window.alert`
     * example.org#%#//scriptlet('abort-on-property-read', 'alert')
     *
     * ! Aborts script when it tries to access `navigator.language`
     * example.org#%#//scriptlet('abort-on-property-read', 'navigator.language')
     * ```
     */
    /* eslint-enable max-len */
    function abortOnPropertyRead$1(source, property) {
      if (!property) {
        return;
      }
      const rid = randomId();
      const abort = function abort() {
        hit(source);
        throw new ReferenceError(rid);
      };
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        setPropertyAccess(base, prop, {
          get: abort,
          set: function set() {}
        });
      };
      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    abortOnPropertyRead$1.names = ['abort-on-property-read',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'abort-on-property-read.js', 'ubo-abort-on-property-read.js', 'aopr.js', 'ubo-aopr.js', 'ubo-abort-on-property-read', 'ubo-aopr', 'abp-abort-on-property-read'];
    abortOnPropertyRead$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, isEmptyObject];

    /* eslint-disable max-len */
    /**
     * @scriptlet abort-on-property-write
     * @description
     * Aborts a script when it attempts to **write** the specified property.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-writejs-
     *
     * Related ABP source:
     * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L896
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('abort-on-property-write', property)
     * ```
     *
     * - `property`  required, path to a property (joined with `.` if needed). The property must be attached to `window`
     *
     * **Examples**
     * ```
     * ! Aborts script when it tries to set `window.adblock` value
     * example.org#%#//scriptlet('abort-on-property-write', 'adblock')
     * ```
     */
    /* eslint-enable max-len */
    function abortOnPropertyWrite$1(source, property) {
      if (!property) {
        return;
      }
      const rid = randomId();
      const abort = function abort() {
        hit(source);
        throw new ReferenceError(rid);
      };
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        setPropertyAccess(base, prop, {
          set: abort
        });
      };
      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    abortOnPropertyWrite$1.names = ['abort-on-property-write',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'abort-on-property-write.js', 'ubo-abort-on-property-write.js', 'aopw.js', 'ubo-aopw.js', 'ubo-abort-on-property-write', 'ubo-aopw', 'abp-abort-on-property-write'];
    abortOnPropertyWrite$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, isEmptyObject];

    /* eslint-disable max-len */
    /**
     * @scriptlet prevent-setTimeout
     * @description
     * Prevents a `setTimeout` call if:
     * 1) the text of the callback is matching the specified `matchCallback` string/regexp which does not start with `!`;
     * otherwise mismatched calls should be defused;
     * 2) the delay is matching the specified `matchDelay`; otherwise mismatched calls should be defused.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-settimeout-ifjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-setTimeout'[, matchCallback[, matchDelay]])
     * ```
     *
     * Call with no arguments will log calls to setTimeout while debugging (`log-setTimeout` superseding),
     * so production filter lists' rules definitely require at least one of the parameters:
     * - `matchCallback`  optional, string or regular expression; invalid regular expression will be skipped and all callbacks will be matched.
     * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.
     * If do not start with `!`, the stringified callback will be matched.
     * If not set, prevents all `setTimeout` calls due to specified `matchDelay`.
     * - `matchDelay`  optional, must be an integer.
     * If starts with `!`, scriptlet will not match the delay but all other will be defused.
     * If do not start with `!`, the delay passed to the `setTimeout` call will be matched.
     * Decimal delay values will be rounded down, e.g `10.95` will be matched by `matchDelay` with value `10`.
     *
     * > If `prevent-setTimeout` log looks like `setTimeout(undefined, 1000)`,
     * it means that no callback was passed to setTimeout() and that's not scriptlet issue
     * and obviously it can not be matched by `matchCallback`.
     *
     * **Examples**
     * 1. Prevents `setTimeout` calls if the callback matches `/\.test/` regardless of the delay.
     *     ```bash
     *     example.org#%#//scriptlet('prevent-setTimeout', '/\.test/')
     *     ```
     *
     *     For instance, the following call will be prevented:
     *     ```javascript
     *     setTimeout(function () {
     *         window.test = "value";
     *     }, 100);
     *     ```
     *
     * 2. Prevents `setTimeout` calls if the callback does not contain `value`.
     *     ```
     *     example.org#%#//scriptlet('prevent-setTimeout', '!value')
     *     ```
     *
     *     For instance, only the first of the following calls will be prevented:
     *     ```javascript
     *     setTimeout(function () {
     *         window.test = "test -- prevented";
     *     }, 300);
     *     setTimeout(function () {
     *         window.test = "value -- executed";
     *     }, 400);
     *     setTimeout(function () {
     *         window.value = "test -- executed";
     *     }, 500);
     *     ```
     *
     * 3. Prevents `setTimeout` calls if the callback contains `value` and the delay is not set to `300`.
     *     ```
     *     example.org#%#//scriptlet('prevent-setTimeout', 'value', '!300')
     *     ```
     *
     *     For instance, only the first of the following calls will not be prevented:
     *     ```javascript
     *     setTimeout(function () {
     *         window.test = "value 1 -- executed";
     *     }, 300);
     *     setTimeout(function () {
     *         window.test = "value 2 -- prevented";
     *     }, 400);
     *     setTimeout(function () {
     *         window.test = "value 3 -- prevented";
     *     }, 500);
     *     ```
     *
     * 4. Prevents `setTimeout` calls if the callback does not contain `value` and the delay is not set to `300`.
     *     ```
     *     example.org#%#//scriptlet('prevent-setTimeout', '!value', '!300')
     *     ```
     *
     *     For instance, only the second of the following calls will be prevented:
     *     ```javascript
     *     setTimeout(function () {
     *         window.test = "test -- executed";
     *     }, 300);
     *     setTimeout(function () {
     *         window.test = "test -- prevented";
     *     }, 400);
     *     setTimeout(function () {
     *         window.test = "value -- executed";
     *     }, 400);
     *     setTimeout(function () {
     *         window.value = "test -- executed";
     *     }, 500);
     *     ```
     *
     * 5. Prevents `setTimeout` calls if the callback contains `value` and delay is a decimal.
     *     ```
     *     example.org#%#//scriptlet('prevent-setTimeout', 'value', '300')
     *     ```
     *
     *     For instance, the following calls will be prevented:
     *     ```javascript
     *     setTimeout(function () {
     *         window.test = "value";
     *     }, 300);
     *     setTimeout(function () {
     *         window.test = "value";
     *     }, 300 + Math.random());
     *     ```
     */
    /* eslint-enable max-len */
    function preventSetTimeout$1(source, matchCallback, matchDelay) {
      // logs setTimeouts to console if no arguments have been specified
      const shouldLog = typeof matchCallback === 'undefined' && typeof matchDelay === 'undefined';
      const handlerWrapper = function handlerWrapper(target, thisArg, args) {
        const callback = args[0];
        const delay = args[1];
        let shouldPrevent = false;
        if (shouldLog) {
          hit(source);
          // https://github.com/AdguardTeam/Scriptlets/issues/105
          logMessage(source, "setTimeout(".concat(String(callback), ", ").concat(delay, ")"), true);
        } else {
          shouldPrevent = isPreventionNeeded({
            callback,
            delay,
            matchCallback,
            matchDelay
          });
        }
        if (shouldPrevent) {
          hit(source);
          args[0] = noopFunc;
        }
        return target.apply(thisArg, args);
      };
      const setTimeoutHandler = {
        apply: handlerWrapper
      };
      window.setTimeout = new Proxy(window.setTimeout, setTimeoutHandler);
    }
    preventSetTimeout$1.names = ['prevent-setTimeout',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'no-setTimeout-if.js',
    // new implementation of setTimeout-defuser.js
    'ubo-no-setTimeout-if.js', 'nostif.js',
    // new short name of no-setTimeout-if
    'ubo-nostif.js', 'ubo-no-setTimeout-if', 'ubo-nostif',
    // old scriptlet names which should be supported as well.
    // should be removed eventually.
    // do not remove until other filter lists maintainers use them
    'setTimeout-defuser.js', 'ubo-setTimeout-defuser.js', 'ubo-setTimeout-defuser', 'std.js', 'ubo-std.js', 'ubo-std'];
    preventSetTimeout$1.injections = [hit, noopFunc, isPreventionNeeded, logMessage,
    // following helpers should be injected as helpers above use them
    parseMatchArg, parseDelayArg, toRegExp, startsWith$1, nativeIsNaN, isValidCallback, isValidMatchStr, escapeRegExp, isValidStrPattern, nativeIsFinite, isValidMatchNumber, parseRawDelay];

    /* eslint-disable max-len */
    /**
     * @scriptlet prevent-setInterval
     * @description
     * Prevents a `setInterval` call if:
     * 1) the text of the callback is matching the specified `matchCallback` string/regexp which does not start with `!`;
     * otherwise mismatched calls should be defused;
     * 2) the delay is matching the specified `matchDelay`; otherwise mismatched calls should be defused.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-setinterval-ifjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-setInterval'[, matchCallback[, matchDelay]])
     * ```
     *
     * Call with no arguments will log calls to setInterval while debugging (`log-setInterval` superseding),
     * so production filter lists' rules definitely require at least one of the parameters:
     * - `matchCallback`  optional, string or regular expression; invalid regular expression will be skipped and all callbacks will be matched.
     * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.
     * If do not start with `!`, the stringified callback will be matched.
     * If not set, prevents all `setInterval` calls due to specified `matchDelay`.
     * - `matchDelay`  optional, must be an integer.
     * If starts with `!`, scriptlet will not match the delay but all other will be defused.
     * If do not start with `!`, the delay passed to the `setInterval` call will be matched.
     * Decimal delay values will be rounded down, e.g `10.95` will be matched by `matchDelay` with value `10`.
     *
     * > If `prevent-setInterval` log looks like `setInterval(undefined, 1000)`,
     * it means that no callback was passed to setInterval() and that's not scriptlet issue
     * and obviously it can not be matched by `matchCallback`.
     *
     *  **Examples**
     * 1. Prevents `setInterval` calls if the callback matches `/\.test/` regardless of the delay.
     *     ```bash
     *     example.org#%#//scriptlet('prevent-setInterval', '/\.test/')
     *     ```
     *
     *     For instance, the following call will be prevented:
     *     ```javascript
     *     setInterval(function () {
     *         window.test = "value";
     *     }, 100);
     *     ```
     *
     * 2. Prevents `setInterval` calls if the callback does not contain `value`.
     *     ```
     *     example.org#%#//scriptlet('prevent-setInterval', '!value')
     *     ```
     *
     *     For instance, only the first of the following calls will be prevented:
     *     ```javascript
     *     setInterval(function () {
     *         window.test = "test -- prevented";
     *     }, 300);
     *     setInterval(function () {
     *         window.test = "value -- executed";
     *     }, 400);
     *     setInterval(function () {
     *         window.value = "test -- executed";
     *     }, 500);
     *     ```
     *
     * 3. Prevents `setInterval` calls if the callback contains `value` and the delay is not set to `300`.
     *     ```
     *     example.org#%#//scriptlet('prevent-setInterval', 'value', '!300')
     *     ```
     *
     *     For instance, only the first of the following calls will not be prevented:
     *     ```javascript
     *     setInterval(function () {
     *         window.test = "value 1 -- executed";
     *     }, 300);
     *     setInterval(function () {
     *         window.test = "value 2 -- prevented";
     *     }, 400);
     *     setInterval(function () {
     *         window.test = "value 3 -- prevented";
     *     }, 500);
     *     ```
     *
     * 4. Prevents `setInterval` calls if the callback does not contain `value` and the delay is not set to `300`.
     *     ```
     *     example.org#%#//scriptlet('prevent-setInterval', '!value', '!300')
     *     ```
     *
     *     For instance, only the second of the following calls will be prevented:
     *     ```javascript
     *     setInterval(function () {
     *         window.test = "test -- executed";
     *     }, 300);
     *     setInterval(function () {
     *         window.test = "test -- prevented";
     *     }, 400);
     *     setInterval(function () {
     *         window.test = "value -- executed";
     *     }, 400);
     *     setInterval(function () {
     *         window.value = "test -- executed";
     *     }, 500);
     *     ```
     *
     * 5. Prevents `setInterval` calls if the callback contains `value` and delay is a decimal.
     *     ```
     *     example.org#%#//scriptlet('prevent-setInterval', 'value', '300')
     *     ```
     *
     *     For instance, the following calls will be prevented:
     *     ```javascript
     *     setInterval(function () {
     *         window.test = "value";
     *     }, 300);
     *     setInterval(function () {
     *         window.test = "value";
     *     }, 300 + Math.random());
     *     ```
     */
    /* eslint-enable max-len */
    function preventSetInterval$1(source, matchCallback, matchDelay) {
      // logs setIntervals to console if no arguments have been specified
      const shouldLog = typeof matchCallback === 'undefined' && typeof matchDelay === 'undefined';
      const handlerWrapper = function handlerWrapper(target, thisArg, args) {
        const callback = args[0];
        const delay = args[1];
        let shouldPrevent = false;
        if (shouldLog) {
          hit(source);
          // https://github.com/AdguardTeam/Scriptlets/issues/105
          logMessage(source, "setInterval(".concat(String(callback), ", ").concat(delay, ")"), true);
        } else {
          shouldPrevent = isPreventionNeeded({
            callback,
            delay,
            matchCallback,
            matchDelay
          });
        }
        if (shouldPrevent) {
          hit(source);
          args[0] = noopFunc;
        }
        return target.apply(thisArg, args);
      };
      const setIntervalHandler = {
        apply: handlerWrapper
      };
      window.setInterval = new Proxy(window.setInterval, setIntervalHandler);
    }
    preventSetInterval$1.names = ['prevent-setInterval',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'no-setInterval-if.js',
    // new implementation of setInterval-defuser.js
    'ubo-no-setInterval-if.js', 'setInterval-defuser.js',
    // old name should be supported as well
    'ubo-setInterval-defuser.js', 'nosiif.js',
    // new short name of no-setInterval-if
    'ubo-nosiif.js', 'sid.js',
    // old short scriptlet name
    'ubo-sid.js', 'ubo-no-setInterval-if', 'ubo-setInterval-defuser', 'ubo-nosiif', 'ubo-sid'];
    preventSetInterval$1.injections = [hit, noopFunc, isPreventionNeeded, logMessage,
    // following helpers should be injected as helpers above use them
    toRegExp, startsWith$1, nativeIsNaN, parseMatchArg, parseDelayArg, isValidCallback, isValidMatchStr, isValidStrPattern, escapeRegExp, nativeIsFinite, isValidMatchNumber, parseRawDelay];

    /* eslint-disable max-len */
    /**
     * @scriptlet prevent-window-open
     * @description
     * Prevents `window.open` calls when URL either matches or not matches the specified string/regexp. Using it without parameters prevents all `window.open` calls.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#windowopen-defuserjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-window-open'[, match[, delay[, replacement]]])
     * ```
     *
     * - `match`  optional, string or regular expression. If not set or regular expression is invalid, all window.open calls will be matched.
     * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.
     * If do not start with `!`, the stringified callback will be matched.
     * - `delay`  optional, number of seconds. If not set, scriptlet will return `null`,
     * otherwise valid sham window object as injected `iframe` will be returned
     * for accessing its methods (blur(), focus() etc.) and will be removed after the delay.
     * - `replacement`  optional, string; one of the predefined constants:
     *     - `obj`  for returning an object instead of default iframe;
     *        for cases when the page requires a valid `window` instance to be returned
     *     - `log`  for logging window.open calls; permitted for production filter lists.
     *
     * **Examples**
     * 1. Prevent all `window.open` calls:
     *     ```
     *     example.org#%#//scriptlet('prevent-window-open')
     *     ```
     *
     * 2. Prevent `window.open` for all URLs containing `example`:
     *     ```
     *     example.org#%#//scriptlet('prevent-window-open', 'example')
     *     ```
     *
     * 3. Prevent `window.open` for all URLs matching RegExp `/example\./`:
     *     ```
     *     example.org#%#//scriptlet('prevent-window-open', '/example\./')
     *     ```
     *
     * 4. Prevent `window.open` for all URLs **NOT** containing `example`:
     *     ```
     *     example.org#%#//scriptlet('prevent-window-open', '!example')
     *     ```
     *
     * Old syntax of prevent-window-open parameters:
     * - `match`  optional, defaults to "matching", any positive number or nothing for "matching", 0 or empty string for "not matching"
     * - `search`  optional, string or regexp for matching the URL passed to `window.open` call; defaults to search all `window.open` call
     * - `replacement`  optional, string to return prop value or property instead of window.open; defaults to return noopFunc.
     * **Examples**
     *     ```
     *     example.org#%#//scriptlet('prevent-window-open', '1', '/example\./')
     *     example.org#%#//scriptlet('prevent-window-open', '0', 'example')
     *     example.org#%#//scriptlet('prevent-window-open', '', '', 'trueFunc')
     *     example.org#%#//scriptlet('prevent-window-open', '1', '', '{propName=noopFunc}')
     *     ```
     *
     * > For better compatibility with uBO, old syntax is not recommended to use.
     */
    /* eslint-enable max-len */
    function preventWindowOpen$1(source) {
      let match = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '*';
      let delay = arguments.length > 2 ? arguments[2] : undefined;
      let replacement = arguments.length > 3 ? arguments[3] : undefined;
      // default match value is needed for preventing all window.open calls
      // if scriptlet runs without args
      const nativeOpen = window.open;
      const isNewSyntax = match !== '0' && match !== '1';
      const oldOpenWrapper = function oldOpenWrapper(str) {
        match = Number(match) > 0;
        // 'delay' was 'search' prop for matching in old syntax
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        if (!isValidStrPattern(delay)) {
          logMessage(source, "Invalid parameter: ".concat(delay));
          return nativeOpen.apply(window, [str, ...args]);
        }
        const searchRegexp = toRegExp(delay);
        if (match !== searchRegexp.test(str)) {
          return nativeOpen.apply(window, [str, ...args]);
        }
        hit(source);
        return handleOldReplacement(replacement);
      };
      const newOpenWrapper = function newOpenWrapper(url) {
        const shouldLog = replacement && replacement.indexOf('log') > -1;
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        if (shouldLog) {
          const argsStr = args && args.length > 0 ? ", ".concat(args.join(', ')) : '';
          const message = "".concat(url).concat(argsStr);
          logMessage(source, message, true);
          hit(source);
        }
        let shouldPrevent = false;
        if (match === '*') {
          shouldPrevent = true;
        } else if (isValidMatchStr(match)) {
          const _parseMatchArg = parseMatchArg(match),
            isInvertedMatch = _parseMatchArg.isInvertedMatch,
            matchRegexp = _parseMatchArg.matchRegexp;
          shouldPrevent = matchRegexp.test(url) !== isInvertedMatch;
        } else {
          logMessage(source, "Invalid parameter: ".concat(match));
          shouldPrevent = false;
        }
        if (shouldPrevent) {
          const parsedDelay = parseInt(delay, 10);
          let result;
          if (nativeIsNaN(parsedDelay)) {
            result = noopNull();
          } else {
            const decoyArgs = {
              replacement,
              url,
              delay: parsedDelay
            };
            const decoy = createDecoy(decoyArgs);
            let popup = decoy.contentWindow;
            if (typeof popup === 'object' && popup !== null) {
              Object.defineProperty(popup, 'closed', {
                value: false
              });
              Object.defineProperty(popup, 'opener', {
                value: window
              });
              Object.defineProperty(popup, 'frameElement', {
                value: null
              });
            } else {
              const nativeGetter = decoy.contentWindow && decoy.contentWindow.get;
              Object.defineProperty(decoy, 'contentWindow', {
                get: getPreventGetter(nativeGetter)
              });
              popup = decoy.contentWindow;
            }
            result = popup;
          }
          hit(source);
          return result;
        }
        return nativeOpen.apply(window, [url, ...args]);
      };
      window.open = isNewSyntax ? newOpenWrapper : oldOpenWrapper;

      // Protect window.open from native code check
      window.open.toString = nativeOpen.toString.bind(nativeOpen);
    }
    preventWindowOpen$1.names = ['prevent-window-open',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'window.open-defuser.js', 'ubo-window.open-defuser.js', 'ubo-window.open-defuser', 'nowoif.js', 'ubo-nowoif.js', 'ubo-nowoif'];
    preventWindowOpen$1.injections = [hit, isValidStrPattern, escapeRegExp, isValidMatchStr, toRegExp, nativeIsNaN, parseMatchArg, handleOldReplacement, createDecoy, getPreventGetter, noopNull, logMessage, noopFunc, trueFunc, startsWith$1, endsWith, substringBefore, substringAfter$1];

    /* eslint-disable max-len */
    /**
     * @scriptlet abort-current-inline-script
     * @description
     * Aborts an inline script when it attempts to **read** or **write to** the specified property
     * AND when the contents of the `<script>` element contains the specified
     * text or matches the regular expression.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-current-inline-scriptjs-
     *
     * Related ABP source:
     * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L928
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('abort-current-inline-script', property[, search])
     * ```
     *
     * - `property`  required, path to a property (joined with `.` if needed). The property must be attached to `window`
     * - `search`  optional, string or regular expression that must match the inline script content.
     * Defaults to abort all scripts which are trying to access the specified property.
     * Invalid regular expression will cause exit and rule will not work.
     *
     * > Note please that for inline script with addEventListener in it
     * `property` should be set as `EventTarget.prototype.addEventListener`,
     * not just `addEventListener`.
     *
     * **Examples**
     * 1. Aborts all inline scripts trying to access `window.alert`
     *     ```
     *     example.org#%#//scriptlet('abort-current-inline-script', 'alert')
     *     ```
     *
     * 2. Aborts inline scripts which are trying to access `window.alert` and contain `Hello, world`.
     *     ```
     *     example.org#%#//scriptlet('abort-current-inline-script', 'alert', 'Hello, world')
     *     ```
     *
     *     For instance, the following script will be aborted
     *     ```html
     *     <script>alert("Hello, world");</script>
     *     ```
     *
     * 3. Aborts inline scripts which are trying to access `window.alert` and match this regexp: `/Hello.+world/`.
     *     ```
     *     example.org#%#//scriptlet('abort-current-inline-script', 'alert', '/Hello.+world/')
     *     ```
     *
     *     For instance, the following scripts will be aborted:
     *     ```html
     *     <script>alert("Hello, big world");</script>
     *     ```
     *     ```html
     *     <script>alert("Hello, little world");</script>
     *     ```
     *
     *     This script will not be aborted:
     *     ```html
     *     <script>alert("Hi, little world");</script>
     *     ```
     */
    /* eslint-enable max-len */
    function abortCurrentInlineScript$1(source, property, search) {
      const searchRegexp = toRegExp(search);
      const rid = randomId();
      const SRC_DATA_MARKER = 'data:text/javascript;base64,';
      const getCurrentScript = function getCurrentScript() {
        if ('currentScript' in document) {
          return document.currentScript;
        }
        const scripts = document.getElementsByTagName('script');
        return scripts[scripts.length - 1];
      };
      const ourScript = getCurrentScript();
      const abort = function abort() {
        const scriptEl = getCurrentScript();
        if (!scriptEl) {
          return;
        }
        let content = scriptEl.textContent;

        // We are using Node.prototype.textContent property descriptor
        // to get the real script content
        // even when document.currentScript.textContent is replaced.
        // https://github.com/AdguardTeam/Scriptlets/issues/57#issuecomment-593638991
        try {
          const textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
          content = textContentGetter.call(scriptEl);
        } catch (e) {} // eslint-disable-line no-empty

        // https://github.com/AdguardTeam/Scriptlets/issues/130
        if (content.length === 0 && typeof scriptEl.src !== 'undefined' && startsWith$1(scriptEl.src, SRC_DATA_MARKER)) {
          const encodedContent = scriptEl.src.slice(SRC_DATA_MARKER.length);
          content = window.atob(encodedContent);
        }
        if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
          hit(source);
          throw new ReferenceError(rid);
        }
      };
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;

        // The scriptlet might be executed before the chain property has been created
        // (for instance, document.body before the HTML body was loaded).
        // In this case we're checking whether the base element exists or not
        // and if not, we simply exit without overriding anything.
        // e.g. https://github.com/AdguardTeam/Scriptlets/issues/57#issuecomment-575841092
        if (base instanceof Object === false && base === null) {
          const props = property.split('.');
          const propIndex = props.indexOf(prop);
          const baseName = props[propIndex - 1];
          const message = "The scriptlet had been executed before the ".concat(baseName, " was loaded.");
          logMessage(source, message);
          return;
        }
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        let currentValue = base[prop];
        let origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
        if (origDescriptor instanceof Object === false || origDescriptor.get instanceof Function === false) {
          currentValue = base[prop];
          origDescriptor = undefined;
        }
        const descriptorWrapper = Object.assign(getDescriptorAddon(), {
          currentValue,
          get() {
            if (!this.isAbortingSuspended) {
              this.isolateCallback(abort);
            }
            if (origDescriptor instanceof Object) {
              return origDescriptor.get.call(base);
            }
            return this.currentValue;
          },
          set(newValue) {
            if (!this.isAbortingSuspended) {
              this.isolateCallback(abort);
            }
            if (origDescriptor instanceof Object) {
              origDescriptor.set.call(base, newValue);
            } else {
              this.currentValue = newValue;
            }
          }
        });
        setPropertyAccess(base, prop, {
          // Call wrapped getter and setter to keep isAbortingSuspended & isolateCallback values
          get() {
            return descriptorWrapper.get.call(descriptorWrapper);
          },
          set(newValue) {
            descriptorWrapper.set.call(descriptorWrapper, newValue);
          }
        });
      };
      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    abortCurrentInlineScript$1.names = ['abort-current-inline-script',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'abort-current-script.js', 'ubo-abort-current-script.js', 'acs.js', 'ubo-acs.js',
    // "ubo"-aliases with no "js"-ending
    'ubo-abort-current-script', 'ubo-acs',
    // obsolete but supported aliases
    'abort-current-inline-script.js', 'ubo-abort-current-inline-script.js', 'acis.js', 'ubo-acis.js', 'ubo-abort-current-inline-script', 'ubo-acis', 'abp-abort-current-inline-script'];
    abortCurrentInlineScript$1.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, startsWith$1, createOnErrorHandler, hit, logMessage, isEmptyObject, getDescriptorAddon];

    /* eslint-disable max-len */
    /**
     * @scriptlet set-constant
     * @description
     * Creates a constant property and assigns it one of the values from the predefined list.
     *
     * > Actually, it's not a constant. Please note, that it can be rewritten with a value of a different type.
     *
     * > If empty object is present in chain it will be trapped until chain leftovers appear.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#set-constantjs-
     *
     * Related ABP snippet:
     * https://github.com/adblockplus/adblockpluscore/blob/adblockpluschrome-3.9.4/lib/content/snippets.js#L1361
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('set-constant', property, value[, stack])
     * ```
     *
     * - `property`  required, path to a property (joined with `.` if needed). The property must be attached to `window`.
     * - `value`  required. Possible values:
     *     - positive decimal integer `<= 32767`
     *     - one of the predefined constants:
     *         - `undefined`
     *         - `false`
     *         - `true`
     *         - `null`
     *         - `emptyObj`  empty object
     *         - `emptyArr`  empty array
     *         - `noopFunc`  function with empty body
     *         - `noopCallbackFunc`  function returning noopFunc
     *         - `trueFunc`  function returning true
     *         - `falseFunc`  function returning false
     *         - `throwFunc`  function throwing an error
     *         - `noopPromiseResolve`  function returning Promise object that is resolved with an empty response
     *         - `noopPromiseReject`  function returning Promise.reject()
     *         - `''`  empty string
     *         - `-1`  number value `-1`
     *         - `yes`
     *         - `no`
     * - `stack`  optional, string or regular expression that must match the current function call stack trace;
     * if regular expression is invalid it will be skipped
     *
     * **Examples**
     * ```
     * ! Any access to `window.first` will return `false`
     * example.org#%#//scriptlet('set-constant', 'first', 'false')
     *
     *  window.first === false
     * ```
     *
     * ```
     * ! Any call to `window.second()` will return `true`
     * example.org#%#//scriptlet('set-constant', 'second', 'trueFunc')
     *
     *  window.second() === true
     *  window.second.toString() === "function trueFunc() {return true;}"
     * ```
     *
     * ```
     * ! Any call to `document.third()` will return `true` if the method is related to `checking.js`
     * example.org#%#//scriptlet('set-constant', 'document.third', 'trueFunc', 'checking.js')
     *
     *  document.third() === true  // if the condition described above is met
     * ```
     */
    /* eslint-enable max-len */
    function setConstant$1(source, property, value, stack) {
      if (!property || !matchStackTrace(stack, new Error().stack)) {
        return;
      }
      const emptyArr = noopArray();
      const emptyObj = noopObject();
      let constantValue;
      if (value === 'undefined') {
        constantValue = undefined;
      } else if (value === 'false') {
        constantValue = false;
      } else if (value === 'true') {
        constantValue = true;
      } else if (value === 'null') {
        constantValue = null;
      } else if (value === 'emptyArr') {
        constantValue = emptyArr;
      } else if (value === 'emptyObj') {
        constantValue = emptyObj;
      } else if (value === 'noopFunc') {
        constantValue = noopFunc;
      } else if (value === 'noopCallbackFunc') {
        constantValue = noopCallbackFunc;
      } else if (value === 'trueFunc') {
        constantValue = trueFunc;
      } else if (value === 'falseFunc') {
        constantValue = falseFunc;
      } else if (value === 'throwFunc') {
        constantValue = throwFunc;
      } else if (value === 'noopPromiseResolve') {
        constantValue = noopPromiseResolve;
      } else if (value === 'noopPromiseReject') {
        constantValue = noopPromiseReject;
      } else if (/^\d+$/.test(value)) {
        constantValue = parseFloat(value);
        if (nativeIsNaN(constantValue)) {
          return;
        }
        if (Math.abs(constantValue) > 32767) {
          return;
        }
      } else if (value === '-1') {
        constantValue = -1;
      } else if (value === '') {
        constantValue = '';
      } else if (value === 'yes') {
        constantValue = 'yes';
      } else if (value === 'no') {
        constantValue = 'no';
      } else {
        return;
      }
      let canceled = false;
      const mustCancel = function mustCancel(value) {
        if (canceled) {
          return canceled;
        }
        canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue && value !== null;
        return canceled;
      };

      /**
       * Safely sets property on a given object
       *
       * IMPORTANT! this duplicates corresponding func in trusted-set-constant scriptlet as
       * reorganizing this to common helpers will most definitely complicate debugging
       *
       * @param {Object} base arbitrary reachable object
       * @param {string} prop property name
       * @param {boolean} configurable if set property should be configurable
       * @param {Object} handler custom property descriptor object
       * @returns {boolean} true if prop was trapped successfully
       */
      const trapProp = function trapProp(base, prop, configurable, handler) {
        if (!handler.init(base[prop])) {
          return false;
        }
        const origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
        let prevSetter;
        // This is required to prevent scriptlets overwrite each over
        if (origDescriptor instanceof Object) {
          // This check is required to avoid defining non-configurable props
          if (!origDescriptor.configurable) {
            const message = "Property '".concat(prop, "' is not configurable");
            logMessage(source, message);
            return false;
          }
          base[prop] = constantValue;
          if (origDescriptor.set instanceof Function) {
            prevSetter = origDescriptor.set;
          }
        }
        Object.defineProperty(base, prop, {
          configurable,
          get() {
            return handler.get();
          },
          set(a) {
            if (prevSetter !== undefined) {
              prevSetter(a);
            }
            handler.set(a);
          }
        });
        return true;
      };

      /**
       * Traverses given chain to set constant value to its end prop
       * Chains that yet include non-object values (e.g null) are valid and will be
       * traversed when appropriate chain member is set by an external script
       *
       * IMPORTANT! this duplicates corresponding func in trusted-set-constant scriptlet as
       * reorganizing this to common helpers will most definitely complicate debugging
       *
       * @param {Object} owner object that owns chain
       * @param {string} property chain of owner properties
       */
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        const base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;

        // Handler method init is used to keep track of factual value
        // and apply mustCancel() check only on end prop
        const inChainPropHandler = {
          factValue: undefined,
          init(a) {
            this.factValue = a;
            return true;
          },
          get() {
            return this.factValue;
          },
          set(a) {
            // Prevent breakage due to loop assignments like win.obj = win.obj
            if (this.factValue === a) {
              return;
            }
            this.factValue = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          }
        };
        const endPropHandler = {
          init(a) {
            if (mustCancel(a)) {
              return false;
            }
            return true;
          },
          get() {
            return constantValue;
          },
          set(a) {
            if (!mustCancel(a)) {
              return;
            }
            constantValue = a;
          }
        };

        // End prop case
        if (!chain) {
          const isTrapped = trapProp(base, prop, false, endPropHandler);
          if (isTrapped) {
            hit(source);
          }
          return;
        }

        // Null prop in chain
        if (base !== undefined && base[prop] === null) {
          trapProp(base, prop, true, inChainPropHandler);
          return;
        }

        // Empty object prop in chain
        if ((base instanceof Object || typeof base === 'object') && isEmptyObject(base)) {
          trapProp(base, prop, true, inChainPropHandler);
        }

        // Defined prop in chain
        const propValue = owner[prop];
        if (propValue instanceof Object || typeof propValue === 'object' && propValue !== null) {
          setChainPropAccess(propValue, chain);
        }

        // Undefined prop in chain
        trapProp(base, prop, true, inChainPropHandler);
      };
      setChainPropAccess(window, property);
    }
    setConstant$1.names = ['set-constant',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'set-constant.js', 'ubo-set-constant.js', 'set.js', 'ubo-set.js', 'ubo-set-constant', 'ubo-set', 'abp-override-property-read'];
    setConstant$1.injections = [hit, logMessage, noopArray, noopObject, noopFunc, noopCallbackFunc, trueFunc, falseFunc, throwFunc, noopPromiseReject, noopPromiseResolve, getPropertyInChain, setPropertyAccess, toRegExp, matchStackTrace, nativeIsNaN, isEmptyObject, getNativeRegexpTest,
    // following helpers should be imported and injected
    // because they are used by helpers above
    shouldAbortInlineOrInjectedScript];

    /* eslint-disable max-len */
    /**
     * @scriptlet remove-cookie
     * @description
     * Removes current page cookies by passed string matching with name. For current domain and subdomains. Runs on load and before unload.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#cookie-removerjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('remove-cookie'[, match])
     * ```
     *
     * - `match`  optional, string or regex matching the cookie name. If not specified all accessible cookies will be removed.
     *
     * **Examples**
     * 1. Removes all cookies:
     *     ```
     *     example.org#%#//scriptlet('remove-cookie')
     *     ```
     *
     * 2. Removes cookies which name contains `example` string:
     *     ```
     *     example.org#%#//scriptlet('remove-cookie', 'example')
     *     ```
     *
     *     For instance this cookie will be removed:
     *
     *     ```javascript
     *     document.cookie = '__example=randomValue';
     *     ```
     */
    /* eslint-enable max-len */
    function removeCookie$1(source, match) {
      const matchRegexp = toRegExp(match);
      const removeCookieFromHost = function removeCookieFromHost(cookieName, hostName) {
        const cookieSpec = "".concat(cookieName, "=");
        const domain1 = "; domain=".concat(hostName);
        const domain2 = "; domain=.".concat(hostName);
        const path = '; path=/';
        const expiration = '; expires=Thu, 01 Jan 1970 00:00:00 GMT';
        document.cookie = cookieSpec + expiration;
        document.cookie = cookieSpec + domain1 + expiration;
        document.cookie = cookieSpec + domain2 + expiration;
        document.cookie = cookieSpec + path + expiration;
        document.cookie = cookieSpec + domain1 + path + expiration;
        document.cookie = cookieSpec + domain2 + path + expiration;
        hit(source);
      };
      const rmCookie = function rmCookie() {
        document.cookie.split(';').forEach(function (cookieStr) {
          const pos = cookieStr.indexOf('=');
          if (pos === -1) {
            return;
          }
          const cookieName = cookieStr.slice(0, pos).trim();
          if (!matchRegexp.test(cookieName)) {
            return;
          }
          const hostParts = document.location.hostname.split('.');
          for (let i = 0; i <= hostParts.length - 1; i += 1) {
            const hostName = hostParts.slice(i).join('.');
            if (hostName) {
              removeCookieFromHost(cookieName, hostName);
            }
          }
        });
      };
      rmCookie();
      window.addEventListener('beforeunload', rmCookie);
    }
    removeCookie$1.names = ['remove-cookie',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'cookie-remover.js', 'ubo-cookie-remover.js', 'ubo-cookie-remover'];
    removeCookie$1.injections = [toRegExp, hit];

    /* eslint-disable max-len */
    /**
     * @scriptlet prevent-addEventListener
     * @description
     * Prevents adding event listeners for the specified events and callbacks.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#addeventlistener-defuserjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-addEventListener'[, typeSearch[, listenerSearch]])
     * ```
     *
     * - `typeSearch`  optional, string or regular expression matching the type (event name);
     * defaults to match all types; invalid regular expression will cause exit and rule will not work
     * - `listenerSearch`  optional, string or regular expression matching the listener function body;
     * defaults to match all listeners; invalid regular expression will cause exit and rule will not work
     *
     * **Examples**
     * 1. Prevent all `click` listeners:
     *     ```
     *     example.org#%#//scriptlet('prevent-addEventListener', 'click')
     *     ```
     *
    2. Prevent 'click' listeners with the callback body containing `searchString`.
     *     ```
     *     example.org#%#//scriptlet('prevent-addEventListener', 'click', 'searchString')
     *     ```
     *
     *     For instance, this listener will not be called:
     *
     *     ```javascript
     *     el.addEventListener('click', () => {
     *         window.test = 'searchString';
     *     });
     *     ```
     */
    /* eslint-enable max-len */
    function preventAddEventListener$1(source, typeSearch, listenerSearch) {
      const typeSearchRegexp = toRegExp(typeSearch);
      const listenerSearchRegexp = toRegExp(listenerSearch);
      const nativeAddEventListener = window.EventTarget.prototype.addEventListener;
      function addEventListenerWrapper(type, listener) {
        var _this$constructor;
        let shouldPrevent = false;
        if (validateType(type) && validateListener(listener)) {
          shouldPrevent = typeSearchRegexp.test(type.toString()) && listenerSearchRegexp.test(listenerToString(listener));
        }
        if (shouldPrevent) {
          hit(source);
          return undefined;
        }

        // Avoid illegal invocations due to lost context
        // https://github.com/AdguardTeam/Scriptlets/issues/271
        let context = this;
        if (this && ((_this$constructor = this.constructor) === null || _this$constructor === void 0 ? void 0 : _this$constructor.name) === 'Window' && this !== window) {
          context = window;
        }
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return nativeAddEventListener.apply(context, [type, listener, ...args]);
      }
      const descriptor = {
        configurable: true,
        set: function set() {},
        get: function get() {
          return addEventListenerWrapper;
        }
      };
      // https://github.com/AdguardTeam/Scriptlets/issues/215
      // https://github.com/AdguardTeam/Scriptlets/issues/143
      Object.defineProperty(window.EventTarget.prototype, 'addEventListener', descriptor);
      Object.defineProperty(window, 'addEventListener', descriptor);
      Object.defineProperty(document, 'addEventListener', descriptor);
    }
    preventAddEventListener$1.names = ['prevent-addEventListener',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'addEventListener-defuser.js', 'ubo-addEventListener-defuser.js', 'aeld.js', 'ubo-aeld.js', 'ubo-addEventListener-defuser', 'ubo-aeld'];
    preventAddEventListener$1.injections = [hit, toRegExp, validateType, validateListener, listenerToString];

    /* eslint-disable consistent-return, no-eval */

    /**
     * @scriptlet prevent-bab
     * @description
     * Prevents BlockAdblock script from detecting an ad blocker.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#bab-defuserjs-
     *
     * It also can be used as `$redirect` sometimes.
     * See [redirect description](../wiki/about-redirects.md#prevent-bab).
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-bab')
     * ```
     */
    function preventBab$2(source) {
      const nativeSetTimeout = window.setTimeout;
      const babRegex = /\.bab_elementid.$/;
      const timeoutWrapper = function timeoutWrapper(callback) {
        if (typeof callback !== 'string' || !babRegex.test(callback)) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          return nativeSetTimeout.apply(window, [callback, ...args]);
        }
        hit(source);
      };
      window.setTimeout = timeoutWrapper;
      const signatures = [['blockadblock'], ['babasbm'], [/getItem\('babn'\)/], ['getElementById', 'String.fromCharCode', 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', 'charAt', 'DOMContentLoaded', 'AdBlock', 'addEventListener', 'doScroll', 'fromCharCode', '<<2|r>>4', 'sessionStorage', 'clientWidth', 'localStorage', 'Math', 'random']];
      const check = function check(str) {
        if (typeof str !== 'string') {
          return false;
        }
        for (let i = 0; i < signatures.length; i += 1) {
          const tokens = signatures[i];
          let match = 0;
          for (let j = 0; j < tokens.length; j += 1) {
            const token = tokens[j];
            const found = token instanceof RegExp ? token.test(str) : str.indexOf(token) > -1;
            if (found) {
              match += 1;
            }
          }
          if (match / tokens.length >= 0.8) {
            return true;
          }
        }
        return false;
      };
      const nativeEval = window.eval;
      const evalWrapper = function evalWrapper(str) {
        if (!check(str)) {
          return nativeEval(str);
        }
        hit(source);
        const bodyEl = document.body;
        if (bodyEl) {
          bodyEl.style.removeProperty('visibility');
        }
        const el = document.getElementById('babasbmsgx');
        if (el) {
          el.parentNode.removeChild(el);
        }
      };
      window.eval = evalWrapper.bind(window);
    }
    preventBab$2.names = ['prevent-bab'
    // there is no aliases for this scriptlet
    ];

    preventBab$2.injections = [hit];

    /* eslint-disable no-unused-vars, no-extra-bind, func-names */

    /* eslint-disable max-len */
    /**
     * @scriptlet nowebrtc
     * @description
     * Disables WebRTC by overriding `RTCPeerConnection`. The overridden function will log every attempt to create a new connection.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#nowebrtcjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('nowebrtc')
     * ```
     */
    /* eslint-enable max-len */
    function nowebrtc$1(source) {
      let propertyName = '';
      if (window.RTCPeerConnection) {
        propertyName = 'RTCPeerConnection';
      } else if (window.webkitRTCPeerConnection) {
        propertyName = 'webkitRTCPeerConnection';
      }
      if (propertyName === '') {
        return;
      }
      const rtcReplacement = function rtcReplacement(config) {
        // eslint-disable-next-line max-len
        const message = "Document tried to create an RTCPeerConnection: ".concat(convertRtcConfigToString(config));
        logMessage(source, message);
        hit(source);
      };
      rtcReplacement.prototype = {
        close: noopFunc,
        createDataChannel: noopFunc,
        createOffer: noopFunc,
        setRemoteDescription: noopFunc
      };
      const rtc = window[propertyName];
      window[propertyName] = rtcReplacement;
      if (rtc.prototype) {
        rtc.prototype.createDataChannel = function (a, b) {
          return {
            close: noopFunc,
            send: noopFunc
          };
        }.bind(null);
      }
    }
    nowebrtc$1.names = ['nowebrtc',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'nowebrtc.js', 'ubo-nowebrtc.js', 'ubo-nowebrtc'];
    nowebrtc$1.injections = [hit, noopFunc, logMessage, convertRtcConfigToString];

    /**
     * @scriptlet log-addEventListener
     * @description
     * Logs all addEventListener calls to the console.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#addeventlistener-loggerjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('log-addEventListener')
     * ```
     */
    function logAddEventListener$1(source) {
      const nativeAddEventListener = window.EventTarget.prototype.addEventListener;
      function addEventListenerWrapper(type, listener) {
        var _this$constructor;
        if (validateType(type) && validateListener(listener)) {
          const message = "addEventListener(\"".concat(type, "\", ").concat(listenerToString(listener), ")");
          logMessage(source, message, true);
          hit(source);
        }

        // logging while debugging
        const message = "Invalid event type or listener passed to addEventListener:\ntype: ".concat(convertTypeToString(type), "\nlistener: ").concat(convertTypeToString(listener));
        logMessage(source, message, true);

        // Avoid illegal invocations due to lost context
        // https://github.com/AdguardTeam/Scriptlets/issues/271
        let context = this;
        if (this && ((_this$constructor = this.constructor) === null || _this$constructor === void 0 ? void 0 : _this$constructor.name) === 'Window' && this !== window) {
          context = window;
        }
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return nativeAddEventListener.apply(context, [type, listener, ...args]);
      }
      const descriptor = {
        configurable: true,
        set: function set() {},
        get: function get() {
          return addEventListenerWrapper;
        }
      };
      // https://github.com/AdguardTeam/Scriptlets/issues/215
      // https://github.com/AdguardTeam/Scriptlets/issues/143
      Object.defineProperty(window.EventTarget.prototype, 'addEventListener', descriptor);
      Object.defineProperty(window, 'addEventListener', descriptor);
      Object.defineProperty(document, 'addEventListener', descriptor);
    }
    logAddEventListener$1.names = ['log-addEventListener',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'addEventListener-logger.js', 'ubo-addEventListener-logger.js', 'aell.js', 'ubo-aell.js', 'ubo-addEventListener-logger', 'ubo-aell'];
    logAddEventListener$1.injections = [hit, validateType, validateListener, listenerToString, convertTypeToString, logMessage, objectToString, isEmptyObject, getObjectEntries];

    /* eslint-disable no-eval */

    /**
     * @scriptlet log-eval
     * @description
     * Logs all `eval()` or `new Function()` calls to the console.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('log-eval')
     * ```
     */
    function logEval$1(source) {
      // wrap eval function
      const nativeEval = window.eval;
      function evalWrapper(str) {
        hit(source);
        logMessage(source, "eval(\"".concat(str, "\")"), true);
        return nativeEval(str);
      }
      window.eval = evalWrapper;

      // wrap new Function
      const nativeFunction = window.Function;
      function FunctionWrapper() {
        hit(source);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        logMessage(source, "new Function(".concat(args.join(', '), ")"), true);
        return nativeFunction.apply(this, [...args]);
      }
      FunctionWrapper.prototype = Object.create(nativeFunction.prototype);
      FunctionWrapper.prototype.constructor = FunctionWrapper;
      window.Function = FunctionWrapper;
    }
    logEval$1.names = ['log-eval'];
    logEval$1.injections = [hit, logMessage];

    /**
     * @scriptlet log
     * @description
     * A simple scriptlet which only purpose is to print arguments to console.
     * This scriptlet can be helpful for debugging and troubleshooting other scriptlets.
     *
     * **Example**
     * ```
     * example.org#%#//scriptlet('log', 'arg1', 'arg2')
     * ```
     */
    function log$1() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      console.log(args); // eslint-disable-line no-console
    }

    log$1.names = ['log'];

    /* eslint-disable no-eval, no-extra-bind */

    /**
     * @scriptlet noeval
     * @description
     * Prevents page to use eval.
     * Notifies about attempts in the console
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#noevaljs-
     *
     * It also can be used as `$redirect` rules sometimes.
     * See [redirect description](../wiki/about-redirects.md#noeval).
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('noeval')
     * ```
     */
    function noeval$1(source) {
      window.eval = function evalWrapper(s) {
        hit(source);
        logMessage(source, "AdGuard has prevented eval:\n".concat(s), true);
      }.bind();
    }
    noeval$1.names = ['noeval',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'noeval.js', 'silent-noeval.js', 'ubo-noeval.js', 'ubo-silent-noeval.js', 'ubo-noeval', 'ubo-silent-noeval'];
    noeval$1.injections = [hit, logMessage];

    /* eslint-disable no-eval, no-extra-bind, func-names */

    /**
     * @scriptlet prevent-eval-if
     * @description
     * Prevents page to use eval matching payload.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#noeval-ifjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-eval-if'[, search])
     * ```
     *
     * - `search`  optional, string or regular expression matching the stringified eval payload;
     * defaults to match all stringified eval payloads;
     * invalid regular expression will cause exit and rule will not work
     *
     * **Examples**
     * ```
     * ! Prevents eval if it matches 'test'
     * example.org#%#//scriptlet('prevent-eval-if', 'test')
     * ```
     */
    function preventEvalIf$1(source, search) {
      const searchRegexp = toRegExp(search);
      const nativeEval = window.eval;
      window.eval = function (payload) {
        if (!searchRegexp.test(payload.toString())) {
          return nativeEval.call(window, payload);
        }
        hit(source);
        return undefined;
      }.bind(window);
    }
    preventEvalIf$1.names = ['prevent-eval-if',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'noeval-if.js', 'ubo-noeval-if.js', 'ubo-noeval-if'];
    preventEvalIf$1.injections = [toRegExp, hit];

    /* eslint-disable func-names, no-multi-assign */

    /**
     * @scriptlet prevent-fab-3.2.0
     * @description
     * Prevents execution of the FAB script v3.2.0.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#fuckadblockjs-320-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-fab-3.2.0')
     * ```
     */
    function preventFab$1(source) {
      hit(source);

      // redefines Fab function for adblock detection
      const Fab = function Fab() {};
      Fab.prototype.check = noopFunc;
      Fab.prototype.clearEvent = noopFunc;
      Fab.prototype.emitEvent = noopFunc;
      Fab.prototype.on = function (a, b) {
        if (!a) {
          b();
        }
        return this;
      };
      Fab.prototype.onDetected = noopThis;
      Fab.prototype.onNotDetected = function (a) {
        a();
        return this;
      };
      Fab.prototype.setOption = noopFunc;
      Fab.prototype.options = {
        set: noopFunc,
        get: noopFunc
      };
      const fab = new Fab();
      const getSetFab = {
        get() {
          return Fab;
        },
        set() {}
      };
      const getsetfab = {
        get() {
          return fab;
        },
        set() {}
      };

      // redefined Fab data properties which if 'FuckAdBlock' variable exists
      if (Object.prototype.hasOwnProperty.call(window, 'FuckAdBlock')) {
        window.FuckAdBlock = Fab;
      } else {
        // or redefined Fab accessor properties
        Object.defineProperty(window, 'FuckAdBlock', getSetFab);
      }
      if (Object.prototype.hasOwnProperty.call(window, 'BlockAdBlock')) {
        window.BlockAdBlock = Fab;
      } else {
        Object.defineProperty(window, 'BlockAdBlock', getSetFab);
      }
      if (Object.prototype.hasOwnProperty.call(window, 'SniffAdBlock')) {
        window.SniffAdBlock = Fab;
      } else {
        Object.defineProperty(window, 'SniffAdBlock', getSetFab);
      }
      if (Object.prototype.hasOwnProperty.call(window, 'fuckAdBlock')) {
        window.fuckAdBlock = fab;
      } else {
        Object.defineProperty(window, 'fuckAdBlock', getsetfab);
      }
      if (Object.prototype.hasOwnProperty.call(window, 'blockAdBlock')) {
        window.blockAdBlock = fab;
      } else {
        Object.defineProperty(window, 'blockAdBlock', getsetfab);
      }
      if (Object.prototype.hasOwnProperty.call(window, 'sniffAdBlock')) {
        window.sniffAdBlock = fab;
      } else {
        Object.defineProperty(window, 'sniffAdBlock', getsetfab);
      }
    }
    preventFab$1.names = ['prevent-fab-3.2.0',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'nofab.js', 'ubo-nofab.js', 'fuckadblock.js-3.2.0', 'ubo-fuckadblock.js-3.2.0', 'ubo-nofab'];
    preventFab$1.injections = [hit, noopFunc, noopThis];

    /* eslint-disable func-names, no-multi-assign */

    /**
     * @scriptlet set-popads-dummy
     * @description
     * Sets static properties PopAds and popns.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#popads-dummyjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('set-popads-dummy')
     * ```
     */
    function setPopadsDummy$1(source) {
      delete window.PopAds;
      delete window.popns;
      Object.defineProperties(window, {
        PopAds: {
          get: function get() {
            hit(source);
            return {};
          }
        },
        popns: {
          get: function get() {
            hit(source);
            return {};
          }
        }
      });
    }
    setPopadsDummy$1.names = ['set-popads-dummy',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'popads-dummy.js', 'ubo-popads-dummy.js', 'ubo-popads-dummy'];
    setPopadsDummy$1.injections = [hit];

    /**
     * @scriptlet prevent-popads-net
     * @description
     * Aborts on property write (PopAds, popns), throws reference error with random id.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#popadsnetjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-popads-net')
     * ```
     */
    function preventPopadsNet$1(source) {
      const rid = randomId();
      const throwError = function throwError() {
        throw new ReferenceError(rid);
      };
      delete window.PopAds;
      delete window.popns;
      Object.defineProperties(window, {
        PopAds: {
          set: throwError
        },
        popns: {
          set: throwError
        }
      });
      window.onerror = createOnErrorHandler(rid).bind();
      hit(source);
    }
    preventPopadsNet$1.names = ['prevent-popads-net',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'popads.net.js', 'ubo-popads.net.js', 'ubo-popads.net'];
    preventPopadsNet$1.injections = [createOnErrorHandler, randomId, hit];

    /* eslint-disable func-names */

    /**
     * @scriptlet prevent-adfly
     * @description
     * Prevents anti-adblock scripts on adfly short links.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#adfly-defuserjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-adfly')
     * ```
     */
    function preventAdfly$1(source) {
      const isDigit = function isDigit(data) {
        return /^\d$/.test(data);
      };
      const handler = function handler(encodedURL) {
        let evenChars = '';
        let oddChars = '';
        for (let i = 0; i < encodedURL.length; i += 1) {
          if (i % 2 === 0) {
            evenChars += encodedURL.charAt(i);
          } else {
            oddChars = encodedURL.charAt(i) + oddChars;
          }
        }
        let data = (evenChars + oddChars).split('');
        for (let i = 0; i < data.length; i += 1) {
          if (isDigit(data[i])) {
            for (let ii = i + 1; ii < data.length; ii += 1) {
              if (isDigit(data[ii])) {
                // eslint-disable-next-line no-bitwise
                const temp = parseInt(data[i], 10) ^ parseInt(data[ii], 10);
                if (temp < 10) {
                  data[i] = temp.toString();
                }
                i = ii;
                break;
              }
            }
          }
        }
        data = data.join('');
        const decodedURL = window.atob(data).slice(16, -16);
        if (window.stop) {
          window.stop();
        }
        window.onbeforeunload = null;
        window.location.href = decodedURL;
      };
      let val;
      // Do not apply handler more than one time
      let applyHandler = true;
      const result = setPropertyAccess(window, 'ysmm', {
        configurable: false,
        set: function set(value) {
          if (applyHandler) {
            applyHandler = false;
            try {
              if (typeof value === 'string') {
                handler(value);
              }
            } catch (err) {} // eslint-disable-line no-empty
          }

          val = value;
        },
        get: function get() {
          return val;
        }
      });
      if (result) {
        hit(source);
      } else {
        logMessage(source, 'Failed to set up prevent-adfly scriptlet');
      }
    }
    preventAdfly$1.names = ['prevent-adfly',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'adfly-defuser.js', 'ubo-adfly-defuser.js', 'ubo-adfly-defuser'];
    preventAdfly$1.injections = [setPropertyAccess, hit, logMessage];

    /* eslint-disable max-len */
    /**
     * @scriptlet debug-on-property-read
     * @description
     * This scriptlet is basically the same as [abort-on-property-read](#abort-on-property-read), but instead of aborting it starts the debugger.
     *
     * **It is not supposed to be used in production filter lists!**
     *
     * **Syntax**
     * ```
     * ! Debug script if it tries to access `window.alert`
     * example.org#%#//scriptlet('debug-on-property-read', 'alert')
     * ! of `window.open`
     * example.org#%#//scriptlet('debug-on-property-read', 'open')
     * ```
     */
    /* eslint-enable max-len */
    function debugOnPropertyRead$1(source, property) {
      if (!property) {
        return;
      }
      const rid = randomId();
      const abort = function abort() {
        hit(source);
        debugger; // eslint-disable-line no-debugger
      };

      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        setPropertyAccess(base, prop, {
          get: abort,
          set: noopFunc
        });
      };
      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    debugOnPropertyRead$1.names = ['debug-on-property-read'];
    debugOnPropertyRead$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, noopFunc, isEmptyObject];

    /* eslint-disable max-len */
    /**
     * @scriptlet debug-on-property-write
     * @description
     * This scriptlet is basically the same as [abort-on-property-write](#abort-on-property-write), but instead of aborting it starts the debugger.
     *
     * **It is not supposed to be used in production filter lists!**
     *
     * **Syntax**
     * ```
     * ! Aborts script when it tries to write in property `window.test`
     * example.org#%#//scriptlet('debug-on-property-write', 'test')
     * ```
     */
    /* eslint-enable max-len */
    function debugOnPropertyWrite$1(source, property) {
      if (!property) {
        return;
      }
      const rid = randomId();
      const abort = function abort() {
        hit(source);
        debugger; // eslint-disable-line no-debugger
      };

      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        setPropertyAccess(base, prop, {
          set: abort
        });
      };
      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    debugOnPropertyWrite$1.names = ['debug-on-property-write'];
    debugOnPropertyWrite$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, isEmptyObject];

    /* eslint-disable max-len */
    /**
     * @scriptlet debug-current-inline-script
     * @description
     * This scriptlet is basically the same as [abort-current-inline-script](#abort-current-inline-script), but instead of aborting it starts the debugger.
     *
     * **It is not supposed to be used in production filter lists!**
     *
     * **Syntax**
     *```
     * ! Aborts script when it tries to access `window.alert`
     * example.org#%#//scriptlet('debug-current-inline-script', 'alert')
     * ```
     */
    /* eslint-enable max-len */
    function debugCurrentInlineScript$1(source, property, search) {
      const searchRegexp = toRegExp(search);
      const rid = randomId();
      const getCurrentScript = function getCurrentScript() {
        if ('currentScript' in document) {
          return document.currentScript;
        }
        const scripts = document.getElementsByTagName('script');
        return scripts[scripts.length - 1];
      };
      const ourScript = getCurrentScript();
      const abort = function abort() {
        const scriptEl = getCurrentScript();
        if (!scriptEl) {
          return;
        }
        let content = scriptEl.textContent;

        // We are using Node.prototype.textContent property descriptor
        // to get the real script content
        // even when document.currentScript.textContent is replaced.
        // https://github.com/AdguardTeam/Scriptlets/issues/57#issuecomment-593638991
        try {
          const textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
          content = textContentGetter.call(scriptEl);
        } catch (e) {} // eslint-disable-line no-empty

        if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
          hit(source);
          debugger; // eslint-disable-line no-debugger
        }
      };

      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;

        // The scriptlet might be executed before the chain property has been created
        // (for instance, document.body before the HTML body was loaded).
        // In this case we're checking whether the base element exists or not
        // and if not, we simply exit without overriding anything.
        // e.g. https://github.com/AdguardTeam/Scriptlets/issues/57#issuecomment-575841092
        if (base instanceof Object === false && base === null) {
          const props = property.split('.');
          const propIndex = props.indexOf(prop);
          const baseName = props[propIndex - 1];
          const message = "The scriptlet had been executed before the ".concat(baseName, " was loaded.");
          logMessage(message, source.verbose);
          return;
        }
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        let currentValue = base[prop];
        setPropertyAccess(base, prop, {
          set: function set(value) {
            abort();
            currentValue = value;
          },
          get: function get() {
            abort();
            return currentValue;
          }
        });
      };
      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    debugCurrentInlineScript$1.names = ['debug-current-inline-script'];
    debugCurrentInlineScript$1.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, createOnErrorHandler, hit, logMessage, isEmptyObject];

    /* eslint-disable max-len */
    /**
     * @scriptlet remove-attr
     * @description
     * Removes the specified attributes from DOM nodes. This scriptlet runs once when the page loads
     * and after that periodically in order to DOM tree changes by default,
     * or as specified by applying argument.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-attrjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('remove-attr', attrs[, selector, applying])
     * ```
     *
     * - `attrs`  required, attribute or list of attributes joined by '|'
     * - `selector`  optional, CSS selector, specifies DOM nodes from which the attributes will be removed
     * - `applying`  optional, one or more space-separated flags that describe the way scriptlet apply, defaults to 'asap stay'; possible flags:
     *     - `asap`  runs as fast as possible **once**
     *     - `complete`  runs **once** after the whole page has been loaded
     *     - `stay`  as fast as possible **and** stays on the page observing possible DOM changes
     *
     * **Examples**
     * 1.  Removes by attribute
     *     ```
     *     example.org#%#//scriptlet('remove-attr', 'example|test')
     *     ```
     *
     *     ```html
     *     <!-- before -->
     *     <div example="true" test="true">Some text</div>
     *
     *     <!-- after -->
     *     <div>Some text</div>
     *     ```
     *
     * 2. Removes with specified selector
     *     ```
     *     example.org#%#//scriptlet('remove-attr', 'example', 'div[class="inner"]')
     *     ```
     *
     *     ```html
     *     <!-- before -->
     *     <div class="wrapper" example="true">
     *         <div class="inner" example="true">Some text</div>
     *     </div>
     *
     *     <!-- after -->
     *     <div class="wrapper" example="true">
     *         <div class="inner">Some text</div>
     *     </div>
     *     ```
     *
     *  3. Using flags
     *     ```
     *     example.org#%#//scriptlet('remove-attr', 'example', 'html', 'asap complete')
     *     ```
     */
    /* eslint-enable max-len */
    function removeAttr$1(source, attrs, selector) {
      let applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'asap stay';
      if (!attrs) {
        return;
      }
      attrs = attrs.split(/\s*\|\s*/);
      if (!selector) {
        selector = "[".concat(attrs.join('],['), "]");
      }
      const rmattr = function rmattr() {
        let nodes = [];
        try {
          nodes = [].slice.call(document.querySelectorAll(selector));
        } catch (e) {
          logMessage(source, "Invalid selector arg: '".concat(selector, "'"));
        }
        let removed = false;
        nodes.forEach(function (node) {
          attrs.forEach(function (attr) {
            node.removeAttribute(attr);
            removed = true;
          });
        });
        if (removed) {
          hit(source);
        }
      };
      const flags = parseFlags(applying);
      const run = function run() {
        rmattr();
        if (!flags.hasFlag(flags.STAY)) {
          return;
        }
        // 'true' for observing attributes
        observeDOMChanges(rmattr, true);
      };
      if (flags.hasFlag(flags.ASAP)) {
        // https://github.com/AdguardTeam/Scriptlets/issues/245
        // Call rmattr on DOM content loaded
        // to ensure that target node is present on the page
        if (document.readyState === 'loading') {
          window.addEventListener('DOMContentLoaded', rmattr, {
            once: true
          });
        } else {
          rmattr();
        }
      }
      if (document.readyState !== 'complete' && flags.hasFlag(flags.COMPLETE)) {
        window.addEventListener('load', run, {
          once: true
        });
      } else if (flags.hasFlag(flags.STAY)) {
        // Only call rmattr for single 'stay' flag
        if (!applying.indexOf(' ') !== -1) {
          rmattr();
        }
        // 'true' for observing attributes
        observeDOMChanges(rmattr, true);
      }
    }
    removeAttr$1.names = ['remove-attr',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'remove-attr.js', 'ubo-remove-attr.js', 'ra.js', 'ubo-ra.js', 'ubo-remove-attr', 'ubo-ra'];
    removeAttr$1.injections = [hit, observeDOMChanges, parseFlags, logMessage,
    // following helpers should be imported and injected
    // because they are used by helpers above
    throttle];

    /* eslint-disable max-len */
    /**
     * @scriptlet set-attr
     * @description
     * Sets the specified attribute on the specified elements. This scriptlet runs once when the page loads
     * and after that and after that on DOM tree changes.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('set-attr', selector, attr[, value])
     * ```
     *
     * - `selector`  required, CSS selector, specifies DOM nodes to set attributes on
     * - `attr`  required, attribute to be set
     * - `value`  the value to assign to the attribute, defaults to ''. Possible values:
     *     - `''`  empty string
     *     - positive decimal integer `<= 32767`
     *     - `true` / `false` in any case variation
     *
     * **Examples**
     * 1.  Set attribute by selector
     *     ```
     *     example.org#%#//scriptlet('set-attr', 'div.class > a.class', 'test-attribute', '0')
     *     ```
     *
     *     ```html
     *     <!-- before -->
     *     <a class="class">Some text</div>
     *
     *     <!-- after -->
     *     <a class="class" test-attribute="0">Some text</div>
     *     ```
     * 2.  Set attribute without value
     *     ```
     *     example.org#%#//scriptlet('set-attr', 'div.class > a.class', 'test-attribute')
     *     ```
     *
     *     ```html
     *     <!-- before -->
     *     <a class="class">Some text</div>
     *
     *     <!-- after -->
     *     <a class="class" test-attribute>Some text</div>
     *     ```
     * 3.  Set attribute value to `TRUE`
     *     ```
     *     example.org#%#//scriptlet('set-attr', 'div.class > a.class', 'test-attribute', 'TRUE')
     *     ```
     *
     *     ```html
     *     <!-- before -->
     *     <a class="class">Some text</div>
     *
     *     <!-- after -->
     *     <a class="class" test-attribute="TRUE">Some text</div>
     *     ```
     * 4.  Set attribute value to `fAlse`
     *     ```
     *     example.org#%#//scriptlet('set-attr', 'div.class > a.class', 'test-attribute', 'fAlse')
     *     ```
     *
     *     ```html
     *     <!-- before -->
     *     <a class="class">Some text</div>
     *
     *     <!-- after -->
     *     <a class="class" test-attribute="fAlse">Some text</div>
     *     ```
     */
    /* eslint-enable max-len */
    function setAttr$1(source, selector, attr) {
      let value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      if (!selector || !attr) {
        return;
      }
      const allowedValues = ['true', 'false'];

      // Drop strings that cant be parsed into number, negative numbers and numbers below 32767
      if (value.length !== 0 && (nativeIsNaN(parseInt(value, 10)) || parseInt(value, 10) < 0 || parseInt(value, 10) > 32767) && !allowedValues.includes(value.toLowerCase())) {
        return;
      }
      const setAttr = function setAttr() {
        const nodes = [].slice.call(document.querySelectorAll(selector));
        let set = false;
        nodes.forEach(function (node) {
          node.setAttribute(attr, value);
          set = true;
        });
        if (set) {
          hit(source);
        }
      };
      setAttr();
      observeDOMChanges(setAttr, true);
    }
    setAttr$1.names = ['set-attr'];
    setAttr$1.injections = [hit, observeDOMChanges, nativeIsNaN,
    // following helpers should be imported and injected
    // because they are used by helpers above
    throttle];

    /* eslint-disable max-len */
    /**
     * @scriptlet remove-class
     * @description
     * Removes the specified classes from DOM nodes. This scriptlet runs once after the page loads
     * and after that periodically in order to DOM tree changes.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-classjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('remove-class', classes[, selector, applying])
     * ```
     *
     * - `classes`  required, class or list of classes separated by '|'
     * - `selector`  optional, CSS selector, specifies DOM nodes from which the classes will be removed.
     * If there is no `selector`, each class of `classes` independently will be removed from all nodes which has one
     * - `applying`  optional, one or more space-separated flags that describe the way scriptlet apply, defaults to 'asap stay'; possible flags:
     *     - `asap`  runs as fast as possible **once**
     *     - `complete`  runs **once** after the whole page has been loaded
     *     - `stay`  as fast as possible **and** stays on the page observing possible DOM changes
     *
     * **Examples**
     * 1.  Removes by classes
     *     ```
     *     example.org#%#//scriptlet('remove-class', 'example|test')
     *     ```
     *
     *     ```html
     *     <!-- before -->
     *     <div id="first" class="nice test">Some text</div>
     *     <div id="second" class="rare example for test">Some text</div>
     *     <div id="third" class="testing better example">Some text</div>
     *
     *     <!-- after -->
     *     <div id="first" class="nice">Some text</div>
     *     <div id="second" class="rare for">Some text</div>
     *     <div id="third" class="testing better">Some text</div>
     *     ```
     *
     * 2. Removes with specified selector
     *     ```
     *     example.org#%#//scriptlet('remove-class', 'branding', 'div[class^="inner"]')
     *     ```
     *
     *     ```html
     *     <!-- before -->
     *     <div class="wrapper true branding">
     *         <div class="inner bad branding">Some text</div>
     *     </div>
     *
     *     <!-- after -->
     *     <div class="wrapper true branding">
     *         <div class="inner bad">Some text</div>
     *     </div>
     *     ```
     *
     *  3. Using flags
     *     ```
     *     example.org#%#//scriptlet('remove-class', 'branding', 'div[class^="inner"]', 'asap complete')
     *     ```
     */
    /* eslint-enable max-len */

    function removeClass$1(source, classNames, selector) {
      let applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'asap stay';
      if (!classNames) {
        return;
      }
      classNames = classNames.split(/\s*\|\s*/);
      let selectors = [];
      if (!selector) {
        selectors = classNames.map(function (className) {
          return ".".concat(className);
        });
      }
      const removeClassHandler = function removeClassHandler() {
        const nodes = new Set();
        if (selector) {
          let foundNodes = [];
          try {
            foundNodes = [].slice.call(document.querySelectorAll(selector));
          } catch (e) {
            logMessage(source, "Invalid selector arg: '".concat(selector, "'"));
          }
          foundNodes.forEach(function (n) {
            return nodes.add(n);
          });
        } else if (selectors.length > 0) {
          selectors.forEach(function (s) {
            const elements = document.querySelectorAll(s);
            for (let i = 0; i < elements.length; i += 1) {
              const element = elements[i];
              nodes.add(element);
            }
          });
        }
        let removed = false;
        nodes.forEach(function (node) {
          classNames.forEach(function (className) {
            if (node.classList.contains(className)) {
              node.classList.remove(className);
              removed = true;
            }
          });
        });
        if (removed) {
          hit(source);
        }
      };
      const CLASS_ATTR_NAME = ['class'];
      const flags = parseFlags(applying);
      const run = function run() {
        removeClassHandler();
        if (!flags.hasFlag(flags.STAY)) {
          return;
        }
        // 'true' for observing attributes
        // 'class' for observing only classes
        observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
      };
      if (flags.hasFlag(flags.ASAP)) {
        // https://github.com/AdguardTeam/Scriptlets/issues/245
        // Call removeClassHandler on DOM content loaded
        // to ensure that target node is present on the page
        if (document.readyState === 'loading') {
          window.addEventListener('DOMContentLoaded', removeClassHandler, {
            once: true
          });
        } else {
          removeClassHandler();
        }
      }
      if (document.readyState !== 'complete' && flags.hasFlag(flags.COMPLETE)) {
        window.addEventListener('load', run, {
          once: true
        });
      } else if (flags.hasFlag(flags.STAY)) {
        // Only call removeClassHandler for single 'stay' flag
        if (!applying.indexOf(' ') !== -1) {
          removeClassHandler();
        }
        observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
      }
    }
    removeClass$1.names = ['remove-class',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'remove-class.js', 'ubo-remove-class.js', 'rc.js', 'ubo-rc.js', 'ubo-remove-class', 'ubo-rc'];
    removeClass$1.injections = [hit, logMessage, observeDOMChanges, parseFlags,
    // following helpers should be imported and injected
    // because they are used by helpers above
    throttle];

    /**
     * @scriptlet disable-newtab-links
     * @description
     * Prevents opening new tabs and windows if there is `target` attribute in element.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#disable-newtab-linksjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('disable-newtab-links')
     * ```
     */
    function disableNewtabLinks$1(source) {
      document.addEventListener('click', function (ev) {
        let target = ev.target;
        while (target !== null) {
          if (target.localName === 'a' && target.hasAttribute('target')) {
            ev.stopPropagation();
            ev.preventDefault();
            hit(source);
            break;
          }
          target = target.parentNode;
        }
      });
    }
    disableNewtabLinks$1.names = ['disable-newtab-links',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'disable-newtab-links.js', 'ubo-disable-newtab-links.js', 'ubo-disable-newtab-links'];
    disableNewtabLinks$1.injections = [hit];

    /* eslint-disable max-len */
    /**
     * @scriptlet adjust-setInterval
     * @description
     * Adjusts delay for specified setInterval() callbacks.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#nano-setinterval-boosterjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('adjust-setInterval'[, matchCallback [, matchDelay[, boost]]])
     * ```
     *
     * - `matchCallback`  optional, string or regular expression for stringified callback matching;
     * defaults to match all callbacks; invalid regular expression will cause exit and rule will not work
     * - `matchDelay`  optional, defaults to 1000, matching setInterval delay; decimal integer OR '*' for any delay
     * - `boost`  optional, default to 0.05, float, capped at 1000 times for up and 50 for down (0.001...50), setInterval delay multiplier
     *
     * **Examples**
     * 1. Adjust all setInterval() x20 times where delay equal 1000ms:
     *     ```
     *     example.org#%#//scriptlet('adjust-setInterval')
     *     ```
     *
     * 2. Adjust all setInterval() x20 times where callback matched with `example` and delay equal 1000ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setInterval', 'example')
     *     ```
     *
     * 3. Adjust all setInterval() x20 times where callback matched with `example` and delay equal 400ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setInterval', 'example', '400')
     *     ```
     *
     * 4. Slow down setInterval() x2 times where callback matched with `example` and delay equal 1000ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setInterval', 'example', '', '2')
     *     ```
     * 5. Adjust all setInterval() x50 times where delay equal 2000ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setInterval', '', '2000', '0.02')
     *     ```
     * 6. Adjust all setInterval() x1000 times where delay equal 2000ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setInterval', '', '2000', '0.001')
     *     ```
     * 7. Adjust all setInterval() x50 times where delay is randomized
     *     ```
     *     example.org#%#//scriptlet('adjust-setInterval', '', '*', '0.02')
     *     ```
     */
    /* eslint-enable max-len */
    function adjustSetInterval$1(source, matchCallback, matchDelay, boost) {
      const nativeSetInterval = window.setInterval;
      const matchRegexp = toRegExp(matchCallback);
      const intervalWrapper = function intervalWrapper(callback, delay) {
        // https://github.com/AdguardTeam/Scriptlets/issues/221
        if (!isValidCallback(callback)) {
          // eslint-disable-next-line max-len
          const message = "Scriptlet can't be applied because of invalid callback: '".concat(String(callback), "'");
          logMessage(source, message);
        } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
          delay *= getBoostMultiplier(boost);
          hit(source);
        }
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return nativeSetInterval.apply(window, [callback, delay, ...args]);
      };
      window.setInterval = intervalWrapper;
    }
    adjustSetInterval$1.names = ['adjust-setInterval',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'nano-setInterval-booster.js', 'ubo-nano-setInterval-booster.js', 'nano-sib.js', 'ubo-nano-sib.js', 'ubo-nano-setInterval-booster', 'ubo-nano-sib'];
    adjustSetInterval$1.injections = [hit, isValidCallback, toRegExp, getBoostMultiplier, isDelayMatched, logMessage,
    // following helpers should be injected as helpers above use them
    nativeIsNaN, nativeIsFinite, getMatchDelay, shouldMatchAnyDelay];

    /* eslint-disable max-len */
    /**
     * @scriptlet adjust-setTimeout
     * @description
     * Adjusts delay for specified setTimeout() callbacks.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#nano-settimeout-boosterjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('adjust-setTimeout'[, matchCallback [, matchDelay[, boost]]])
     * ```
     *
     * - `matchCallback`  optional, string or regular expression for stringified callback matching;
     * defaults to match all callbacks; invalid regular expression will cause exit and rule will not work
     * - `matchDelay`  optional, defaults to 1000, matching setTimeout delay; decimal integer OR '*' for any delay
     * - `boost`  optional, default to 0.05, float, capped at 1000 times for up and 50 for down (0.001...50), setTimeout delay multiplier
     *
     * **Examples**
     * 1. Adjust all setTimeout() x20 times where timeout equal 1000ms:
     *     ```
     *     example.org#%#//scriptlet('adjust-setTimeout')
     *     ```
     *
     * 2. Adjust all setTimeout() x20 times where callback matched with `example` and timeout equal 1000ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setTimeout', 'example')
     *     ```
     *
     * 3. Adjust all setTimeout() x20 times where callback matched with `example` and timeout equal 400ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setTimeout', 'example', '400')
     *     ```
     *
     * 4. Slow down setTimeout() x2 times where callback matched with `example` and timeout equal 1000ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setTimeout', 'example', '', '2')
     *     ```
     * 5. Adjust all setTimeout() x50 times where timeout equal 2000ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setTimeout', '', '2000', '0.02')
     *     ```
     * 6. Adjust all setTimeout() x1000 times where timeout equal 2000ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setTimeout', '', '2000', '0.001')
     *     ```
     * 7. Adjust all setTimeout() x20 times where callback matched with `test` and timeout is randomized
     *     ```
     *     example.org#%#//scriptlet('adjust-setTimeout', 'test', '*')
     *     ```
     */
    /* eslint-enable max-len */
    function adjustSetTimeout$1(source, matchCallback, matchDelay, boost) {
      const nativeSetTimeout = window.setTimeout;
      const matchRegexp = toRegExp(matchCallback);
      const timeoutWrapper = function timeoutWrapper(callback, delay) {
        // https://github.com/AdguardTeam/Scriptlets/issues/221
        if (!isValidCallback(callback)) {
          // eslint-disable-next-line max-len
          const message = "Scriptlet can't be applied because of invalid callback: '".concat(String(callback), "'");
          logMessage(source, message);
        } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
          delay *= getBoostMultiplier(boost);
          hit(source);
        }
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return nativeSetTimeout.apply(window, [callback, delay, ...args]);
      };
      window.setTimeout = timeoutWrapper;
    }
    adjustSetTimeout$1.names = ['adjust-setTimeout',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'nano-setTimeout-booster.js', 'ubo-nano-setTimeout-booster.js', 'nano-stb.js', 'ubo-nano-stb.js', 'ubo-nano-setTimeout-booster', 'ubo-nano-stb'];
    adjustSetTimeout$1.injections = [hit, isValidCallback, toRegExp, getBoostMultiplier, isDelayMatched, logMessage,
    // following helpers should be injected as helpers above use them
    nativeIsNaN, nativeIsFinite, getMatchDelay, shouldMatchAnyDelay];

    /* eslint-disable max-len */
    /**
     * @scriptlet dir-string
     * @description
     * Wraps the `console.dir` API to call the `toString` method of the argument.
     * There are several adblock circumvention systems that detect browser devtools
     * and hide themselves. Therefore, if we force them to think
     * that devtools are open (using this scriptlet),
     * it will automatically disable the adblock circumvention script.
     *
     * Related ABP source:
     * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L766
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('dir-string'[, times])
     * ```
     * - `times`  optional, the number of times to call the `toString` method of the argument to `console.dir`
     *
     * **Example**
     * ```
     * ! Run 2 times
     * example.org#%#//scriptlet('dir-string', '2')
     * ```
     */
    /* eslint-enable max-len */
    function dirString$1(source, times) {
      const _console = console,
        dir = _console.dir;
      function dirWrapper(object) {
        if (typeof dir === 'function') {
          dir.call(this, object);
        }
        hit(source);
      }
      // eslint-disable-next-line no-console
      console.dir = dirWrapper;
    }
    dirString$1.names = ['dir-string', 'abp-dir-string'];
    dirString$1.injections = [hit];

    /* eslint-disable max-len */
    /**
     * @scriptlet json-prune
     * @description
     * Removes specified properties from the result of calling JSON.parse and returns the caller
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#json-prunejs-
     *
     * Related ABP source:
     * https://github.com/adblockplus/adblockpluscore/blob/master/lib/content/snippets.js#L1285
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('json-prune'[, propsToRemove [, obligatoryProps [, stack]]])
     * ```
     *
     * - `propsToRemove`  optional, string of space-separated properties to remove
     * - `obligatoryProps`  optional, string of space-separated properties which must be all present for the pruning to occur
     * - `stack`  optional, string or regular expression that must match the current function call stack trace;
     * if regular expression is invalid it will be skipped
     *
     * > Note please that you can use wildcard `*` for chain property name.
     * e.g. 'ad.*.src' instead of 'ad.0.src ad.1.src ad.2.src ...'
     *
     * **Examples**
     * 1. Removes property `example` from the results of JSON.parse call
     *     ```
     *     example.org#%#//scriptlet('json-prune', 'example')
     *     ```
     *
     *     For instance, the following call will return `{ one: 1}`
     *
     *     ```html
     *     JSON.parse('{"one":1,"example":true}')
     *     ```
     *
     * 2. If there are no specified properties in the result of JSON.parse call, pruning will NOT occur
     *     ```
     *     example.org#%#//scriptlet('json-prune', 'one', 'obligatoryProp')
     *     ```
     *
     *     For instance, the following call will return `{ one: 1, two: 2}`
     *
     *     ```html
     *     JSON.parse('{"one":1,"two":2}')
     *     ```
     *
     * 3. A property in a list of properties can be a chain of properties
     *
     *     ```
     *     example.org#%#//scriptlet('json-prune', 'a.b', 'adpath.url.first')
     *     ```
     *
     * 4. Removes property `content.ad` from the results of JSON.parse call if its error stack trace contains `test.js`
     *     ```
     *     example.org#%#//scriptlet('json-prune', 'content.ad', '', 'test.js')
     *     ```
     *
     * 5. A property in a list of properties can be a chain of properties with wildcard in it
     *
     *     ```
     *     example.org#%#//scriptlet('json-prune', 'content.*.media.src', 'content.*.media.preroll')
     *     ```
     *
     * 6. Call with no arguments will log the current hostname and json payload at the console
     *     ```
     *     example.org#%#//scriptlet('json-prune')
     *     ```
     *
     * 7. Call with only second argument will log the current hostname and matched json payload at the console
     *     ```
     *     example.org#%#//scriptlet('json-prune', '', '"id":"117458"')
     *     ```
     */
    /* eslint-enable max-len */
    function jsonPrune$1(source, propsToRemove, requiredInitialProps, stack) {
      if (!!stack && !matchStackTrace(stack, new Error().stack)) {
        return;
      }
      const prunePaths = propsToRemove !== undefined && propsToRemove !== '' ? propsToRemove.split(/ +/) : [];
      const requiredPaths = requiredInitialProps !== undefined && requiredInitialProps !== '' ? requiredInitialProps.split(/ +/) : [];
      function isPruningNeeded(root) {
        if (!root) {
          return false;
        }
        let shouldProcess;

        // Only log hostname and matched JSON payload if only second argument is present
        if (prunePaths.length === 0 && requiredPaths.length > 0) {
          const rootString = JSON.stringify(root);
          const matchRegex = toRegExp(requiredPaths.join(''));
          const shouldLog = matchRegex.test(rootString);
          if (shouldLog) {
            logMessage(source, "".concat(window.location.hostname, "\n").concat(JSON.stringify(root, null, 2)), true);
            if (root && typeof root === 'object') {
              logMessage(source, root, true, false);
            }
            shouldProcess = false;
            return shouldProcess;
          }
        }
        for (let i = 0; i < requiredPaths.length; i += 1) {
          const requiredPath = requiredPaths[i];
          const lastNestedPropName = requiredPath.split('.').pop();
          const hasWildcard = requiredPath.indexOf('.*.') > -1 || requiredPath.indexOf('*.') > -1 || requiredPath.indexOf('.*') > -1 || requiredPath.indexOf('.[].') > -1 || requiredPath.indexOf('[].') > -1 || requiredPath.indexOf('.[]') > -1;

          // if the path has wildcard, getPropertyInChain should 'look through' chain props
          const details = getWildcardPropertyInChain(root, requiredPath, hasWildcard);

          // start value of 'shouldProcess' due to checking below
          shouldProcess = !hasWildcard;
          for (let i = 0; i < details.length; i += 1) {
            if (hasWildcard) {
              // if there is a wildcard,
              // at least one (||) of props chain should be present in object
              shouldProcess = !(details[i].base[lastNestedPropName] === undefined) || shouldProcess;
            } else {
              // otherwise each one (&&) of them should be there
              shouldProcess = !(details[i].base[lastNestedPropName] === undefined) && shouldProcess;
            }
          }
        }
        return shouldProcess;
      }

      /**
       * Prunes properties of 'root' object
       *
       * @param {Object} root
       * @returns {Object} pruned root
       */
      const jsonPruner = function jsonPruner(root) {
        if (prunePaths.length === 0 && requiredPaths.length === 0) {
          logMessage(source, "".concat(window.location.hostname, "\n").concat(JSON.stringify(root, null, 2)), true);
          if (root && typeof root === 'object') {
            logMessage(source, root, true, false);
          }
          return root;
        }
        try {
          if (isPruningNeeded(root) === false) {
            return root;
          }

          // if pruning is needed, we check every input pathToRemove
          // and delete it if root has it
          prunePaths.forEach(function (path) {
            const ownerObjArr = getWildcardPropertyInChain(root, path, true);
            ownerObjArr.forEach(function (ownerObj) {
              if (ownerObj !== undefined && ownerObj.base) {
                delete ownerObj.base[ownerObj.prop];
                hit(source);
              }
            });
          });
        } catch (e) {
          logMessage(source, e);
        }
        return root;
      };
      const nativeJSONParse = JSON.parse;
      const jsonParseWrapper = function jsonParseWrapper() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        // dealing with stringified json in args, which should be parsed.
        // so we call nativeJSONParse as JSON.parse which is bound to JSON object
        const root = nativeJSONParse.apply(JSON, args);
        return jsonPruner(root);
      };

      // JSON.parse mocking
      jsonParseWrapper.toString = nativeJSONParse.toString.bind(nativeJSONParse);
      JSON.parse = jsonParseWrapper;
      const nativeResponseJson = Response.prototype.json;
      // eslint-disable-next-line func-names
      const responseJsonWrapper = function responseJsonWrapper() {
        const promise = nativeResponseJson.apply(this);
        return promise.then(function (obj) {
          return jsonPruner(obj);
        });
      };

      // do nothing if browser does not support Response (e.g. Internet Explorer)
      // https://developer.mozilla.org/en-US/docs/Web/API/Response
      if (typeof Response === 'undefined') {
        return;
      }
      Response.prototype.json = responseJsonWrapper;
    }
    jsonPrune$1.names = ['json-prune',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'json-prune.js', 'ubo-json-prune.js', 'ubo-json-prune', 'abp-json-prune'];
    jsonPrune$1.injections = [hit, matchStackTrace, getWildcardPropertyInChain, logMessage,
    // following helpers are needed for helpers above
    toRegExp, getNativeRegexpTest, shouldAbortInlineOrInjectedScript];

    /* eslint-disable max-len */
    /**
     * @scriptlet prevent-requestAnimationFrame
     * @description
     * Prevents a `requestAnimationFrame` call
     * if the text of the callback is matching the specified search string which does not start with `!`;
     * otherwise mismatched calls should be defused.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-requestanimationframe-ifjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-requestAnimationFrame'[, search])
     * ```
     *
     * - `search`  optional, string or regular expression; invalid regular expression will be skipped and all callbacks will be matched.
     * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.
     * If do not start with `!`, the stringified callback will be matched.
     *
     * Call with no argument will log all requestAnimationFrame calls while debugging.
     * So do not use the scriptlet without any parameter in production filter lists.
     *
     * **Examples**
     * 1. Prevents `requestAnimationFrame` calls if the callback matches `/\.test/`.
     *     ```bash
     *     example.org#%#//scriptlet('prevent-requestAnimationFrame', '/\.test/')
     *     ```
     *
     *     For instance, the following call will be prevented:
     *     ```javascript
     *     var times = 0;
     *     requestAnimationFrame(function change() {
     *         window.test = 'new value';
     *         if (times < 2) {
     *             times += 1;
     *             requestAnimationFrame(change);
     *         }
     *     });
     *     ```
     * 2. Prevents `requestAnimationFrame` calls if **does not match** 'check'.
     *     ```bash
     *     example.org#%#//scriptlet('prevent-requestAnimationFrame', '!check')
     *     ```
     *
     *     For instance, only the first call will be prevented:
     *
     *     ```javascript
     *     var timesFirst = 0;
     *     requestAnimationFrame(function changeFirst() {
     *         window.check = 'should not be prevented';
     *         if (timesFirst < 2) {
     *             timesFirst += 1;
     *             requestAnimationFrame(changeFirst);
     *         }
     *     });
     *
     *     var timesSecond = 0;
     *     requestAnimationFrame(function changeSecond() {
     *         window.second = 'should be prevented';
     *         if (timesSecond < 2) {
     *             timesSecond += 1;
     *             requestAnimationFrame(changeSecond);
     *         }
     *     });
     *     ```
     */
    /* eslint-enable max-len */

    function preventRequestAnimationFrame$1(source, match) {
      const nativeRequestAnimationFrame = window.requestAnimationFrame;

      // logs requestAnimationFrame to console if no arguments have been specified
      const shouldLog = typeof match === 'undefined';
      const _parseMatchArg = parseMatchArg(match),
        isInvertedMatch = _parseMatchArg.isInvertedMatch,
        matchRegexp = _parseMatchArg.matchRegexp;
      const rafWrapper = function rafWrapper(callback) {
        let shouldPrevent = false;
        if (shouldLog) {
          hit(source);
          logMessage(source, "requestAnimationFrame(".concat(String(callback), ")"), true);
        } else if (isValidCallback(callback) && isValidStrPattern(match)) {
          shouldPrevent = matchRegexp.test(callback.toString()) !== isInvertedMatch;
        }
        if (shouldPrevent) {
          hit(source);
          return nativeRequestAnimationFrame(noopFunc);
        }
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return nativeRequestAnimationFrame.apply(window, [callback, ...args]);
      };
      window.requestAnimationFrame = rafWrapper;
    }
    preventRequestAnimationFrame$1.names = ['prevent-requestAnimationFrame',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'no-requestAnimationFrame-if.js', 'ubo-no-requestAnimationFrame-if.js', 'norafif.js', 'ubo-norafif.js', 'ubo-no-requestAnimationFrame-if', 'ubo-norafif'];
    preventRequestAnimationFrame$1.injections = [hit, noopFunc, parseMatchArg, isValidStrPattern, isValidCallback, logMessage,
    // following helpers should be injected as helpers above use them
    escapeRegExp, toRegExp, startsWith$1];

    /* eslint-disable max-len */
    /**
     * @scriptlet set-cookie
     * @description
     * Sets a cookie with the specified name, value, and path.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('set-cookie', name, value[, path])
     * ```
     *
     * - `name`  required, cookie name to be set
     * - `value`  required, cookie value; possible values:
     *     - number `>= 0 && <= 15`
     *     - one of the predefined constants:
     *         - `true` / `True`
     *         - `false` / `False`
     *         - `yes` / `Yes` / `Y`
     *         - `no`
     *         - `ok` / `OK`
     * - `path`  optional, cookie path, defaults to `/`; possible values:
     *     - `/`  root path
     *     - `none`  to set no path at all
     *
     * **Examples**
     * ```
     * example.org#%#//scriptlet('set-cookie', 'CookieConsent', '1')
     *
     * example.org#%#//scriptlet('set-cookie', 'gdpr-settings-cookie', 'true')
     *
     * example.org#%#//scriptlet('set-cookie', 'cookie_consent', 'ok', 'none')
     * ```
     */
    /* eslint-enable max-len */
    function setCookie$1(source, name, value) {
      let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';
      const validValue = getLimitedCookieValue(value);
      if (validValue === null) {
        logMessage(source, "Invalid cookie value: '".concat(validValue, "'"));
        return;
      }
      if (!isValidCookiePath(path)) {
        logMessage(source, "Invalid cookie path: '".concat(path, "'"));
        return;
      }
      const cookieToSet = concatCookieNameValuePath(name, validValue, path);
      if (!cookieToSet) {
        return;
      }
      hit(source);
      document.cookie = cookieToSet;
    }
    setCookie$1.names = ['set-cookie'];
    setCookie$1.injections = [hit, logMessage, nativeIsNaN, isCookieSetWithValue, getLimitedCookieValue, concatCookieNameValuePath, isValidCookiePath, getCookiePath];

    /**
     * @scriptlet set-cookie-reload
     * @description
     * Sets a cookie with the specified name and value, and path,
     * and reloads the current page after the cookie setting.
     * If reloading option is not needed, use [set-cookie](#set-cookie) scriptlet.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('set-cookie-reload', name, value[, path])
     * ```
     *
     * - `name`  required, cookie name to be set
     * - `value`  required, cookie value; possible values:
     *     - number `>= 0 && <= 15`
     *     - one of the predefined constants:
     *         - `true` / `True`
     *         - `false` / `False`
     *         - `yes` / `Yes` / `Y`
     *         - `no`
     *         - `ok` / `OK`
     * - `path`  optional, cookie path, defaults to `/`; possible values:
     *     - `/`  root path
     *     - `none`  to set no path at all
     *
     * **Examples**
     * ```
     * example.org#%#//scriptlet('set-cookie-reload', 'checking', 'ok')
     *
     * example.org#%#//scriptlet('set-cookie-reload', 'gdpr-settings-cookie', '1')
     *
     * example.org#%#//scriptlet('set-cookie-reload', 'cookie-set', 'true', 'none')
     * ```
     */
    function setCookieReload$1(source, name, value) {
      let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';
      if (isCookieSetWithValue(document.cookie, name, value)) {
        return;
      }
      const validValue = getLimitedCookieValue(value);
      if (validValue === null) {
        logMessage(source, "Invalid cookie value: '".concat(value, "'"));
        return;
      }
      if (!isValidCookiePath(path)) {
        logMessage(source, "Invalid cookie path: '".concat(path, "'"));
        return;
      }
      const cookieToSet = concatCookieNameValuePath(name, validValue, path);
      if (!cookieToSet) {
        return;
      }
      document.cookie = cookieToSet;
      hit(source);

      // Only reload the page if cookie was set
      // https://github.com/AdguardTeam/Scriptlets/issues/212
      if (isCookieSetWithValue(document.cookie, name, value)) {
        window.location.reload();
      }
    }
    setCookieReload$1.names = ['set-cookie-reload'];
    setCookieReload$1.injections = [hit, logMessage, nativeIsNaN, isCookieSetWithValue, getLimitedCookieValue, concatCookieNameValuePath, isValidCookiePath, getCookiePath];

    /**
     * @scriptlet hide-in-shadow-dom
     * @description
     * Hides elements inside open shadow DOM elements.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('hide-in-shadow-dom', selector[, baseSelector])
     * ```
     *
     * - `selector`  required, CSS selector of element in shadow-dom to hide
     * - `baseSelector`  optional, selector of specific page DOM element,
     * narrows down the part of the page DOM where shadow-dom host supposed to be,
     * defaults to document.documentElement
     *
     * > `baseSelector` should match element of the page DOM, but not of shadow DOM
     *
     * **Examples**
     * ```
     * ! hides menu bar
     * virustotal.com#%#//scriptlet('hide-in-shadow-dom', 'iron-pages', 'vt-virustotal-app')
     *
     * ! hides floating element
     * virustotal.com#%#//scriptlet('hide-in-shadow-dom', 'vt-ui-contact-fab')
     * ```
     */
    function hideInShadowDom$1(source, selector, baseSelector) {
      // do nothing if browser does not support ShadowRoot
      // https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot
      if (!Element.prototype.attachShadow) {
        return;
      }
      const hideElement = function hideElement(targetElement) {
        const DISPLAY_NONE_CSS = 'display:none!important;';
        targetElement.style.cssText = DISPLAY_NONE_CSS;
      };

      /**
       * Handles shadow-dom piercing and hiding of found elements
       */
      const hideHandler = function hideHandler() {
        // start value of shadow-dom hosts for the page dom
        let hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);

        // if there is shadow-dom host, they should be explored
        while (hostElements.length !== 0) {
          let isHidden = false;
          const _pierceShadowDom = pierceShadowDom(selector, hostElements),
            targets = _pierceShadowDom.targets,
            innerHosts = _pierceShadowDom.innerHosts;
          targets.forEach(function (targetEl) {
            hideElement(targetEl);
            isHidden = true;
          });
          if (isHidden) {
            hit(source);
          }

          // continue to pierce for inner shadow-dom hosts
          // and search inside them while the next iteration
          hostElements = innerHosts;
        }
      };
      hideHandler();
      observeDOMChanges(hideHandler, true);
    }
    hideInShadowDom$1.names = ['hide-in-shadow-dom'];
    hideInShadowDom$1.injections = [hit, observeDOMChanges, findHostElements, pierceShadowDom,
    // following helpers should be imported and injected
    // because they are used by helpers above
    flatten, throttle];

    /**
     * @scriptlet remove-in-shadow-dom
     * @description
     * Removes elements inside open shadow DOM elements.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('remove-in-shadow-dom', selector[, baseSelector])
     * ```
     *
     * - `selector`  required, CSS selector of element in shadow-dom to remove
     * - `baseSelector`  optional, selector of specific page DOM element,
     * narrows down the part of the page DOM where shadow-dom host supposed to be,
     * defaults to document.documentElement
     *
     * > `baseSelector` should match element of the page DOM, but not of shadow DOM
     *
     * **Examples**
     * ```
     * ! removes menu bar
     * virustotal.com#%#//scriptlet('remove-in-shadow-dom', 'iron-pages', 'vt-virustotal-app')
     *
     * ! removes floating element
     * virustotal.com#%#//scriptlet('remove-in-shadow-dom', 'vt-ui-contact-fab')
     * ```
     */
    function removeInShadowDom$1(source, selector, baseSelector) {
      // do nothing if browser does not support ShadowRoot
      // https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot
      if (!Element.prototype.attachShadow) {
        return;
      }
      const removeElement = function removeElement(targetElement) {
        targetElement.remove();
      };

      /**
       * Handles shadow-dom piercing and removing of found elements
       */
      const removeHandler = function removeHandler() {
        // start value of shadow-dom hosts for the page dom
        let hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);

        // if there is shadow-dom host, they should be explored
        while (hostElements.length !== 0) {
          let isRemoved = false;
          const _pierceShadowDom = pierceShadowDom(selector, hostElements),
            targets = _pierceShadowDom.targets,
            innerHosts = _pierceShadowDom.innerHosts;
          targets.forEach(function (targetEl) {
            removeElement(targetEl);
            isRemoved = true;
          });
          if (isRemoved) {
            hit(source);
          }

          // continue to pierce for inner shadow-dom hosts
          // and search inside them while the next iteration
          hostElements = innerHosts;
        }
      };
      removeHandler();
      observeDOMChanges(removeHandler, true);
    }
    removeInShadowDom$1.names = ['remove-in-shadow-dom'];
    removeInShadowDom$1.injections = [hit, observeDOMChanges, findHostElements, pierceShadowDom,
    // following helpers should be imported and injected
    // because they are used by helpers above
    flatten, throttle];

    /* eslint-disable max-len */
    /**
     * @scriptlet prevent-fetch
     * @description
     * Prevents `fetch` calls if **all** given parameters match
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-fetch-ifjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-fetch'[, propsToMatch[, responseBody[, responseType]]])
     * ```
     *
     * - `propsToMatch`  optional, string of space-separated properties to match; possible props:
     *   - string or regular expression for matching the URL passed to fetch call; empty string, wildcard `*` or invalid regular expression will match all fetch calls
     *   - colon-separated pairs `name:value` where
     *     - `name` is [`init` option name](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#parameters)
     *     - `value` is string or regular expression for matching the value of the option passed to fetch call; invalid regular expression will cause any value matching
     * - `responseBody`  optional, string for defining response body value, defaults to `emptyObj`. Possible values:
     *    - `emptyObj`  empty object
     *    - `emptyArr`  empty array
     * - `responseType`  optional, string for defining response type, defaults to `default`. Possible values:
     *    - `default`
     *    - `opaque`
     *
     * > Usage with no arguments will log fetch calls to browser console;
     * which is useful for debugging but not permitted for production filter lists.
     *
     * **Examples**
     * 1. Log all fetch calls
     *     ```
     *     example.org#%#//scriptlet('prevent-fetch')
     *     ```
     *
     * 2. Prevent all fetch calls
     *     ```
     *     example.org#%#//scriptlet('prevent-fetch', '*')
     *     OR
     *     example.org#%#//scriptlet('prevent-fetch', '')
     *     ```
     *
     * 3. Prevent fetch call for specific url
     *     ```
     *     example.org#%#//scriptlet('prevent-fetch', '/url\\.part/')
     *     ```
     *
     * 4. Prevent fetch call for specific request method
     *     ```
     *     example.org#%#//scriptlet('prevent-fetch', 'method:HEAD')
     *     ```
     *
     * 5. Prevent fetch call for specific url and request method
     *     ```
     *     example.org#%#//scriptlet('prevent-fetch', '/specified_url_part/ method:/HEAD|GET/')
     *     ```
     *
     * 6. Prevent fetch call and specify response body value
     *     ```
     *     ! Specify response body for fetch call to a specific url
     *     example.org#%#//scriptlet('prevent-fetch', '/specified_url_part/ method:/HEAD|GET/', 'emptyArr')
     *
     *     ! Specify response body for all fetch calls
     *     example.org#%#//scriptlet('prevent-fetch', '', 'emptyArr')
     *     ```
     *
     * 7. Prevent all fetch calls and specify response type value
     *     ```
     *     example.org#%#//scriptlet('prevent-fetch', '*', '', 'opaque')
     *     ```
     */
    /* eslint-enable max-len */
    function preventFetch$1(source, propsToMatch) {
      let responseBody = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'emptyObj';
      let responseType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'default';
      // do nothing if browser does not support fetch or Proxy (e.g. Internet Explorer)
      // https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
      if (typeof fetch === 'undefined' || typeof Proxy === 'undefined' || typeof Response === 'undefined') {
        return;
      }
      let strResponseBody;
      if (responseBody === '' || responseBody === 'emptyObj') {
        strResponseBody = '{}';
      } else if (responseBody === 'emptyArr') {
        strResponseBody = '[]';
      } else {
        return;
      }

      // Skip disallowed response types
      if (!(responseType === 'default' || responseType === 'opaque')) {
        logMessage(source, "Invalid parameter: ".concat(responseType));
        return;
      }
      const handlerWrapper = function handlerWrapper(target, thisArg, args) {
        let shouldPrevent = false;
        const fetchData = getFetchData(args);
        if (typeof propsToMatch === 'undefined') {
          logMessage(source, "fetch( ".concat(objectToString(fetchData), " )"), true);
          hit(source);
          return Reflect.apply(target, thisArg, args);
        }
        shouldPrevent = matchRequestProps(source, propsToMatch, fetchData);
        if (shouldPrevent) {
          hit(source);
          return noopPromiseResolve(strResponseBody, fetchData.url, responseType);
        }
        return Reflect.apply(target, thisArg, args);
      };
      const fetchHandler = {
        apply: handlerWrapper
      };
      fetch = new Proxy(fetch, fetchHandler); // eslint-disable-line no-global-assign
    }

    preventFetch$1.names = ['prevent-fetch',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'no-fetch-if.js', 'ubo-no-fetch-if.js', 'ubo-no-fetch-if'];
    preventFetch$1.injections = [hit, getFetchData, objectToString, noopPromiseResolve, matchRequestProps, logMessage, toRegExp, isValidStrPattern, escapeRegExp, isEmptyObject, getRequestData, getRequestProps, getObjectEntries, getObjectFromEntries, parseMatchProps, validateParsedData, getMatchPropsData];

    /* eslint-disable max-len */
    /**
     * @scriptlet set-local-storage-item
     * @description
     * Adds specified key and its value to localStorage object, or updates the value of the key if it already exists.
     * Scriptlet won't set item if storage is full.
     *
     * **Syntax**
     * ```
     * example.com#%#//scriptlet('set-local-storage-item', 'key', 'value')
     * ```
     *
     * - `key`  required, key name to be set.
     * - `value`  required, key value; possible values:
     *     - positive decimal integer `<= 32767`
     *     - one of the predefined constants:
     *         - `undefined`
     *         - `false`
     *         - `true`
     *         - `null`
     *         - `emptyObj`  empty object
     *         - `emptyArr`  empty array
     *         - `''`  empty string
     *         - `yes`
     *         - `no`
     *
     * **Examples**
     * ```
     * example.org#%#//scriptlet('set-local-storage-item', 'player.live.current.mute', 'false')
     *
     * example.org#%#//scriptlet('set-local-storage-item', 'exit-intent-marketing', '1')
     * ```
     */
    /* eslint-enable max-len */

    function setLocalStorageItem$1(source, key, value) {
      if (typeof key === 'undefined') {
        logMessage(source, 'Item key should be specified.');
        return;
      }
      let validValue;
      try {
        validValue = getLimitedStorageItemValue(value);
      } catch (_unused) {
        logMessage(source, "Invalid storage item value: '".concat(value, "'"));
        return;
      }
      const _window = window,
        localStorage = _window.localStorage;
      setStorageItem(source, localStorage, key, validValue);
      hit(source);
    }
    setLocalStorageItem$1.names = ['set-local-storage-item'];
    setLocalStorageItem$1.injections = [hit, logMessage, nativeIsNaN, setStorageItem, getLimitedStorageItemValue];

    /* eslint-disable max-len */
    /**
     * @scriptlet set-session-storage-item
     * @description
     * Adds specified key and its value to sessionStorage object, or updates the value of the key if it already exists.
     * Scriptlet won't set item if storage is full.
     *
     * **Syntax**
     * ```
     * example.com#%#//scriptlet('set-session-storage-item', 'key', 'value')
     * ```
     *
     * - `key`  required, key name to be set.
     * - `value`  required, key value; possible values:
     *     - positive decimal integer `<= 32767`
     *     - one of the predefined constants:
     *         - `undefined`
     *         - `false`
     *         - `true`
     *         - `null`
     *         - `emptyObj`  empty object
     *         - `emptyArr`  empty array
     *         - `''`  empty string
     *         - `yes`
     *         - `no`
     *
     * **Examples**
     * ```
     * example.org#%#//scriptlet('set-session-storage-item', 'player.live.current.mute', 'false')
     *
     * example.org#%#//scriptlet('set-session-storage-item', 'exit-intent-marketing', '1')
     * ```
     */
    /* eslint-enable max-len */

    function setSessionStorageItem$1(source, key, value) {
      if (typeof key === 'undefined') {
        logMessage(source, 'Item key should be specified.');
        return;
      }
      let validValue;
      try {
        validValue = getLimitedStorageItemValue(value);
      } catch (_unused) {
        logMessage(source, "Invalid storage item value: '".concat(value, "'"));
        return;
      }
      const _window = window,
        sessionStorage = _window.sessionStorage;
      setStorageItem(source, sessionStorage, key, validValue);
      hit(source);
    }
    setSessionStorageItem$1.names = ['set-session-storage-item'];
    setSessionStorageItem$1.injections = [hit, logMessage, nativeIsNaN, setStorageItem, getLimitedStorageItemValue];

    /* eslint-disable max-len */
    /**
     * @scriptlet abort-on-stack-trace
     * @description
     * Aborts a script when it attempts to utilize (read or write to) the specified property and it's error stack trace contains given value.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock-for-firefox-legacy/commit/7099186ae54e70b588d5e99554a05d783cabc8ff
     *
     * **Syntax**
     * ```
     * example.com#%#//scriptlet('abort-on-stack-trace', property, stack)
     * ```
     *
     * - `property`  required, path to a property. The property must be attached to window.
     * - `stack`  required, string that must match the current function call stack trace.
     *     - values to abort inline or injected script, accordingly:
     *         - `inlineScript`
     *         - `injectedScript`
     *
     * **Examples**
     * ```
     * ! Aborts script when it tries to access `window.Ya` and it's error stack trace contains `test.js`
     * example.org#%#//scriptlet('abort-on-stack-trace', 'Ya', 'test.js')
     *
     * ! Aborts script when it tries to access `window.Ya.videoAd` and it's error stack trace contains `test.js`
     * example.org#%#//scriptlet('abort-on-stack-trace', 'Ya.videoAd', 'test.js')
     *
     * ! Aborts script when stack trace matches with any of these parameters
     * example.org#%#//scriptlet('abort-on-stack-trace', 'Ya', 'yandexFuncName')
     * example.org#%#//scriptlet('abort-on-stack-trace', 'Ya', 'yandexScriptName')
     *
     * ! Aborts script when it tries to access `window.Ya` and it's an inline script
     * example.org#%#//scriptlet('abort-on-stack-trace', 'Ya', 'inlineScript')
     *
     * ! Aborts script when it tries to access `window.Ya` and it's an injected script
     * example.org#%#//scriptlet('abort-on-stack-trace', 'Ya', 'injectedScript')
     * ```
     */
    /* eslint-enable max-len */
    function abortOnStackTrace$1(source, property, stack) {
      if (!property || !stack) {
        return;
      }
      const rid = randomId();
      const abort = function abort() {
        hit(source);
        throw new ReferenceError(rid);
      };
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        if (!stack.match(/^(inlineScript|injectedScript)$/) && !isValidStrPattern(stack)) {
          logMessage(source, "Invalid parameter: ".concat(stack));
          return;
        }

        // Prevent infinite loops when trapping prop used by helpers in getter/setter
        const descriptorWrapper = Object.assign(getDescriptorAddon(), {
          value: base[prop],
          get() {
            if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
              abort();
            }
            return this.value;
          },
          set(newValue) {
            if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
              abort();
            }
            this.value = newValue;
          }
        });
        setPropertyAccess(base, prop, {
          // Call wrapped getter and setter to keep isAbortingSuspended & isolateCallback values
          get() {
            return descriptorWrapper.get.call(descriptorWrapper);
          },
          set(newValue) {
            descriptorWrapper.set.call(descriptorWrapper, newValue);
          }
        });
      };
      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    abortOnStackTrace$1.names = ['abort-on-stack-trace',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'abort-on-stack-trace.js', 'ubo-abort-on-stack-trace.js', 'aost.js', 'ubo-aost.js', 'ubo-abort-on-stack-trace', 'ubo-aost', 'abp-abort-on-stack-trace'];
    abortOnStackTrace$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, isValidStrPattern, escapeRegExp, matchStackTrace, getDescriptorAddon, logMessage, toRegExp, isEmptyObject, getNativeRegexpTest, startsWith$1, shouldAbortInlineOrInjectedScript];

    /* eslint-disable max-len */
    /**
     * @scriptlet log-on-stack-trace
     * @description
     * This scriptlet is basically the same as [abort-on-stack-trace](#abort-on-stack-trace), but instead of aborting it logs:
     * - function and source script names pairs that access the given property
     * - was that get or set attempt
     * - script being injected or inline
     *
     * **Syntax**
     * ```
     * example.com#%#//scriptlet('log-on-stack-trace', 'property')
     * ```
     *
     * - `property`  required, path to a property. The property must be attached to window.
     */
    /* eslint-enable max-len */
    function logOnStacktrace$1(source, property) {
      if (!property) {
        return;
      }
      const refineStackTrace = function refineStackTrace(stackString) {
        // Split stack trace string by lines and remove first two elements ('Error' and getter call)
        // Remove '    at ' at the start of each string
        const stackSteps = stackString.split('\n').slice(2).map(function (line) {
          return line.replace(/ {4}at /, '');
        });
        // Trim each line extracting funcName : fullPath pair
        const logInfoArray = stackSteps.map(function (line) {
          let funcName;
          let funcFullPath;
          /* eslint-disable-next-line no-useless-escape */
          const reg = /\(([^\)]+)\)/;
          const regFirefox = /(.*?@)(\S+)(:\d+):\d+\)?$/;
          if (line.match(reg)) {
            funcName = line.split(' ').slice(0, -1).join(' ');
            /* eslint-disable-next-line prefer-destructuring */
            funcFullPath = line.match(reg)[1];
          } else if (line.match(regFirefox)) {
            funcName = line.split('@').slice(0, -1).join(' ');
            /* eslint-disable-next-line prefer-destructuring */
            funcFullPath = line.match(regFirefox)[2];
          } else {
            // For when func name is not available
            funcName = 'function name is not available';
            funcFullPath = line;
          }
          return [funcName, funcFullPath];
        });
        // Convert array into object for better display using console.table
        const logInfoObject = {};
        logInfoArray.forEach(function (pair) {
          /* eslint-disable-next-line prefer-destructuring */
          logInfoObject[pair[0]] = pair[1];
        });
        return logInfoObject;
      };
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        let value = base[prop];
        /* eslint-disable no-console */
        setPropertyAccess(base, prop, {
          get() {
            hit(source);
            logMessage(source, "Get ".concat(prop), true);
            console.table(refineStackTrace(new Error().stack));
            return value;
          },
          set(newValue) {
            hit(source);
            logMessage(source, "Set ".concat(prop), true);
            console.table(refineStackTrace(new Error().stack));
            value = newValue;
          }
        });
        /* eslint-enable no-console */
      };

      setChainPropAccess(window, property);
    }
    logOnStacktrace$1.names = ['log-on-stack-trace'];
    logOnStacktrace$1.injections = [getPropertyInChain, setPropertyAccess, hit, logMessage, isEmptyObject];

    /* eslint-disable max-len */
    /**
     * @scriptlet prevent-xhr
     * @description
     * Prevents `xhr` calls if **all** given parameters match.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-xhr-ifjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-xhr'[, propsToMatch[, randomize]])
     * ```
     *
     * - `propsToMatch`  optional, string of space-separated properties to match; possible props:
     *   - string or regular expression for matching the URL passed to `XMLHttpRequest.open()` call; empty string or wildcard `*` for all `XMLHttpRequest.open()` calls match
     *   - colon-separated pairs `name:value` where
     *     - `name` is XMLHttpRequest object property name
     *     - `value` is string or regular expression for matching the value of the option passed to `XMLHttpRequest.open()` call
     * - `randomize`  defaults to `false` for empty responseText, optional argument to randomize responseText of matched XMLHttpRequest's response; possible values:
     *   - `true` to randomize responseText, random alphanumeric string of 10 symbols
     *   - colon-separated pair `name:value` string value to customize responseText data where
     *       - `name`  only `length` supported for now
     *       - `value`  range on numbers, for example `100-300`, limited to 500000 characters
     *
     * > Usage with no arguments will log XMLHttpRequest objects to browser console;
     * which is useful for debugging but not allowed for production filter lists.
     *
     * **Examples**
     * 1. Log all XMLHttpRequests
     *     ```
     *     example.org#%#//scriptlet('prevent-xhr')
     *     ```
     *
     * 2. Prevent all XMLHttpRequests
     *     ```
     *     example.org#%#//scriptlet('prevent-xhr', '*')
     *     example.org#%#//scriptlet('prevent-xhr', '')
     *     ```
     *
     * 3. Prevent XMLHttpRequests for specific url
     *     ```
     *     example.org#%#//scriptlet('prevent-xhr', 'example.org')
     *     ```
     *
     * 4. Prevent XMLHttpRequests for specific request method
     *     ```
     *     example.org#%#//scriptlet('prevent-xhr', 'method:HEAD')
     *     ```
     *
     * 5. Prevent XMLHttpRequests for specific url and specified request methods
     *     ```
     *     example.org#%#//scriptlet('prevent-xhr', 'example.org method:/HEAD|GET/')
     *     ```
     *
     * 6. Prevent XMLHttpRequests for specific url and randomize it's response text
     *     ```
     *     example.org#%#//scriptlet('prevent-xhr', 'example.org', 'true')
     *     ```
     *
     * 7. Prevent XMLHttpRequests for specific url and randomize it's response text with range
     *     ```
     *    example.org#%#//scriptlet('prevent-xhr', 'example.org', 'length:100-300')
     *     ```
     */
    /* eslint-enable max-len */
    function preventXHR$1(source, propsToMatch, customResponseText) {
      // do nothing if browser does not support Proxy (e.g. Internet Explorer)
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
      if (typeof Proxy === 'undefined') {
        return;
      }
      let response = '';
      let responseText = '';
      let responseUrl;
      const openWrapper = function openWrapper(target, thisArg, args) {
        // Get method and url from .open()
        const xhrData = {
          method: args[0],
          url: args[1]
        };
        responseUrl = xhrData.url;
        if (typeof propsToMatch === 'undefined') {
          // Log if no propsToMatch given
          logMessage(source, "xhr( ".concat(objectToString(xhrData), " )"), true);
          hit(source);
        } else if (matchRequestProps(source, propsToMatch, xhrData)) {
          thisArg.shouldBePrevented = true;
        }
        return Reflect.apply(target, thisArg, args);
      };
      const sendWrapper = function sendWrapper(target, thisArg, args) {
        if (!thisArg.shouldBePrevented) {
          return Reflect.apply(target, thisArg, args);
        }
        if (thisArg.responseType === 'blob') {
          response = new Blob();
        }
        if (thisArg.responseType === 'arraybuffer') {
          response = new ArrayBuffer();
        }
        if (customResponseText) {
          const randomText = generateRandomResponse(customResponseText);
          if (randomText) {
            responseText = randomText;
          } else {
            logMessage(source, "Invalid range: ".concat(customResponseText));
          }
        }
        // Mock response object
        Object.defineProperties(thisArg, {
          readyState: {
            value: 4,
            writable: false
          },
          response: {
            value: response,
            writable: false
          },
          responseText: {
            value: responseText,
            writable: false
          },
          responseURL: {
            value: responseUrl,
            writable: false
          },
          responseXML: {
            value: '',
            writable: false
          },
          status: {
            value: 200,
            writable: false
          },
          statusText: {
            value: 'OK',
            writable: false
          }
        });
        // Mock events
        setTimeout(function () {
          const stateEvent = new Event('readystatechange');
          thisArg.dispatchEvent(stateEvent);
          const loadEvent = new Event('load');
          thisArg.dispatchEvent(loadEvent);
          const loadEndEvent = new Event('loadend');
          thisArg.dispatchEvent(loadEndEvent);
        }, 1);
        hit(source);
        return undefined;
      };
      const openHandler = {
        apply: openWrapper
      };
      const sendHandler = {
        apply: sendWrapper
      };
      XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
      XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
    }
    preventXHR$1.names = ['prevent-xhr',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'no-xhr-if.js', 'ubo-no-xhr-if.js', 'ubo-no-xhr-if'];
    preventXHR$1.injections = [hit, logMessage, objectToString, matchRequestProps, generateRandomResponse, toRegExp, isValidStrPattern, escapeRegExp, isEmptyObject, getObjectEntries, getNumberFromString, nativeIsFinite, nativeIsNaN, parseMatchProps, validateParsedData, getMatchPropsData, getRequestProps, getRandomIntInclusive, getRandomStrByLength];

    /**
     * @scriptlet close-window
     * @description
     * Closes the browser tab immediately.
     *
     * > `window.close()` usage is restricted in Chrome. In this case
     * tab will only be closed when using AdGuard browser extension.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('close-window'[, path])
     * ```
     *
     * - `path`  optional, string or regular expression
     * matching the current location's path: `window.location.pathname` + `window.location.search`.
     * Defaults to execute on every page.
     *
     * **Examples**
     * ```
     * ! closes any example.org tab
     * example.org#%#//scriptlet('close-window')
     *
     * ! closes specific example.org tab
     * example.org#%#//scriptlet('close-window', '/example-page.html')
     * ```
     */
    function forceWindowClose$1(source) {
      let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      // https://github.com/AdguardTeam/Scriptlets/issues/158#issuecomment-993423036
      if (typeof window.close !== 'function') {
        const message = 'window.close() is not a function so \'close-window\' scriptlet is unavailable';
        logMessage(source, message);
        return;
      }
      const closeImmediately = function closeImmediately() {
        try {
          hit(source);
          window.close();
        } catch (e) {
          // log the error if window closing is impossible
          // https://developer.mozilla.org/en-US/docs/Web/API/Window/close
          logMessage(source, e);
        }
      };
      const closeByExtension = function closeByExtension() {
        const extCall = function extCall() {
          dispatchEvent(new Event('adguard:scriptlet-close-window'));
        };
        window.addEventListener('adguard:subscribed-to-close-window', extCall, {
          once: true
        });
        setTimeout(function () {
          window.removeEventListener('adguard:subscribed-to-close-window', extCall, {
            once: true
          });
        }, 5000);
      };
      const shouldClose = function shouldClose() {
        if (path === '') {
          return true;
        }
        const pathRegexp = toRegExp(path);
        const currentPath = "".concat(window.location.pathname).concat(window.location.search);
        return pathRegexp.test(currentPath);
      };
      if (shouldClose()) {
        closeImmediately();
        if (navigator.userAgent.indexOf('Chrome') > -1) {
          closeByExtension();
        }
      }
    }
    forceWindowClose$1.names = ['close-window', 'window-close-if.js', 'ubo-window-close-if.js', 'ubo-window-close-if'];
    forceWindowClose$1.injections = [hit, toRegExp, logMessage];

    /* eslint-disable max-len */
    /**
     * @scriptlet prevent-refresh
     * @description
     * Prevents reloading of a document through a meta "refresh" tag.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#refresh-defuserjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-refresh'[, delay])
     * ```
     *
     * - `delay`  optional, number of seconds for delay that indicates when scriptlet should run. If not set, source tag value will be applied.
     *
     * **Examples**
     * 1. Prevent reloading of a document through a meta "refresh" tag.
     * ```
     *     enrt.eu#%#//scriptlet('prevent-refresh')
     * ```
     *
     * 2. Prevent reloading of a document with delay.
     * ```
     *     cryptodirectories.com#%#//scriptlet('prevent-refresh', 3)
     * ```
     */
    /* eslint-enable max-len */
    function preventRefresh$1(source, delaySec) {
      const getMetaElements = function getMetaElements() {
        let metaNodes = [];
        try {
          metaNodes = document.querySelectorAll('meta[http-equiv="refresh" i][content]');
        } catch (e) {
          // 'i' attribute flag is problematic in Edge 15
          try {
            metaNodes = document.querySelectorAll('meta[http-equiv="refresh"][content]');
          } catch (e) {
            logMessage(source, e);
          }
        }
        return Array.from(metaNodes);
      };
      const getMetaContentDelay = function getMetaContentDelay(metaElements) {
        const delays = metaElements.map(function (meta) {
          const contentString = meta.getAttribute('content');
          if (contentString.length === 0) {
            return null;
          }
          let contentDelay;
          // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv
          const limiterIndex = contentString.indexOf(';');
          if (limiterIndex !== -1) {
            const delaySubstring = contentString.substring(0, limiterIndex);
            contentDelay = getNumberFromString(delaySubstring);
          } else {
            contentDelay = getNumberFromString(contentString);
          }
          return contentDelay;
        }).filter(function (delay) {
          return delay !== null;
        });
        // Check if "delays" array is empty, may happens when meta's content is invalid
        // and reduce() method cannot be used with empty arrays without initial value
        if (!delays.length) {
          return null;
        }
        // Get smallest delay of all metas on the page
        const minDelay = delays.reduce(function (a, b) {
          return Math.min(a, b);
        });
        // eslint-disable-next-line consistent-return
        return minDelay;
      };
      const stop = function stop() {
        const metaElements = getMetaElements();
        if (metaElements.length === 0) {
          return;
        }
        let secondsToRun = getNumberFromString(delaySec);
        // Check if argument is provided
        if (secondsToRun === null) {
          secondsToRun = getMetaContentDelay(metaElements);
        }
        // Check if meta tag has delay
        if (secondsToRun === null) {
          return;
        }
        const delayMs = secondsToRun * 1000;
        setTimeout(function () {
          window.stop();
          hit(source);
        }, delayMs);
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', stop, {
          once: true
        });
      } else {
        stop();
      }
    }
    preventRefresh$1.names = ['prevent-refresh',
    // Aliases are needed for matching the related scriptlet converted into our syntax
    // These are used by UBO rules syntax
    // https://github.com/gorhill/uBlock/wiki/Resources-Library#general-purpose-scriptlets
    'refresh-defuser.js', 'refresh-defuser',
    // Prefix 'ubo-' is required to run converted rules
    'ubo-refresh-defuser.js', 'ubo-refresh-defuser'];
    preventRefresh$1.injections = [hit, getNumberFromString, logMessage, nativeIsNaN];

    /* eslint-disable max-len, consistent-return */
    /**
     * @scriptlet prevent-element-src-loading
     * @description
     * Prevents target element source loading without triggering 'onerror' listeners and not breaking 'onload' ones.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-element-src-loading', tagName, match)
     * ```
     *
     * - `tagName`  required, case-insensitive target element tagName which `src` property resource loading will be silently prevented; possible values:
     *     - `script`
     *     - `img`
     *     - `iframe`
     * - `match`  required, string or regular expression for matching the element's URL;
     *
     * **Examples**
     * 1. Prevent script source loading:
     * ```
     *     example.org#%#//scriptlet('prevent-element-src-loading', 'script' ,'adsbygoogle')
     * ```
     */
    /* eslint-enable max-len */
    function preventElementSrcLoading$1(source, tagName, match) {
      // do nothing if browser does not support Proxy or Reflect
      if (typeof Proxy === 'undefined' || typeof Reflect === 'undefined') {
        return;
      }
      const srcMockData = {
        // "KCk9Pnt9" = "()=>{}"
        script: 'data:text/javascript;base64,KCk9Pnt9',
        // Empty 1x1 image
        img: 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',
        // Empty h1 tag
        iframe: 'data:text/html;base64, PGRpdj48L2Rpdj4='
      };
      let instance;
      if (tagName === 'script') {
        instance = HTMLScriptElement;
      } else if (tagName === 'img') {
        instance = HTMLImageElement;
      } else if (tagName === 'iframe') {
        instance = HTMLIFrameElement;
      } else {
        return;
      }

      // For websites that use Trusted Types
      // https://w3c.github.io/webappsec-trusted-types/dist/spec/
      const hasTrustedTypes = window.trustedTypes && typeof window.trustedTypes.createPolicy === 'function';
      let policy;
      if (hasTrustedTypes) {
        // The name for the trusted-types policy should only be 'AGPolicy',because corelibs can
        // allow our policy if the server has restricted the creation of a trusted-types policy with
        // the directive 'Content-Security-Policy: trusted-types <policyName>;`.
        // If such a header is presented in the server response, corelibs adds permission to create
        // the 'AGPolicy' policy with the 'allow-duplicates' option to prevent errors.
        // See AG-18204 for details.
        policy = window.trustedTypes.createPolicy('AGPolicy', {
          createScriptURL: function createScriptURL(arg) {
            return arg;
          }
        });
      }
      const SOURCE_PROPERTY_NAME = 'src';
      const ONERROR_PROPERTY_NAME = 'onerror';
      const searchRegexp = toRegExp(match);

      // This will be needed to silent error events on matched element,
      // as url wont be available
      const setMatchedAttribute = function setMatchedAttribute(elem) {
        return elem.setAttribute(source.name, 'matched');
      };
      const setAttributeWrapper = function setAttributeWrapper(target, thisArg, args) {
        // Check if arguments are present
        if (!args[0] || !args[1]) {
          return Reflect.apply(target, thisArg, args);
        }
        const nodeName = thisArg.nodeName.toLowerCase();
        const attrName = args[0].toLowerCase();
        const attrValue = args[1];
        const isMatched = attrName === SOURCE_PROPERTY_NAME && tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(attrValue);
        if (!isMatched) {
          return Reflect.apply(target, thisArg, args);
        }
        hit(source);
        setMatchedAttribute(thisArg);
        // Forward the URI that corresponds with element's MIME type
        return Reflect.apply(target, thisArg, [attrName, srcMockData[nodeName]]);
      };
      const setAttributeHandler = {
        apply: setAttributeWrapper
      };
      // eslint-disable-next-line max-len
      instance.prototype.setAttribute = new Proxy(Element.prototype.setAttribute, setAttributeHandler);
      const origSrcDescriptor = safeGetDescriptor(instance.prototype, SOURCE_PROPERTY_NAME);
      if (!origSrcDescriptor) {
        return;
      }
      Object.defineProperty(instance.prototype, SOURCE_PROPERTY_NAME, {
        enumerable: true,
        configurable: true,
        get() {
          return origSrcDescriptor.get.call(this);
        },
        set(urlValue) {
          const nodeName = this.nodeName.toLowerCase();
          const isMatched = tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(urlValue);
          if (!isMatched) {
            origSrcDescriptor.set.call(this, urlValue);
            return true;
          }

          // eslint-disable-next-line no-undef
          if (policy && urlValue instanceof TrustedScriptURL) {
            const trustedSrc = policy.createScriptURL(urlValue);
            origSrcDescriptor.set.call(this, trustedSrc);
            hit(source);
            return;
          }
          setMatchedAttribute(this);
          origSrcDescriptor.set.call(this, srcMockData[nodeName]);
          hit(source);
        }
      });

      // https://github.com/AdguardTeam/Scriptlets/issues/228
      // Prevent error event being triggered by other sources
      const origOnerrorDescriptor = safeGetDescriptor(HTMLElement.prototype, ONERROR_PROPERTY_NAME);
      if (!origOnerrorDescriptor) {
        return;
      }
      Object.defineProperty(HTMLElement.prototype, ONERROR_PROPERTY_NAME, {
        enumerable: true,
        configurable: true,
        get() {
          return origOnerrorDescriptor.get.call(this);
        },
        set(cb) {
          const isMatched = this.getAttribute(source.name) === 'matched';
          if (!isMatched) {
            origOnerrorDescriptor.set.call(this, cb);
            return true;
          }
          origOnerrorDescriptor.set.call(this, noopFunc);
          return true;
        }
      });
      const addEventListenerWrapper = function addEventListenerWrapper(target, thisArg, args) {
        // Check if arguments are present
        if (!args[0] || !args[1] || !thisArg) {
          return Reflect.apply(target, thisArg, args);
        }
        const eventName = args[0];
        const isMatched = typeof thisArg.getAttribute === 'function' && thisArg.getAttribute(source.name) === 'matched' && eventName === 'error';
        if (isMatched) {
          return Reflect.apply(target, thisArg, [eventName, noopFunc]);
        }
        return Reflect.apply(target, thisArg, args);
      };
      const addEventListenerHandler = {
        apply: addEventListenerWrapper
      };
      // eslint-disable-next-line max-len
      EventTarget.prototype.addEventListener = new Proxy(EventTarget.prototype.addEventListener, addEventListenerHandler);
    }
    preventElementSrcLoading$1.names = ['prevent-element-src-loading'];
    preventElementSrcLoading$1.injections = [hit, toRegExp, safeGetDescriptor, noopFunc];

    /**
     * @scriptlet no-topics
     * @description
     * Prevents using The Topics API
     * https://developer.chrome.com/docs/privacy-sandbox/topics/
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('no-topics')
     * ```
     */
    function noTopics$1(source) {
      const TOPICS_PROPERTY_NAME = 'browsingTopics';
      if (Document instanceof Object === false) {
        return;
      }
      if (!Object.prototype.hasOwnProperty.call(Document.prototype, TOPICS_PROPERTY_NAME) || Document.prototype[TOPICS_PROPERTY_NAME] instanceof Function === false) {
        return;
      }

      // document.browsingTopics() is async function so it's better to return noopPromiseResolve()
      // https://github.com/patcg-individual-drafts/topics#the-api-and-how-it-works
      Document.prototype[TOPICS_PROPERTY_NAME] = function () {
        return noopPromiseResolve('[]');
      };
      hit(source);
    }
    noTopics$1.names = ['no-topics'];
    noTopics$1.injections = [hit, noopPromiseResolve];

    /* eslint-disable max-len */
    /**
     * @trustedScriptlet trusted-replace-xhr-response
     * @description
     * Replaces response content of `xhr` requests if **all** given parameters match.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('trusted-replace-xhr-response'[, pattern, replacement[, propsToMatch]])
     * ```
     *
     * - `pattern`  optional, argument for matching contents of responseText that should be replaced. If set, `replacement` is required;
     * possible values:
     *   - `*` to match all text content
     *   - non-empty string
     *   - regular expression
     * - `replacement`  optional, should be set if `pattern` is set. String to replace matched content with. Empty string to remove content.
     * - `propsToMatch`  optional, string of space-separated properties to match for extra condition; possible props:
     *   - string or regular expression for matching the URL passed to `XMLHttpRequest.open()` call;
     *   - colon-separated pairs `name:value` where
     *     - `name`  string or regular expression for matching XMLHttpRequest property name
     *     - `value`  string or regular expression for matching the value of the option passed to `XMLHttpRequest.open()` call
     *
     * > Usage with no arguments will log XMLHttpRequest objects to browser console;
     * which is useful for debugging but not permitted for production filter lists.
     *
     * **Examples**
     * 1. Log all XMLHttpRequests
     *     ```
     *     example.org#%#//scriptlet('trusted-replace-xhr-response')
     *     ```
     *
     * 2. Replace text content of XMLHttpRequests with specific url
     *     ```
     *     example.org#%#//scriptlet('trusted-replace-xhr-response', 'adb_detect:true', 'adb_detect:false', 'example.org')
     *     example.org#%#//scriptlet('trusted-replace-xhr-response', '/#EXT-X-VMAP-AD-BREAK[\s\S]*?/', '#EXT-X-ENDLIST', 'example.org')
     *     ```
     *
     * 3. Remove all text content of XMLHttpRequests with specific request method
     *     ```
     *     example.org#%#//scriptlet('trusted-replace-xhr-response', '*', '', 'method:GET')
     *     ```
     *
     * 4. Replace text content of XMLHttpRequests matching by URL regex and request methods
     *     ```
     *     example.org#%#//scriptlet('trusted-replace-xhr-response', '/#EXT-X-VMAP-AD-BREAK[\s\S]*?/', '#EXT-X-ENDLIST', '/\.m3u8/ method:/GET|HEAD/')
     *     ```
     * 5. Remove all text content of  all XMLHttpRequests for example.com
     *     ```
     *     example.org#%#//scriptlet('trusted-replace-xhr-response', '*', '', 'example.com')
     *     ```
     */
    /* eslint-enable max-len */
    function trustedReplaceXhrResponse$1(source) {
      let pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      let replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      let propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      // do nothing if browser does not support Proxy (e.g. Internet Explorer)
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
      if (typeof Proxy === 'undefined') {
        return;
      }

      // Only allow pattern as empty string for logging purposes
      if (pattern === '' && replacement !== '') {
        const message = 'Pattern argument should not be empty string.';
        logMessage(source, message);
        return;
      }
      const shouldLog = pattern === '' && replacement === '';
      const nativeOpen = window.XMLHttpRequest.prototype.open;
      const nativeSend = window.XMLHttpRequest.prototype.send;
      let xhrData;
      const openWrapper = function openWrapper(target, thisArg, args) {
        // eslint-disable-next-line prefer-spread
        xhrData = getXhrData.apply(null, args);
        if (shouldLog) {
          // Log if no propsToMatch given
          const message = "xhr( ".concat(objectToString(xhrData), " )");
          logMessage(source, message, true);
          hit(source);
          return Reflect.apply(target, thisArg, args);
        }
        if (matchRequestProps(source, propsToMatch, xhrData)) {
          thisArg.shouldBePrevented = true;
        }

        // Trap setRequestHeader of target xhr object to mimic request headers later
        if (thisArg.shouldBePrevented) {
          thisArg.collectedHeaders = [];
          const setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
            // Collect headers
            thisArg.collectedHeaders.push(args);
            return Reflect.apply(target, thisArg, args);
          };
          const setRequestHeaderHandler = {
            apply: setRequestHeaderWrapper
          };

          // setRequestHeader can only be called on open xhr object,
          // so we can safely proxy it here
          thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
        }
        return Reflect.apply(target, thisArg, args);
      };
      const sendWrapper = function sendWrapper(target, thisArg, args) {
        if (!thisArg.shouldBePrevented) {
          return Reflect.apply(target, thisArg, args);
        }

        /**
         * Create separate XHR request with original request's input
         * to be able to collect response data without triggering
         * listeners on original XHR object
         */
        const forgedRequest = new XMLHttpRequest();
        forgedRequest.addEventListener('readystatechange', function () {
          if (forgedRequest.readyState !== 4) {
            return;
          }
          const readyState = forgedRequest.readyState,
            response = forgedRequest.response,
            responseText = forgedRequest.responseText,
            responseURL = forgedRequest.responseURL,
            responseXML = forgedRequest.responseXML,
            status = forgedRequest.status,
            statusText = forgedRequest.statusText;

          // Extract content from response
          const content = responseText || response;
          if (typeof content !== 'string') {
            return;
          }
          const patternRegexp = pattern === '*' ? /(\n|.)*/ : toRegExp(pattern);
          const modifiedContent = content.replace(patternRegexp, replacement);

          // Manually put required values into target XHR object
          // as thisArg can't be redefined and XHR objects can't be (re)assigned or copied
          Object.defineProperties(thisArg, {
            readyState: {
              value: readyState
            },
            response: {
              value: modifiedContent
            },
            responseText: {
              value: modifiedContent
            },
            responseURL: {
              value: responseURL
            },
            responseXML: {
              value: responseXML
            },
            status: {
              value: status
            },
            statusText: {
              value: statusText
            }
          });

          // Mock events
          setTimeout(function () {
            const stateEvent = new Event('readystatechange');
            thisArg.dispatchEvent(stateEvent);
            const loadEvent = new Event('load');
            thisArg.dispatchEvent(loadEvent);
            const loadEndEvent = new Event('loadend');
            thisArg.dispatchEvent(loadEndEvent);
          }, 1);
          hit(source);
        });
        nativeOpen.apply(forgedRequest, [xhrData.method, xhrData.url]);

        // Mimic request headers before sending
        // setRequestHeader can only be called on open request objects
        thisArg.collectedHeaders.forEach(function (header) {
          const name = header[0];
          const value = header[1];
          forgedRequest.setRequestHeader(name, value);
        });
        thisArg.collectedHeaders = [];
        try {
          nativeSend.call(forgedRequest, args);
        } catch (_unused) {
          return Reflect.apply(target, thisArg, args);
        }
        return undefined;
      };
      const openHandler = {
        apply: openWrapper
      };
      const sendHandler = {
        apply: sendWrapper
      };
      XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
      XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
    }
    trustedReplaceXhrResponse$1.names = ['trusted-replace-xhr-response'
    // trusted scriptlets support no aliases
    ];

    trustedReplaceXhrResponse$1.injections = [hit, logMessage, toRegExp, objectToString, matchRequestProps, getXhrData, getMatchPropsData, getRequestProps, validateParsedData, parseMatchProps, isValidStrPattern, escapeRegExp, isEmptyObject, getObjectEntries];

    /* eslint-disable max-len */
    /**
     * @scriptlet xml-prune
     * @description
     * Removes an element from the specified XML.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('xml-prune'[, propsToMatch[, optionalProp[, urlToMatch]]])
     * ```
     *
     * - `propsToMatch`  optional, selector of elements which will be removed from XML
     * - `optionalProp`  optional, selector of elements that must occur in XML document
     * - `urlToMatch`  optional, string or regular expression for matching the request's URL
     * > Usage with no arguments will log response payload and URL to browser console;
     * which is useful for debugging but prohibited for production filter lists.
     *
     * **Examples**
     * 1. Remove `Period` tag whose `id` contains `-ad-` from all requests
     *     ```
     *     example.org#%#//scriptlet('xml-prune', 'Period[id*="-ad-"]')
     *     ```
     *
     * 2. Remove `Period` tag whose `id` contains `-ad-`, only if XML contains `SegmentTemplate`
     *     ```
     *     example.org#%#//scriptlet('xml-prune', 'Period[id*="-ad-"]', 'SegmentTemplate')
     *     ```
     *
     * 3. Remove `Period` tag whose `id` contains `-ad-`, only if request's URL contains `.mpd`
     *     ```
     *     example.org#%#//scriptlet('xml-prune', 'Period[id*="-ad-"]', '', '.mpd')
     *     ```
     *
     * 4. Call with no arguments will log response payload and URL at the console
     *     ```
     *     example.org#%#//scriptlet('xml-prune')
     *     ```
     *
     * 5. Call with only `urlToMatch` argument will log response payload and URL only for the matched URL
     *     ```
     *     example.org#%#//scriptlet('xml-prune', '', '', '.mpd')
     *     ```
     */
    /* eslint-enable max-len */

    function xmlPrune$1(source, propsToRemove) {
      var _this = this;
      let optionalProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      let urlToMatch = arguments.length > 3 ? arguments[3] : undefined;
      // do nothing if browser does not support Reflect, fetch or Proxy (e.g. Internet Explorer)
      // https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect
      if (typeof Reflect === 'undefined' || typeof fetch === 'undefined' || typeof Proxy === 'undefined' || typeof Response === 'undefined') {
        return;
      }
      let shouldPruneResponse = true;
      if (!propsToRemove) {
        // If "propsToRemove" is not defined, then response shouldn't be pruned
        // but it should be logged in browser console
        shouldPruneResponse = false;
      }
      const urlMatchRegexp = toRegExp(urlToMatch);
      const isXML = function isXML(text) {
        // It's necessary to check the type of 'text'
        // because 'text' is obtained from the xhr/fetch response,
        // so it could also be Blob/ArrayBuffer/Object or another type
        if (typeof text === 'string') {
          // Check if "text" starts with "<" and check if it ends with ">"
          // If so, then it might be an XML file and should be pruned or logged
          const trimedText = text.trim();
          if (trimedText.startsWith('<') && trimedText.endsWith('>')) {
            return true;
          }
        }
        return false;
      };
      const createXMLDocument = function createXMLDocument(text) {
        const xmlParser = new DOMParser();
        const xmlDocument = xmlParser.parseFromString(text, 'text/xml');
        return xmlDocument;
      };
      const pruneXML = function pruneXML(text) {
        if (!isXML(text)) {
          shouldPruneResponse = false;
          return text;
        }
        const xmlDoc = createXMLDocument(text);
        const errorNode = xmlDoc.querySelector('parsererror');
        if (errorNode) {
          return text;
        }
        if (optionalProp !== '' && xmlDoc.querySelector(optionalProp) === null) {
          shouldPruneResponse = false;
          return text;
        }
        const elems = xmlDoc.querySelectorAll(propsToRemove);
        if (!elems.length) {
          shouldPruneResponse = false;
          return text;
        }
        elems.forEach(function (elem) {
          elem.remove();
        });
        const serializer = new XMLSerializer();
        text = serializer.serializeToString(xmlDoc);
        return text;
      };
      const xhrWrapper = function xhrWrapper(target, thisArg, args) {
        const xhrURL = args[1];
        if (typeof xhrURL !== 'string' || xhrURL.length === 0) {
          return Reflect.apply(target, thisArg, args);
        }
        if (urlMatchRegexp.test(xhrURL)) {
          thisArg.addEventListener('readystatechange', function pruneResponse() {
            if (thisArg.readyState === 4) {
              const response = thisArg.response;
              thisArg.removeEventListener('readystatechange', pruneResponse);
              if (!shouldPruneResponse) {
                if (isXML(response)) {
                  const message = "XMLHttpRequest.open() URL: ".concat(xhrURL, "\nresponse: ").concat(response);
                  logMessage(source, message);
                  logMessage(source, createXMLDocument(response), true, false);
                }
              } else {
                const prunedResponseContent = pruneXML(response);
                if (shouldPruneResponse) {
                  Object.defineProperty(thisArg, 'response', {
                    value: prunedResponseContent
                  });
                  Object.defineProperty(thisArg, 'responseText', {
                    value: prunedResponseContent
                  });
                  hit(source);
                }
                // In case if response shouldn't be pruned
                // pruneXML sets shouldPruneResponse to false
                // so it's necessary to set it to true again
                // otherwise response will be only logged
                shouldPruneResponse = true;
              }
            }
          });
        }
        return Reflect.apply(target, thisArg, args);
      };
      const xhrHandler = {
        apply: xhrWrapper
      };
      // eslint-disable-next-line max-len
      window.XMLHttpRequest.prototype.open = new Proxy(window.XMLHttpRequest.prototype.open, xhrHandler);
      const nativeFetch = window.fetch;
      const fetchWrapper = function fetchWrapper(target, thisArg, args) {
        const fetchURL = args[0] instanceof Request ? args[0].url : args[0];
        if (typeof fetchURL !== 'string' || fetchURL.length === 0) {
          return Reflect.apply(target, thisArg, args);
        }
        if (urlMatchRegexp.test(fetchURL)) {
          return nativeFetch.apply(_this, args).then(function (response) {
            return response.text().then(function (text) {
              if (!shouldPruneResponse) {
                if (isXML(text)) {
                  const message = "fetch URL: ".concat(fetchURL, "\nresponse text: ").concat(text);
                  logMessage(source, message);
                  logMessage(source, createXMLDocument(text), true, false);
                }
                return Reflect.apply(target, thisArg, args);
              }
              const prunedText = pruneXML(text);
              if (shouldPruneResponse) {
                hit(source);
                return new Response(prunedText, {
                  status: response.status,
                  statusText: response.statusText,
                  headers: response.headers
                });
              }
              // If response shouldn't be pruned
              // pruneXML sets shouldPruneResponse to false
              // so it's necessary to set it to true again
              // otherwise response will be only logged
              shouldPruneResponse = true;
              return Reflect.apply(target, thisArg, args);
            });
          });
        }
        return Reflect.apply(target, thisArg, args);
      };
      const fetchHandler = {
        apply: fetchWrapper
      };
      window.fetch = new Proxy(window.fetch, fetchHandler);
    }
    xmlPrune$1.names = ['xml-prune',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'xml-prune.js', 'ubo-xml-prune.js', 'ubo-xml-prune'];
    xmlPrune$1.injections = [hit, logMessage, toRegExp];

    /* eslint-disable max-len */
    /**
     * @scriptlet m3u-prune
     * @description
     * Removes content from the specified M3U file.
     *
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('m3u-prune'[, propsToRemove[, urlToMatch]])
     * ```
     *
     * - `propsToRemove`  optional, string or regular expression to match the URL line (segment) which will be removed alongside with its tags
     * - `urlToMatch`  optional, string or regular expression for matching the request's URL
     * > Usage with no arguments will log response payload and URL to browser console;
     * which is useful for debugging but prohibited for production filter lists.
     *
     * **Examples**
     * 1. Removes a tag which contains `tvessaiprod.nbcuni.com/video/`, from all requests
     *     ```
     *     example.org#%#//scriptlet('m3u-prune', 'tvessaiprod.nbcuni.com/video/')
     *     ```
     *
     * 2. Removes a line which contains `tvessaiprod.nbcuni.com/video/`, only if request's URL contains `.m3u8`
     *     ```
     *     example.org#%#//scriptlet('m3u-prune', 'tvessaiprod.nbcuni.com/video/', '.m3u8')
     *     ```
     *
     * 3. Call with no arguments will log response payload and URL at the console
     *     ```
     *     example.org#%#//scriptlet('m3u-prune')
     *     ```
     *
     * 4. Call with only `urlToMatch` argument will log response payload and URL only for the matched URL
     *     ```
     *     example.org#%#//scriptlet('m3u-prune', '', '.m3u8')
     *     ```
     */
    /* eslint-enable max-len */

    function m3uPrune$1(source, propsToRemove, urlToMatch) {
      // do nothing if browser does not support fetch or Proxy (e.g. Internet Explorer)
      // https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect
      if (typeof Reflect === 'undefined' || typeof fetch === 'undefined' || typeof Proxy === 'undefined' || typeof Response === 'undefined') {
        return;
      }
      let shouldPruneResponse = false;
      const urlMatchRegexp = toRegExp(urlToMatch);
      const SEGMENT_MARKER = '#';
      const AD_MARKER = {
        ASSET: '#EXT-X-ASSET:',
        CUE: '#EXT-X-CUE:',
        CUE_IN: '#EXT-X-CUE-IN',
        DISCONTINUITY: '#EXT-X-DISCONTINUITY',
        EXTINF: '#EXTINF',
        EXTM3U: '#EXTM3U',
        SCTE35: '#EXT-X-SCTE35:'
      };
      const COMCAST_AD_MARKER = {
        AD: '-AD-',
        VAST: '-VAST-',
        VMAP_AD: '-VMAP-AD-',
        VMAP_AD_BREAK: '#EXT-X-VMAP-AD-BREAK:'
      };

      // List of tags which should not be removed
      const TAGS_ALLOWLIST = ['#EXT-X-TARGETDURATION', '#EXT-X-MEDIA-SEQUENCE', '#EXT-X-DISCONTINUITY-SEQUENCE', '#EXT-X-ENDLIST', '#EXT-X-PLAYLIST-TYPE', '#EXT-X-I-FRAMES-ONLY', '#EXT-X-MEDIA', '#EXT-X-STREAM-INF', '#EXT-X-I-FRAME-STREAM-INF', '#EXT-X-SESSION-DATA', '#EXT-X-SESSION-KEY', '#EXT-X-INDEPENDENT-SEGMENTS', '#EXT-X-START'];
      const isAllowedTag = function isAllowedTag(str) {
        return TAGS_ALLOWLIST.some(function (el) {
          return str.startsWith(el);
        });
      };

      /**
       * Sets an item in array to undefined, if it contains one of the
       * AD_MARKER: AD_MARKER.EXTINF, AD_MARKER.DISCONTINUITY
       *
       * @param {Array} lines
       * @param {number} i
       * @returns {Object} { array, index }
       */
      const pruneExtinfFromVmapBlock = function pruneExtinfFromVmapBlock(lines, i) {
        let array = lines.slice();
        let index = i;
        if (array[index].includes(AD_MARKER.EXTINF)) {
          array[index] = undefined;
          index += 1;
          if (array[index].includes(AD_MARKER.DISCONTINUITY)) {
            array[index] = undefined;
            index += 1;
            const prunedExtinf = pruneExtinfFromVmapBlock(array, index);
            array = prunedExtinf.array;
            index = prunedExtinf.index;
          }
        }
        return {
          array,
          index
        };
      };

      /**
       * Sets an item in array to undefined, if it contains one of the
       * COMCAST_AD_MARKER: COMCAST_AD_MARKER.VMAP_AD, COMCAST_AD_MARKER.VAST, COMCAST_AD_MARKER.AD
       *
       * @param {Array} lines
       * @returns {Array}
       */
      const pruneVmapBlock = function pruneVmapBlock(lines) {
        let array = lines.slice();
        for (let i = 0; i < array.length - 1; i += 1) {
          if (array[i].includes(COMCAST_AD_MARKER.VMAP_AD) || array[i].includes(COMCAST_AD_MARKER.VAST) || array[i].includes(COMCAST_AD_MARKER.AD)) {
            array[i] = undefined;
            if (array[i + 1].includes(AD_MARKER.EXTINF)) {
              i += 1;
              const prunedExtinf = pruneExtinfFromVmapBlock(array, i);
              array = prunedExtinf.array;
              // It's necessary to subtract 1 from "i",
              // otherwise one line will be skipped
              i = prunedExtinf.index - 1;
            }
          }
        }
        return array;
      };

      /**
       * Sets an item in array to undefined, if it contains one of the
       * AD_MARKER: AD_MARKER.CUE, AD_MARKER.ASSET, AD_MARKER.SCTE35, AD_MARKER.CUE_IN
       *
       * @param {string} line
       * @param {number} index
       * @param {Array} array
       * @returns {string|undefined}
       */

      const pruneSpliceoutBlock = function pruneSpliceoutBlock(line, index, array) {
        if (!line.startsWith(AD_MARKER.CUE)) {
          return line;
        }
        line = undefined;
        index += 1;
        if (array[index].startsWith(AD_MARKER.ASSET)) {
          array[index] = undefined;
          index += 1;
        }
        if (array[index].startsWith(AD_MARKER.SCTE35)) {
          array[index] = undefined;
          index += 1;
        }
        if (array[index].startsWith(AD_MARKER.CUE_IN)) {
          array[index] = undefined;
          index += 1;
        }
        if (array[index].startsWith(AD_MARKER.SCTE35)) {
          array[index] = undefined;
        }
        return line;
      };
      const removeM3ULineRegexp = toRegExp(propsToRemove);

      /**
       * Sets an item in array to undefined, if it contains removeM3ULineRegexp and one of the
       * AD_MARKER: AD_MARKER.EXTINF, AD_MARKER.DISCONTINUITY
       *
       * @param {string} line
       * @param {number} index
       * @param {Array} array
       * @returns {string|undefined}
       */

      const pruneInfBlock = function pruneInfBlock(line, index, array) {
        if (!line.startsWith(AD_MARKER.EXTINF)) {
          return line;
        }
        if (!removeM3ULineRegexp.test(array[index + 1])) {
          return line;
        }
        if (!isAllowedTag(array[index])) {
          array[index] = undefined;
        }
        index += 1;
        if (!isAllowedTag(array[index])) {
          array[index] = undefined;
        }
        index += 1;
        if (array[index].startsWith(AD_MARKER.DISCONTINUITY)) {
          array[index] = undefined;
        }
        return line;
      };

      /**
       * Removes block of segments (if it contains removeM3ULineRegexp) until another segment occurs
       *
       * @param {Array} lines
       * @returns {Array}
       */
      const pruneSegments = function pruneSegments(lines) {
        for (let i = 0; i < lines.length - 1; i += 1) {
          var _lines$i;
          if ((_lines$i = lines[i]) !== null && _lines$i !== void 0 && _lines$i.startsWith(SEGMENT_MARKER) && removeM3ULineRegexp.test(lines[i])) {
            const segmentName = lines[i].substring(0, lines[i].indexOf(':'));
            if (!segmentName) {
              return lines;
            }
            lines[i] = undefined;
            i += 1;
            for (let j = i; j < lines.length; j += 1) {
              if (!lines[j].includes(segmentName) && !isAllowedTag(lines[j])) {
                lines[j] = undefined;
              } else {
                i = j - 1;
                break;
              }
            }
          }
        }
        return lines;
      };

      /**
       * Determines if text contains "#EXTM3U" or "VMAP_AD_BREAK"
       *
       * @param {*} text
       * @returns {boolean}
       */
      const isM3U = function isM3U(text) {
        if (typeof text === 'string') {
          // Check if "text" starts with "#EXTM3U" or with "VMAP_AD_BREAK"
          // If so, then it might be an M3U file and should be pruned or logged
          const trimmedText = text.trim();
          return trimmedText.startsWith(AD_MARKER.EXTM3U) || trimmedText.startsWith(COMCAST_AD_MARKER.VMAP_AD_BREAK);
        }
        return false;
      };

      /**
       * Determines if pruning is needed
       *
       * @param {string} text
       * @param {RegExp} regexp
       * @returns {boolean}
       */
      const isPruningNeeded = function isPruningNeeded(text, regexp) {
        return isM3U(text) && regexp.test(text);
      };

      /**
       * Prunes lines which contain removeM3ULineRegexp and specific AD_MARKER
       *
       * @param {string} text
       * @returns {string}
       */
      // TODO: make it compatible with $hls modifier
      const pruneM3U = function pruneM3U(text) {
        let lines = text.split(/\n\r|\n|\r/);
        if (text.includes(COMCAST_AD_MARKER.VMAP_AD_BREAK)) {
          lines = pruneVmapBlock(lines);
          return lines.filter(function (l) {
            return !!l;
          }).join('\n');
        }
        lines = pruneSegments(lines);
        return lines.map(function (line, index, array) {
          if (typeof line === 'undefined') {
            return line;
          }
          line = pruneSpliceoutBlock(line, index, array);
          if (typeof line !== 'undefined') {
            line = pruneInfBlock(line, index, array);
          }
          return line;
        }).filter(function (l) {
          return !!l;
        }).join('\n');
      };
      const xhrWrapper = function xhrWrapper(target, thisArg, args) {
        const xhrURL = args[1];
        if (typeof xhrURL !== 'string' || xhrURL.length === 0) {
          return Reflect.apply(target, thisArg, args);
        }
        if (urlMatchRegexp.test(xhrURL)) {
          thisArg.addEventListener('readystatechange', function pruneResponse() {
            if (thisArg.readyState === 4) {
              const response = thisArg.response;
              thisArg.removeEventListener('readystatechange', pruneResponse);
              // If "propsToRemove" is not defined, then response should be logged only
              if (!propsToRemove) {
                if (isM3U(response)) {
                  const message = "XMLHttpRequest.open() URL: ".concat(xhrURL, "\nresponse: ").concat(response);
                  logMessage(source, message);
                }
              } else {
                shouldPruneResponse = isPruningNeeded(response, removeM3ULineRegexp);
              }
              if (shouldPruneResponse) {
                const prunedResponseContent = pruneM3U(response);
                Object.defineProperty(thisArg, 'response', {
                  value: prunedResponseContent
                });
                Object.defineProperty(thisArg, 'responseText', {
                  value: prunedResponseContent
                });
                hit(source);
              }
            }
          });
        }
        return Reflect.apply(target, thisArg, args);
      };
      const xhrHandler = {
        apply: xhrWrapper
      };
      // eslint-disable-next-line max-len
      window.XMLHttpRequest.prototype.open = new Proxy(window.XMLHttpRequest.prototype.open, xhrHandler);
      const nativeFetch = window.fetch;
      const fetchWrapper = async function fetchWrapper(target, thisArg, args) {
        const fetchURL = args[0] instanceof Request ? args[0].url : args[0];
        if (typeof fetchURL !== 'string' || fetchURL.length === 0) {
          return Reflect.apply(target, thisArg, args);
        }
        if (urlMatchRegexp.test(fetchURL)) {
          const response = await nativeFetch(...args);
          const responseText = await response.text();
          // If "propsToRemove" is not defined, then response should be logged only
          if (!propsToRemove && isM3U(responseText)) {
            const message = "fetch URL: ".concat(fetchURL, "\nresponse text: ").concat(responseText);
            logMessage(source, message);
            return Reflect.apply(target, thisArg, args);
          }
          if (isPruningNeeded(responseText, removeM3ULineRegexp)) {
            const prunedText = pruneM3U(responseText);
            hit(source);
            return new Response(prunedText, {
              status: response.status,
              statusText: response.statusText,
              headers: response.headers
            });
          }
          return Reflect.apply(target, thisArg, args);
        }
        return Reflect.apply(target, thisArg, args);
      };
      const fetchHandler = {
        apply: fetchWrapper
      };
      window.fetch = new Proxy(window.fetch, fetchHandler);
    }
    m3uPrune$1.names = ['m3u-prune',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'm3u-prune.js', 'ubo-m3u-prune.js', 'ubo-m3u-prune'];
    m3uPrune$1.injections = [hit, toRegExp, logMessage];

    /* eslint-disable max-len */
    /**
     * @trustedScriptlet trusted-set-cookie
     * @description
     * Sets a cookie with arbitrary name and value,
     * and with optional ability to offset cookie attribute 'expires' and set path.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('trusted-set-cookie', name, value[, offsetExpiresSec[, path]])
     * ```
     *
     * - `name`  required, cookie name to be set
     * - `value`  required, cookie value. Possible values:
     *   - arbitrary value
     *   - empty string for no value
     *   - `$now$` keyword for setting current time in ms, e.g 1667915146503
     *   - `$currentDate$` keyword for setting current time as string, e.g 'Tue Nov 08 2022 13:53:19 GMT+0300'
     * - `offsetExpiresSec`  optional, offset from current time in seconds, after which cookie should expire; defaults to no offset
     * Possible values:
     *   - positive integer in seconds
     *   - `1year` keyword for setting expiration date to one year
     *   - `1day` keyword for setting expiration date to one day
     * - `path`  optional, argument for setting cookie path, defaults to `/`; possible values:
     *   - `/`  root path
     *   - `none`  to set no path at all
     *
     * **Examples**
     * 1. Set cookie
     * ```
     * example.org#%#//scriptlet('trusted-set-cookie', 'cmpconsent', 'accept')
     * example.org#%#//scriptlet('trusted-set-cookie', 'cmpconsent', '1-accept_1')
     * ```
     *
     * 2. Set cookie with `new Date().getTime()` value
     * ```
     * example.org#%#//scriptlet('trusted-set-cookie', 'cmpconsent', '$now$')
     * ```
     *
     * 3. Set cookie which will expire in 3 days
     * ```
     * example.org#%#//scriptlet('trusted-set-cookie', 'cmpconsent', 'accept', '259200')
     * ```
     *
     * 4. Set cookie which will expire in one year
     * ```
     * example.org#%#//scriptlet('trusted-set-cookie', 'cmpconsent', 'accept', '1year')
     * ```
     *
     * 5. Set cookie with no path
     * ```
     * example.org#%#//scriptlet('trusted-set-cookie', 'cmpconsent', 'decline', '', 'none')
     * ```
     */
    /* eslint-enable max-len */

    function trustedSetCookie$1(source, name, value) {
      let offsetExpiresSec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      let path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '/';
      if (typeof name === 'undefined') {
        logMessage(source, 'Cookie name should be specified');
        return;
      }
      if (typeof value === 'undefined') {
        logMessage(source, 'Cookie value should be specified');
        return;
      }
      const parsedValue = parseKeywordValue(value);
      if (!isValidCookiePath(path)) {
        logMessage(source, "Invalid cookie path: '".concat(path, "'"));
        return;
      }
      let cookieToSet = concatCookieNameValuePath(name, parsedValue, path);
      if (!cookieToSet) {
        return;
      }
      if (offsetExpiresSec) {
        const parsedOffsetMs = getTrustedCookieOffsetMs(offsetExpiresSec);
        if (!parsedOffsetMs) {
          logMessage(source, "Invalid offsetExpiresSec value: ".concat(offsetExpiresSec));
          return;
        }
        const expires = Date.now() + parsedOffsetMs;
        cookieToSet += " expires=".concat(new Date(expires).toUTCString(), ";");
      }
      document.cookie = cookieToSet;
      hit(source);
    }
    trustedSetCookie$1.names = ['trusted-set-cookie'
    // trusted scriptlets support no aliases
    ];

    trustedSetCookie$1.injections = [hit, logMessage, nativeIsNaN, isCookieSetWithValue, concatCookieNameValuePath, isValidCookiePath, getTrustedCookieOffsetMs, parseKeywordValue, getCookiePath];

    /* eslint-disable max-len */
    /**
     * @trustedScriptlet trusted-set-cookie-reload
     * @description
     * Sets a cookie with arbitrary name and value,
     * and with optional ability to offset cookie attribute 'expires' and set path.
     * Also reloads the current page after the cookie setting.
     * If reloading option is not needed, use the [`trusted-set-cookie` scriptlet](#trusted-set-cookie).
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('trusted-set-cookie-reload', name, value[, offsetExpiresSec[, path]])
     * ```
     *
     * - `name`  required, cookie name to be set
     * - `value`  required, cookie value. Possible values:
     *   - arbitrary value
     *   - empty string for no value
     *   - `$now$` keyword for setting current time in ms, e.g 1667915146503
     *   - `$currentDate$` keyword for setting current time as string, e.g 'Tue Nov 08 2022 13:53:19 GMT+0300'
     * - `offsetExpiresSec`  optional, offset from current time in seconds, after which cookie should expire; defaults to no offset
     * Possible values:
     *   - positive integer in seconds
     *   - `1year` keyword for setting expiration date to one year
     *   - `1day` keyword for setting expiration date to one day
     * - `path`  optional, argument for setting cookie path, defaults to `/`; possible values:
     *   - `/`  root path
     *   - `none`  to set no path at all
     *
     * **Examples**
     * 1. Set cookie and reload the page after it
     * ```
     * example.org#%#//scriptlet('trusted-set-cookie-reload', 'cmpconsent', 'accept')
     * ```
     *
     * 2. Set cookie with `new Date().getTime()` value and reload the page after it
     * ```
     * example.org#%#//scriptlet('trusted-set-cookie-reload', 'cmpconsent', '$now$')
     * ```
     *
     * 3. Set cookie which will expire in 3 days and reload the page after it
     * ```
     * example.org#%#//scriptlet('trusted-set-cookie-reload', 'cmpconsent', 'accept', '259200')
     * ```
     *
     * 4. Set cookie which will expire in one year and reload the page after it
     * ```
     * example.org#%#//scriptlet('trusted-set-cookie-reload', 'cmpconsent', 'accept', '1year')
     * ```
     *
     * 5. Set cookie with no 'expire' and no path, reload the page after it
     * ```
     * example.org#%#//scriptlet('trusted-set-cookie-reload', 'cmpconsent', 'decline', '', 'none')
     * ```
     */
    /* eslint-enable max-len */

    function trustedSetCookieReload$1(source, name, value) {
      let offsetExpiresSec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      let path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '/';
      if (typeof name === 'undefined') {
        logMessage(source, 'Cookie name should be specified');
        return;
      }
      if (typeof value === 'undefined') {
        logMessage(source, 'Cookie value should be specified');
        return;
      }

      // Prevent infinite reloads if cookie was already set or blocked by the browser
      // https://github.com/AdguardTeam/Scriptlets/issues/212
      if (isCookieSetWithValue(document.cookie, name, value)) {
        return;
      }
      const parsedValue = parseKeywordValue(value);
      if (!isValidCookiePath(path)) {
        logMessage(source, "Invalid cookie path: '".concat(path, "'"));
        return;
      }
      let cookieToSet = concatCookieNameValuePath(name, parsedValue, path);
      if (!cookieToSet) {
        return;
      }
      if (offsetExpiresSec) {
        const parsedOffsetMs = getTrustedCookieOffsetMs(offsetExpiresSec);
        if (!parsedOffsetMs) {
          logMessage(source, "Invalid offsetExpiresSec value: ".concat(offsetExpiresSec));
          return;
        }
        const expires = Date.now() + parsedOffsetMs;
        cookieToSet += " expires=".concat(new Date(expires).toUTCString(), ";");
      }
      document.cookie = cookieToSet;
      hit(source);

      // Only reload the page if cookie was set
      // https://github.com/AdguardTeam/Scriptlets/issues/212
      if (isCookieSetWithValue(document.cookie, name, value)) {
        window.location.reload();
      }
    }
    trustedSetCookieReload$1.names = ['trusted-set-cookie-reload'
    // trusted scriptlets support no aliases
    ];

    trustedSetCookieReload$1.injections = [hit, logMessage, nativeIsNaN, isCookieSetWithValue, concatCookieNameValuePath, isValidCookiePath, getTrustedCookieOffsetMs, parseKeywordValue, getCookiePath];

    /* eslint-disable max-len */
    /**
     * @trustedScriptlet trusted-replace-fetch-response
     * @description
     * Replaces response text content of `fetch` requests if **all** given parameters match.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('trusted-replace-fetch-response'[, pattern, replacement[, propsToMatch]])
     * ```
     *
     * - `pattern`  optional, argument for matching contents of responseText that should be replaced. If set, `replacement` is required;
     * possible values:
     *   - `*` to match all text content
     *   - non-empty string
     *   - regular expression
     * - `replacement`  optional, should be set if `pattern` is set. String to replace the response text content matched by `pattern`.
     * Empty string to remove content. Defaults to empty string.
     * - `propsToMatch`  optional, string of space-separated properties to match; possible props:
     *   - string or regular expression for matching the URL passed to fetch call; empty string, wildcard `*` or invalid regular expression will match all fetch calls
     *   - colon-separated pairs `name:value` where
     *     - `name` is [`init` option name](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#parameters)
     *     - `value` is string or regular expression for matching the value of the option passed to fetch call; invalid regular expression will cause any value matching
     *
     * > Usage with no arguments will log fetch calls to browser console;
     * which is useful for debugging but only allowed for production filter lists.
     *
     * > Scriptlet does nothing if response body can't be converted to text.
     *
     * **Examples**
     * 1. Log all fetch calls
     *     ```
     *     example.org#%#//scriptlet('trusted-replace-fetch-response')
     *     ```
     *
     * 2. Replace response text content of fetch requests with specific url
     *     ```
     *     example.org#%#//scriptlet('trusted-replace-fetch-response', 'adb_detect:true', 'adb_detect:false', 'example.org')
     *     example.org#%#//scriptlet('trusted-replace-fetch-response', '/#EXT-X-VMAP-AD-BREAK[\s\S]*?/', '#EXT-X-ENDLIST', 'example.org')
     *     ```
     *
     * 3. Remove all text content of fetch responses with specific request method
     *     ```
     *     example.org#%#//scriptlet('trusted-replace-fetch-response', '*', '', 'method:GET')
     *     ```
     *
     * 4. Replace response text content of fetch requests matching by URL regex and request methods
     *     ```
     *     example.org#%#//scriptlet('trusted-replace-fetch-response', '/#EXT-X-VMAP-AD-BREAK[\s\S]*?/', '#EXT-X-ENDLIST', '/\.m3u8/ method:/GET|HEAD/')
     *     ```
     * 5. Remove text content of all fetch responses for example.com
     *     ```
     *     example.org#%#//scriptlet('trusted-replace-fetch-response', '*', '', 'example.com')
     *     ```
     */
    /* eslint-enable max-len */
    function trustedReplaceFetchResponse$1(source) {
      let pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      let replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      let propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      // do nothing if browser does not support fetch or Proxy (e.g. Internet Explorer)
      // https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
      if (typeof fetch === 'undefined' || typeof Proxy === 'undefined' || typeof Response === 'undefined') {
        return;
      }

      // Only allow pattern as empty string for logging purposes
      if (pattern === '' && replacement !== '') {
        logMessage(source, 'Pattern argument should not be empty string');
        return;
      }
      const shouldLog = pattern === '' && replacement === '';
      const nativeFetch = fetch;
      let shouldReplace = false;
      let fetchData;
      const handlerWrapper = function handlerWrapper(target, thisArg, args) {
        fetchData = getFetchData(args);
        if (shouldLog) {
          // log if no propsToMatch given
          logMessage(source, "fetch( ".concat(objectToString(fetchData), " )"), true);
          hit(source);
          return Reflect.apply(target, thisArg, args);
        }
        shouldReplace = matchRequestProps(source, propsToMatch, fetchData);
        if (!shouldReplace) {
          return Reflect.apply(target, thisArg, args);
        }

        /**
         * Create new Response object using original response' properties
         * and given text as body content
         *
         * @param {Response} response original response to copy properties from
         * @param {string} textContent text to set as body content
         * @returns {Response}
         */
        const forgeResponse = function forgeResponse(response, textContent) {
          const bodyUsed = response.bodyUsed,
            headers = response.headers,
            ok = response.ok,
            redirected = response.redirected,
            status = response.status,
            statusText = response.statusText,
            type = response.type,
            url = response.url;
          const forgedResponse = new Response(textContent, {
            status,
            statusText,
            headers
          });

          // Manually set properties which can't be set by Response constructor
          Object.defineProperties(forgedResponse, {
            url: {
              value: url
            },
            type: {
              value: type
            },
            ok: {
              value: ok
            },
            bodyUsed: {
              value: bodyUsed
            },
            redirected: {
              value: redirected
            }
          });
          return forgedResponse;
        };

        // eslint-disable-next-line prefer-spread
        return nativeFetch.apply(null, args).then(function (response) {
          return response.text().then(function (bodyText) {
            const patternRegexp = pattern === '*' ? /(\n|.)*/ : toRegExp(pattern);
            const modifiedTextContent = bodyText.replace(patternRegexp, replacement);
            const forgedResponse = forgeResponse(response, modifiedTextContent);
            hit(source);
            return forgedResponse;
          }).catch(function () {
            // log if response body can't be converted to a string
            const fetchDataStr = objectToString(fetchData);
            const message = "Response body can't be converted to text: ".concat(fetchDataStr);
            logMessage(source, message);
            return Reflect.apply(target, thisArg, args);
          });
        }).catch(function () {
          return Reflect.apply(target, thisArg, args);
        });
      };
      const fetchHandler = {
        apply: handlerWrapper
      };
      fetch = new Proxy(fetch, fetchHandler); // eslint-disable-line no-global-assign
    }

    trustedReplaceFetchResponse$1.names = ['trusted-replace-fetch-response'];
    trustedReplaceFetchResponse$1.injections = [hit, logMessage, getFetchData, objectToString, matchRequestProps, toRegExp, isValidStrPattern, escapeRegExp, isEmptyObject, getRequestData, getRequestProps, getObjectEntries, getObjectFromEntries, parseMatchProps, validateParsedData, getMatchPropsData];

    /* eslint-disable max-len */
    /**
     * @trustedScriptlet trusted-set-local-storage-item
     * @description
     * Adds item with arbitrary key and value to localStorage object, or updates the value of the key if it already exists.
     * Scriptlet won't set item if storage is full.
     *
     * **Syntax**
     * ```
     * example.com#%#//scriptlet('trusted-set-local-storage-item', 'key', 'value')
     * ```
     *
     * - `key`  required, key name to be set.
     * - `value`  required, key value; possible values:
     *   - arbitrary value
     *   - `$now$` keyword for setting current time in ms, corresponds to `Date.now()` and `(new Date).getTime()` calls
     *   - `$currentDate$` keyword for setting string representation of the current date and time, corresponds to `Date()` and `(new Date).toString()` calls
     *
     * **Examples**
     * 1. Set local storage item
     * ```
     * example.org#%#//scriptlet('trusted-set-local-storage-item', 'player.live.current.mute', 'false')
     *
     * example.org#%#//scriptlet('trusted-set-local-storage-item', 'COOKIE_CONSENTS', '{"preferences":3,"marketing":false}')
     *
     * example.org#%#//scriptlet('trusted-set-local-storage-item', 'providers', '[16364,88364]')
     *
     * example.org#%#//scriptlet('trusted-set-local-storage-item', 'providers', '{"providers":[16364,88364],"consent":"all"}')
     * ```
     *
     * 2. Set item with current time since unix epoch in ms
     * ```
     * example.org#%#//scriptlet('trusted-set-local-storage-item', 'player.live.current.play', '$now$')
     * ```
     *
     * 3. Set item with current date, e.g 'Tue Nov 08 2022 13:53:19 GMT+0300'
     * ```
     * example.org#%#//scriptlet('trusted-set-local-storage-item', 'player.live.current.play', '$currentDate$')
     * ```
     *
     * 4. Set item without value
     * ```
     * example.org#%#//scriptlet('trusted-set-local-storage-item', 'ppu_main_none', '')
     * ```
     */
    /* eslint-enable max-len */

    function trustedSetLocalStorageItem$1(source, key, value) {
      if (typeof key === 'undefined') {
        logMessage(source, 'Item key should be specified');
        return;
      }
      if (typeof value === 'undefined') {
        logMessage(source, 'Item value should be specified');
        return;
      }
      const parsedValue = parseKeywordValue(value);
      const _window = window,
        localStorage = _window.localStorage;
      setStorageItem(source, localStorage, key, parsedValue);
      hit(source);
    }
    trustedSetLocalStorageItem$1.names = ['trusted-set-local-storage-item'
    // trusted scriptlets support no aliases
    ];

    trustedSetLocalStorageItem$1.injections = [hit, logMessage, nativeIsNaN, setStorageItem, parseKeywordValue];

    /* eslint-disable max-len */
    /**
     * @trustedScriptlet trusted-set-constant
     * @description
     * Creates a constant property and assigns it a specified value.
     *
     * > Actually, it's not a constant. Please note, that it can be rewritten with a value of a different type.
     *
     * > If empty object is present in chain it will be trapped until chain leftovers appear.
     *
     * > Use [set-constant](./about-scriptlets.md#set-constant) to set predefined values and functions.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('trusted-set-constant', property, value[, stack])
     * ```
     *
     * - `property`  required, path to a property (joined with `.` if needed). The property must be attached to `window`.
     * - `value`  required, an arbitrary value to be set; value type is being inferred from the argument, e.g '500' will be set as number;
     * to set string type value wrap argument into another pair of quotes: `'"500"'`;
     * - `stack`  optional, string or regular expression that must match the current function call stack trace;
     * if regular expression is invalid it will be skipped
     *
     * **Examples**
     * 1. Set property values of different types
     * ```
     * ! Set string value wrapping argument into another pair of quotes
     * example.org#%#//scriptlet('trusted-set-constant', 'click_r', '"null"')
     *
     *  window.click_r === 'null'
     *  typeof window.click_r === 'string'
     *
     * ! Set inferred null value
     * example.org#%#//scriptlet('trusted-set-constant', 'click_r', 'null')
     *
     *  window.click_r === null
     *  typeof window.click_r === 'object'
     *
     * ! Set number type value
     * example.org#%#//scriptlet('trusted-set-constant', 'click_r', '48')
     *
     *  window.click_r === 48
     *  typeof window.click_r === 'number'
     *
     * ! Set array or object as property value, argument should be a JSON string
     * example.org#%#//scriptlet('trusted-set-constant', 'click_r', '[1,"string"]')
     * example.org#%#//scriptlet('trusted-set-constant', 'click_r', '{"aaa":123,"bbb":{"ccc":"string"}}')
     * ```
     *
     * 2. Use script stack matching to set value
     * ```
     * ! `document.first` will return `1` if the method is related to `checking.js`
     * example.org#%#//scriptlet('trusted-set-constant', 'document.first', '1', 'checking.js')
     *
     *  document.first === 1  // if the condition described above is met
     * ```
     */
    /* eslint-enable max-len */
    function trustedSetConstant$1(source, property, value, stack) {
      if (!property || !matchStackTrace(stack, new Error().stack)) {
        return;
      }
      let constantValue;
      try {
        constantValue = inferValue(value);
      } catch (e) {
        logMessage(source, e);
        return;
      }
      let canceled = false;
      const mustCancel = function mustCancel(value) {
        if (canceled) {
          return canceled;
        }
        canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue && value !== null;
        return canceled;
      };

      /**
       * Safely sets property on a given object
       *
       * IMPORTANT! this duplicates corresponding func in set-constant scriptlet as
       * reorganizing this to common helpers will most definitely complicate debugging
       *
       * @param {Object} base arbitrary reachable object
       * @param {string} prop property name
       * @param {boolean} configurable if set property should be configurable
       * @param {Object} handler custom property descriptor object
       * @returns {boolean} true if prop was trapped successfully
       */
      const trapProp = function trapProp(base, prop, configurable, handler) {
        if (!handler.init(base[prop])) {
          return false;
        }
        const origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
        let prevSetter;
        // This is required to prevent scriptlets overwrite each over
        if (origDescriptor instanceof Object) {
          // This check is required to avoid defining non-configurable props
          if (!origDescriptor.configurable) {
            const message = "Property '".concat(prop, "' is not configurable");
            logMessage(source, message);
            return false;
          }
          base[prop] = constantValue;
          if (origDescriptor.set instanceof Function) {
            prevSetter = origDescriptor.set;
          }
        }
        Object.defineProperty(base, prop, {
          configurable,
          get() {
            return handler.get();
          },
          set(a) {
            if (prevSetter !== undefined) {
              prevSetter(a);
            }
            handler.set(a);
          }
        });
        return true;
      };

      /**
       * Traverses given chain to set constant value to its end prop
       * Chains that yet include non-object values (e.g null) are valid and will be
       * traversed when appropriate chain member is set by an external script
       *
       * IMPORTANT! this duplicates corresponding func in set-constant scriptlet as
       * reorganizing this to common helpers will most definitely complicate debugging
       *
       * @param {Object} owner object that owns chain
       * @param {string} property chain of owner properties
       */
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        const base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;

        // Handler method init is used to keep track of factual value
        // and apply mustCancel() check only on end prop
        const inChainPropHandler = {
          factValue: undefined,
          init(a) {
            this.factValue = a;
            return true;
          },
          get() {
            return this.factValue;
          },
          set(a) {
            // Prevent breakage due to loop assignments like win.obj = win.obj
            if (this.factValue === a) {
              return;
            }
            this.factValue = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          }
        };
        const endPropHandler = {
          init(a) {
            if (mustCancel(a)) {
              return false;
            }
            return true;
          },
          get() {
            return constantValue;
          },
          set(a) {
            if (!mustCancel(a)) {
              return;
            }
            constantValue = a;
          }
        };

        // End prop case
        if (!chain) {
          const isTrapped = trapProp(base, prop, false, endPropHandler);
          if (isTrapped) {
            hit(source);
          }
          return;
        }

        // Null prop in chain
        if (base !== undefined && base[prop] === null) {
          trapProp(base, prop, true, inChainPropHandler);
          return;
        }

        // Empty object prop in chain
        if ((base instanceof Object || typeof base === 'object') && isEmptyObject(base)) {
          trapProp(base, prop, true, inChainPropHandler);
        }

        // Defined prop in chain
        const propValue = owner[prop];
        if (propValue instanceof Object || typeof propValue === 'object' && propValue !== null) {
          setChainPropAccess(propValue, chain);
        }

        // Undefined prop in chain
        trapProp(base, prop, true, inChainPropHandler);
      };
      setChainPropAccess(window, property);
    }
    trustedSetConstant$1.names = ['trusted-set-constant'
    // trusted scriptlets support no aliases
    ];

    trustedSetConstant$1.injections = [hit, inferValue, logMessage, noopArray, noopObject, noopFunc, noopCallbackFunc, trueFunc, falseFunc, throwFunc, noopPromiseReject, noopPromiseResolve, getPropertyInChain, setPropertyAccess, toRegExp, matchStackTrace, nativeIsNaN, isEmptyObject, getNativeRegexpTest,
    // following helpers should be imported and injected
    // because they are used by helpers above
    shouldAbortInlineOrInjectedScript];

    /* eslint-disable max-len */
    /**
     * @scriptlet inject-css-in-shadow-dom
     * @description
     * Injects CSS rule into selected Shadow DOM subtrees on a page
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('inject-css-in-shadow-dom', cssRule[, hostSelector])
     * ```
     *
     * - `cssRule`  required, string representing a single css rule
     * - `hostSelector`  optional, string, selector to match shadow host elements. CSS rule will be only applied to shadow roots inside these elements.
     * Defaults to injecting css rule into all available roots.
     *
     * **Examples**
     * 1. Apply style to all shadow dom subtrees
     * ```
     * example.org#%#//scriptlet('inject-css-in-shadow-dom', '#advertisement { display: none !important; }')
     * ```
     *
     * 2. Apply style to a specific shadow dom subtree
     * ```
     * example.org#%#//scriptlet('inject-css-in-shadow-dom', '#content { margin-top: 0 !important; }', '.row > #hidden')
     * ```
     */
    /* eslint-enable max-len */

    function injectCssInShadowDom$1(source, cssRule) {
      let hostSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      // do nothing if browser does not support ShadowRoot, Proxy or Reflect
      // https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot
      if (!Element.prototype.attachShadow || typeof Proxy === 'undefined' || typeof Reflect === 'undefined') {
        return;
      }

      // Prevent url() and image-set() styles from being applied
      if (cssRule.match(/(url|image-set)\(.*\)/i)) {
        logMessage(source, '"url()" function is not allowed for css rules');
        return;
      }
      const callback = function callback(shadowRoot) {
        try {
          // adoptedStyleSheets and CSSStyleSheet constructor are not yet supported by Safari
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/adoptedStyleSheets
          // https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/CSSStyleSheet
          const stylesheet = new CSSStyleSheet();
          try {
            stylesheet.insertRule(cssRule);
          } catch (e) {
            logMessage(source, "Unable to apply the rule '".concat(cssRule, "' due to: \n'").concat(e.message, "'"));
            return;
          }
          shadowRoot.adoptedStyleSheets = [...shadowRoot.adoptedStyleSheets, stylesheet];
        } catch (_unused) {
          const styleTag = document.createElement('style');
          styleTag.innerText = cssRule;
          shadowRoot.appendChild(styleTag);
        }
        hit(source);
      };
      hijackAttachShadow(window, hostSelector, callback);
    }
    injectCssInShadowDom$1.names = ['inject-css-in-shadow-dom'];
    injectCssInShadowDom$1.injections = [hit, logMessage, hijackAttachShadow];

    /**
     * This file must export all scriptlets which should be accessible
     */

    var scriptletList = /*#__PURE__*/Object.freeze({
        __proto__: null,
        trustedClickElement: trustedClickElement$1,
        abortOnPropertyRead: abortOnPropertyRead$1,
        abortOnPropertyWrite: abortOnPropertyWrite$1,
        preventSetTimeout: preventSetTimeout$1,
        preventSetInterval: preventSetInterval$1,
        preventWindowOpen: preventWindowOpen$1,
        abortCurrentInlineScript: abortCurrentInlineScript$1,
        setConstant: setConstant$1,
        removeCookie: removeCookie$1,
        preventAddEventListener: preventAddEventListener$1,
        preventBab: preventBab$2,
        nowebrtc: nowebrtc$1,
        logAddEventListener: logAddEventListener$1,
        logEval: logEval$1,
        log: log$1,
        noeval: noeval$1,
        preventEvalIf: preventEvalIf$1,
        preventFab: preventFab$1,
        setPopadsDummy: setPopadsDummy$1,
        preventPopadsNet: preventPopadsNet$1,
        preventAdfly: preventAdfly$1,
        debugOnPropertyRead: debugOnPropertyRead$1,
        debugOnPropertyWrite: debugOnPropertyWrite$1,
        debugCurrentInlineScript: debugCurrentInlineScript$1,
        removeAttr: removeAttr$1,
        setAttr: setAttr$1,
        removeClass: removeClass$1,
        disableNewtabLinks: disableNewtabLinks$1,
        adjustSetInterval: adjustSetInterval$1,
        adjustSetTimeout: adjustSetTimeout$1,
        dirString: dirString$1,
        jsonPrune: jsonPrune$1,
        preventRequestAnimationFrame: preventRequestAnimationFrame$1,
        setCookie: setCookie$1,
        setCookieReload: setCookieReload$1,
        hideInShadowDom: hideInShadowDom$1,
        removeInShadowDom: removeInShadowDom$1,
        preventFetch: preventFetch$1,
        setLocalStorageItem: setLocalStorageItem$1,
        setSessionStorageItem: setSessionStorageItem$1,
        abortOnStackTrace: abortOnStackTrace$1,
        logOnStacktrace: logOnStacktrace$1,
        preventXHR: preventXHR$1,
        forceWindowClose: forceWindowClose$1,
        preventRefresh: preventRefresh$1,
        preventElementSrcLoading: preventElementSrcLoading$1,
        noTopics: noTopics$1,
        trustedReplaceXhrResponse: trustedReplaceXhrResponse$1,
        xmlPrune: xmlPrune$1,
        m3uPrune: m3uPrune$1,
        trustedSetCookie: trustedSetCookie$1,
        trustedSetCookieReload: trustedSetCookieReload$1,
        trustedReplaceFetchResponse: trustedReplaceFetchResponse$1,
        trustedSetLocalStorageItem: trustedSetLocalStorageItem$1,
        trustedSetConstant: trustedSetConstant$1,
        injectCssInShadowDom: injectCssInShadowDom$1
    });

    /**
     * Store of ADG redirects names and their analogs.
     * As it is not a compatibility table, no need to keep in redirects array third-party redirects.
     *
     * Needed only for conversion purposes.
     * e.g. googletagmanager-gtm is removed and should be removed from compatibility table as well
     * but now it works as alias for google-analytics so it should stay valid for compiler
     */
    const redirects$1 = [{
      adg: '1x1-transparent.gif',
      ubo: '1x1.gif',
      abp: '1x1-transparent-gif'
    }, {
      adg: '2x2-transparent.png',
      ubo: '2x2.png',
      abp: '2x2-transparent-png'
    }, {
      adg: '3x2-transparent.png',
      ubo: '3x2.png',
      abp: '3x2-transparent-png'
    }, {
      adg: '32x32-transparent.png',
      ubo: '32x32.png',
      abp: '32x32-transparent-png'
    }, {
      adg: 'amazon-apstag',
      ubo: 'amazon_apstag.js'
    }, {
      adg: 'ati-smarttag'
    }, {
      adg: 'didomi-loader'
    }, {
      adg: 'click2load.html',
      ubo: 'click2load.html'
    }, {
      adg: 'fingerprintjs2',
      ubo: 'fingerprint2.js'
    }, {
      adg: 'fingerprintjs3',
      ubo: 'fingerprint3.js'
    }, {
      adg: 'google-analytics',
      ubo: 'google-analytics_analytics.js'
    }, {
      adg: 'google-analytics-ga',
      ubo: 'google-analytics_ga.js'
    }, {
      adg: 'googlesyndication-adsbygoogle',
      ubo: 'googlesyndication_adsbygoogle.js'
    }, {
      // https://github.com/AdguardTeam/Scriptlets/issues/162
      adg: 'googlesyndication-adsbygoogle',
      ubo: 'googlesyndication.com/adsbygoogle.js'
    }, {
      // https://github.com/AdguardTeam/Scriptlets/issues/127
      adg: 'googletagmanager-gtm',
      ubo: 'google-analytics_ga.js'
    }, {
      // https://github.com/AdguardTeam/Scriptlets/issues/260
      adg: 'googletagmanager-gtm',
      ubo: 'googletagmanager_gtm.js'
    }, {
      adg: 'googletagservices-gpt',
      ubo: 'googletagservices_gpt.js'
    }, {
      adg: 'google-ima3',
      ubo: 'google-ima.js'
    }, {
      adg: 'gemius'
    }, {
      adg: 'matomo'
    }, {
      adg: 'metrika-yandex-watch'
    }, {
      adg: 'metrika-yandex-tag'
    }, {
      adg: 'naver-wcslog'
    }, {
      adg: 'noeval',
      ubo: 'noeval-silent.js'
    }, {
      adg: 'noopcss',
      ubo: 'noop.css',
      abp: 'blank-css'
    }, {
      adg: 'noopframe',
      ubo: 'noop.html',
      abp: 'blank-html'
    }, {
      adg: 'noopjs',
      ubo: 'noop.js',
      abp: 'blank-js'
    }, {
      adg: 'noopjson'
    }, {
      adg: 'nooptext',
      ubo: 'noop.txt',
      abp: 'blank-text'
    }, {
      adg: 'noopmp3-0.1s',
      ubo: 'noop-0.1s.mp3',
      abp: 'blank-mp3'
    }, {
      adg: 'noopmp4-1s',
      ubo: 'noop-1s.mp4',
      abp: 'blank-mp4'
    }, {
      adg: 'noopvmap-1.0',
      ubo: 'noop-vmap1.0.xml'
    }, {
      adg: 'noopvast-2.0'
    }, {
      adg: 'noopvast-3.0'
    }, {
      adg: 'noopvast-4.0'
    }, {
      adg: 'prebid'
    }, {
      adg: 'pardot-1.0'
    }, {
      adg: 'prevent-bab',
      ubo: 'nobab.js'
    }, {
      adg: 'prevent-bab2',
      ubo: 'nobab2.js'
    }, {
      adg: 'prevent-fab-3.2.0',
      ubo: 'nofab.js'
    }, {
      // AG-15917
      adg: 'prevent-fab-3.2.0',
      ubo: 'fuckadblock.js-3.2.0'
    }, {
      adg: 'prevent-popads-net',
      ubo: 'popads.js'
    }, {
      adg: 'scorecardresearch-beacon',
      ubo: 'scorecardresearch_beacon.js'
    }, {
      adg: 'set-popads-dummy',
      ubo: 'popads-dummy.js'
    }, {
      adg: 'empty',
      ubo: 'empty'
    }, {
      adg: 'prebid-ads',
      ubo: 'prebid-ads.js'
    }];

    const JS_RULE_MARKER = '#%#';
    const COMMENT_MARKER = '!';

    /**
     * Checks if rule text is comment e.g. !!example.org##+js(set-constant.js, test, false)
     *
     * @param {string} rule rule text
     * @returns {boolean} if rule text is comment
     */
    const isComment = function isComment(rule) {
      return startsWith$1(rule, COMMENT_MARKER);
    };

    /* ************************************************************************
     *
     * Scriptlets
     *
     ************************************************************************** */

    /**
     * uBlock scriptlet rule mask
     */
    const UBO_SCRIPTLET_MASK_REG = /#@?#script:inject|#@?#\s*\+js/;
    const UBO_SCRIPTLET_MASK_1 = '##+js';
    const UBO_SCRIPTLET_MASK_2 = '##script:inject';
    const UBO_SCRIPTLET_EXCEPTION_MASK_1 = '#@#+js';
    const UBO_SCRIPTLET_EXCEPTION_MASK_2 = '#@#script:inject';

    /**
     * AdBlock Plus snippet rule mask
     */
    const ABP_SCRIPTLET_MASK = '#$#';
    const ABP_SCRIPTLET_EXCEPTION_MASK = '#@$#';

    /**
     * AdGuard CSS rule mask
     */
    const ADG_CSS_MASK_REG = /#@?\$#.+?\s*\{.*\}\s*$/g;

    /**
     * Checks if the `rule` is AdGuard scriptlet rule
     *
     * @param {string} rule - rule text
     * @returns {boolean} if given rule is adg rule
     */
    const isAdgScriptletRule = function isAdgScriptletRule(rule) {
      return !isComment(rule) && rule.indexOf(ADG_SCRIPTLET_MASK) > -1;
    };

    /**
     * Checks if the `rule` is uBO scriptlet rule
     *
     * @param {string} rule rule text
     * @returns {boolean} if given rule is ubo rule
     */
    const isUboScriptletRule = function isUboScriptletRule(rule) {
      return (rule.indexOf(UBO_SCRIPTLET_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_MASK_2) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_2) > -1) && UBO_SCRIPTLET_MASK_REG.test(rule) && !isComment(rule);
    };

    /**
     * Checks if the `rule` is AdBlock Plus snippet
     *
     * @param {string} rule rule text
     * @returns {boolean} if given rule is abp rule
     */
    const isAbpSnippetRule = function isAbpSnippetRule(rule) {
      return (rule.indexOf(ABP_SCRIPTLET_MASK) > -1 || rule.indexOf(ABP_SCRIPTLET_EXCEPTION_MASK) > -1) && rule.search(ADG_CSS_MASK_REG) === -1 && !isComment(rule);
    };

    /**
     * Returns array of scriptlet objects.
     * Needed for scriptlet name validation which will check aliases names.
     *
     * @returns {Array<Object>} Array of all scriptlet objects.
     */
    const getScriptletsObjList = function getScriptletsObjList() {
      return Object.values(scriptletList);
    };

    /**
     * Finds scriptlet by the `name`.
     *
     * @param {string} name Scriptlet name.
     * @param {Array<Object>} scriptlets Array of all scriptlet objects.
     * @returns {Function} Scriptlet function.
     */
    const getScriptletByName = function getScriptletByName(name, scriptlets) {
      if (!scriptlets) {
        scriptlets = getScriptletsObjList();
      }
      return scriptlets.find(function (s) {
        return s.names
        // full match name checking
        && (s.names.indexOf(name) > -1
        // or check ubo alias name without '.js' at the end
        || !endsWith(name, '.js') && s.names.indexOf("".concat(name, ".js")) > -1);
      });
    };
    const scriptletObjects = getScriptletsObjList();

    /**
     * Checks whether the scriptlet `name` is valid by checking the scriptlet list object.
     *
     * @param {string} name Scriptlet name.
     * @returns {boolean} True if scriptlet name is valid.
     */
    const isValidScriptletNameNotCached = function isValidScriptletNameNotCached(name) {
      if (!name) {
        return false;
      }
      const scriptlet = getScriptletByName(name, scriptletObjects);
      if (!scriptlet) {
        return false;
      }
      return true;
    };

    /**
     * Cache for better performance of scriptlet name validation.
     */
    const scriptletNameValidationCache = new Map();

    /**
     * Checks whether the `name` is valid scriptlet name.
     * Uses cache for better performance.
     *
     * @param {string} name Scriptlet name.
     * @returns {boolean} True if scriptlet name is valid.
     */
    const isValidScriptletName = function isValidScriptletName(name) {
      if (!name) {
        return false;
      }
      // if there is no cached validation value
      if (!scriptletNameValidationCache.has(name)) {
        // we should calculate it first
        const isValid = isValidScriptletNameNotCached(name);
        // and save it to the cache then
        scriptletNameValidationCache.set(name, isValid);
        return isValid;
      }
      // otherwise return cached validation result
      return scriptletNameValidationCache.get(name);
    };

    /* ************************************************************************
     *
     * Redirects
     *
     ************************************************************************** */

    /**
     * Redirect resources markers
     */
    const ADG_UBO_REDIRECT_MARKER = 'redirect=';
    const ADG_UBO_REDIRECT_RULE_MARKER = 'redirect-rule=';
    const ABP_REDIRECT_MARKER = 'rewrite=abp-resource:';
    const EMPTY_REDIRECT_MARKER = 'empty';
    const VALID_SOURCE_TYPES = ['image', 'media', 'subdocument', 'stylesheet', 'script', 'xmlhttprequest', 'other'];

    /**
     * Source types for redirect rules if there is no one of them.
     * Used for ADG -> UBO conversion.
     */
    const ABSENT_SOURCE_TYPE_REPLACEMENT = [{
      NAME: 'nooptext',
      TYPES: VALID_SOURCE_TYPES
    }, {
      NAME: 'noopcss',
      TYPES: ['stylesheet']
    }, {
      NAME: 'noopjs',
      TYPES: ['script']
    }, {
      NAME: 'noopframe',
      TYPES: ['subdocument']
    }, {
      NAME: '1x1-transparent.gif',
      TYPES: ['image']
    }, {
      NAME: 'noopmp3-0.1s',
      TYPES: ['media']
    }, {
      NAME: 'noopmp4-1s',
      TYPES: ['media']
    }, {
      NAME: 'googlesyndication-adsbygoogle',
      TYPES: ['xmlhttprequest', 'script']
    }, {
      NAME: 'google-analytics',
      TYPES: ['script']
    }, {
      NAME: 'googletagservices-gpt',
      TYPES: ['script']
    }];
    const validAdgRedirects = redirects$1.filter(function (el) {
      return el.adg;
    });

    /**
     * Compatibility object where KEYS = UBO redirect names and VALUES = ADG redirect names
     * It's used for UBO -> ADG converting
     */
    const uboToAdgCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {
      return el.ubo;
    }).map(function (el) {
      return [el.ubo, el.adg];
    }));

    /**
     * Compatibility object where KEYS = ABP redirect names and VALUES = ADG redirect names
     * It's used for ABP -> ADG converting
     */
    const abpToAdgCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {
      return el.abp;
    }).map(function (el) {
      return [el.abp, el.adg];
    }));

    /**
     * Compatibility object where KEYS = UBO redirect names and VALUES = ADG redirect names
     * It's used for ADG -> UBO converting
     */
    const adgToUboCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {
      return el.ubo;
    }).map(function (el) {
      return [el.adg, el.ubo];
    }));

    /**
     * Needed for AdGuard redirect names validation where KEYS = **valid** AdGuard redirect names
     * 'adgToUboCompatibility' is still needed for ADG -> UBO converting
     */
    const validAdgCompatibility = getObjectFromEntries(validAdgRedirects.map(function (el) {
      return [el.adg, 'valid adg redirect'];
    }));
    const REDIRECT_RULE_TYPES = {
      VALID_ADG: {
        redirectMarker: ADG_UBO_REDIRECT_MARKER,
        redirectRuleMarker: ADG_UBO_REDIRECT_RULE_MARKER,
        compatibility: validAdgCompatibility
      },
      ADG: {
        redirectMarker: ADG_UBO_REDIRECT_MARKER,
        redirectRuleMarker: ADG_UBO_REDIRECT_RULE_MARKER,
        compatibility: adgToUboCompatibility
      },
      UBO: {
        redirectMarker: ADG_UBO_REDIRECT_MARKER,
        redirectRuleMarker: ADG_UBO_REDIRECT_RULE_MARKER,
        compatibility: uboToAdgCompatibility
      },
      ABP: {
        redirectMarker: ABP_REDIRECT_MARKER,
        compatibility: abpToAdgCompatibility
      }
    };

    /**
     * Parses redirect rule modifiers
     *
     * @param {string} rule rule text
     * @returns {Array} list of rule modifiers
     */
    const parseModifiers = function parseModifiers(rule) {
      return substringAfter$1(rule, '$').split(',');
    };

    /**
     * Gets redirect resource name
     *
     * @param {string} rule rule text
     * @param {string} marker - specific Adg/Ubo or Abp redirect resources marker
     * @returns {string} - redirect resource name
     */
    const getRedirectName = function getRedirectName(rule, marker) {
      const ruleModifiers = parseModifiers(rule);
      const redirectNamePart = ruleModifiers.find(function (el) {
        return el.includes(marker);
      });
      return substringAfter$1(redirectNamePart, marker);
    };

    /**
     * Checks if the `rule` is AdGuard redirect rule.
     * Discards comments and JS rules and checks if the `rule` has 'redirect' modifier.
     *
     * @param {string} rule - rule text
     * @returns {boolean} if given rule is adg redirect
     */
    const isAdgRedirectRule = function isAdgRedirectRule(rule) {
      const MARKER_IN_BASE_PART_MASK = '/((?!\\$|\\,).{1})redirect((-rule)?)=(.{0,}?)\\$(popup)?/';
      return !isComment(rule) && (rule.includes(REDIRECT_RULE_TYPES.ADG.redirectMarker) || rule.includes(REDIRECT_RULE_TYPES.ADG.redirectRuleMarker))
      // some js rules may have 'redirect=' in it, so we should get rid of them
      && !rule.includes(JS_RULE_MARKER)
      // get rid of rules like '_redirect=*://look.$popup'
      && !toRegExp(MARKER_IN_BASE_PART_MASK).test(rule);
    };

    // const getRedirectResourceMarkerData = ()

    /**
     * Checks if the `rule` satisfies the `type`
     *
     * @param {string} rule - rule text
     * @param {'VALID_ADG'|'ADG'|'UBO'|'ABP'} type - type of a redirect rule
     * @returns {boolean} if the `rule` satisfies the `type`
     */
    const isRedirectRuleByType = function isRedirectRuleByType(rule, type) {
      const _REDIRECT_RULE_TYPES$ = REDIRECT_RULE_TYPES[type],
        redirectMarker = _REDIRECT_RULE_TYPES$.redirectMarker,
        redirectRuleMarker = _REDIRECT_RULE_TYPES$.redirectRuleMarker,
        compatibility = _REDIRECT_RULE_TYPES$.compatibility;
      if (rule && !isComment(rule)) {
        let marker;
        // check if there is a $redirect-rule modifier in rule
        let markerIndex = redirectRuleMarker ? rule.indexOf(redirectRuleMarker) : -1;
        if (markerIndex > -1) {
          marker = redirectRuleMarker;
        } else {
          // check if there $redirect modifier in rule
          markerIndex = rule.indexOf(redirectMarker);
          if (markerIndex > -1) {
            marker = redirectMarker;
          } else {
            return false;
          }
        }
        const redirectName = getRedirectName(rule, marker);
        if (!redirectName) {
          return false;
        }
        return redirectName === Object.keys(compatibility).find(function (el) {
          return el === redirectName;
        });
      }
      return false;
    };

    /**
     * Checks if the `rule` is **valid** AdGuard redirect resource rule
     *
     * @param {string} rule - rule text
     * @returns {boolean} if given rule is valid adg redirect
     */
    const isValidAdgRedirectRule = function isValidAdgRedirectRule(rule) {
      return isRedirectRuleByType(rule, 'VALID_ADG');
    };

    /**
     * Checks if the AdGuard redirect `rule` has Ubo analog. Needed for Adg->Ubo conversion
     *
     * @param {string} rule - AdGuard rule text
     * @returns {boolean} - true if the rule can be converted to Ubo
     */
    const isAdgRedirectCompatibleWithUbo = function isAdgRedirectCompatibleWithUbo(rule) {
      return isAdgRedirectRule(rule) && isRedirectRuleByType(rule, 'ADG');
    };

    /**
     * Checks if the Ubo redirect `rule` has AdGuard analog. Needed for Ubo->Adg conversion
     *
     * @param {string} rule - Ubo rule text
     * @returns {boolean} - true if the rule can be converted to AdGuard
     */
    const isUboRedirectCompatibleWithAdg = function isUboRedirectCompatibleWithAdg(rule) {
      return isRedirectRuleByType(rule, 'UBO');
    };

    /**
     * Checks if the Abp redirect `rule` has AdGuard analog. Needed for Abp->Adg conversion
     *
     * @param {string} rule - Abp rule text
     * @returns {boolean} - true if the rule can be converted to AdGuard
     */
    const isAbpRedirectCompatibleWithAdg = function isAbpRedirectCompatibleWithAdg(rule) {
      return isRedirectRuleByType(rule, 'ABP');
    };

    /**
     * Checks if the rule has specified content type before Adg -> Ubo conversion.
     *
     * Used ONLY for Adg -> Ubo conversion
     * because Ubo redirect rules must contain content type, but Adg and Abp must not.
     *
     * Also source type can not be added automatically because of such valid rules:
     * ! Abp:
     * $rewrite=abp-resource:blank-js,xmlhttprequest
     * ! Adg:
     * $script,redirect=noopvast-2.0
     * $xmlhttprequest,redirect=noopvast-2.0
     *
     * @param {string} rule rule text
     * @returns {boolean} if the rule has specified content type before conversion
     */
    const hasValidContentType = function hasValidContentType(rule) {
      const ruleModifiers = parseModifiers(rule);
      // rule can have more than one source type modifier
      const sourceTypes = ruleModifiers.filter(function (el) {
        return VALID_SOURCE_TYPES.includes(el);
      });
      const isSourceTypeSpecified = sourceTypes.length > 0;
      const isEmptyRedirect = ruleModifiers.includes("".concat(ADG_UBO_REDIRECT_MARKER).concat(EMPTY_REDIRECT_MARKER)) || ruleModifiers.includes("".concat(ADG_UBO_REDIRECT_RULE_MARKER).concat(EMPTY_REDIRECT_MARKER));
      if (isEmptyRedirect) {
        // no source type for 'empty' is allowed
        return true;
      }
      return isSourceTypeSpecified;
    };
    const validator = {
      UBO_SCRIPTLET_MASK_REG,
      ABP_SCRIPTLET_MASK,
      ABP_SCRIPTLET_EXCEPTION_MASK,
      isComment,
      isAdgScriptletRule,
      isUboScriptletRule,
      isAbpSnippetRule,
      getScriptletByName,
      isValidScriptletName,
      ADG_UBO_REDIRECT_RULE_MARKER,
      REDIRECT_RULE_TYPES,
      ABSENT_SOURCE_TYPE_REPLACEMENT,
      isAdgRedirectRule,
      isValidAdgRedirectRule,
      isAdgRedirectCompatibleWithUbo,
      isUboRedirectCompatibleWithAdg,
      isAbpRedirectCompatibleWithAdg,
      parseModifiers,
      getRedirectName,
      hasValidContentType
    };

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    var arrayWithHoles = _arrayWithHoles;

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
    }
    var iterableToArray = _iterableToArray;

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var arrayLikeToArray = _arrayLikeToArray;

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
    }
    var unsupportedIterableToArray = _unsupportedIterableToArray;

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var nonIterableRest = _nonIterableRest;

    function _toArray(arr) {
      return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
    }
    var toArray$1 = _toArray;

    /**
     * AdGuard scriptlet rule
     */
    const ADGUARD_SCRIPTLET_MASK_REG = /#@?%#\/\/scriptlet\(.+\)/;
    // eslint-disable-next-line no-template-curly-in-string
    const ADGUARD_SCRIPTLET_TEMPLATE = '${domains}#%#//scriptlet(${args})';
    // eslint-disable-next-line no-template-curly-in-string
    const ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@%#//scriptlet(${args})';

    /**
     * uBlock scriptlet rule mask
     */
    // eslint-disable-next-line no-template-curly-in-string
    const UBO_SCRIPTLET_TEMPLATE = '${domains}##+js(${args})';
    // eslint-disable-next-line no-template-curly-in-string
    const UBO_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@#+js(${args})';
    const UBO_ALIAS_NAME_MARKER = 'ubo-';
    const UBO_SCRIPTLET_JS_ENDING = '.js';

    // https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#xhr
    const UBO_XHR_TYPE = 'xhr';
    const ADG_XHR_TYPE = 'xmlhttprequest';
    const ADG_SET_CONSTANT_NAME = 'set-constant';
    const ADG_SET_CONSTANT_EMPTY_STRING = '';
    const ADG_SET_CONSTANT_EMPTY_ARRAY = 'emptyArr';
    const ADG_SET_CONSTANT_EMPTY_OBJECT = 'emptyObj';
    const UBO_SET_CONSTANT_EMPTY_STRING = '\'\'';
    const UBO_SET_CONSTANT_EMPTY_ARRAY = '[]';
    const UBO_SET_CONSTANT_EMPTY_OBJECT = '{}';
    const ADG_PREVENT_FETCH_NAME = 'prevent-fetch';
    const ADG_PREVENT_FETCH_EMPTY_STRING = '';
    const ADG_PREVENT_FETCH_WILDCARD = '*';
    const UBO_NO_FETCH_IF_WILDCARD = '/^/';
    const ESCAPED_COMMA_SEPARATOR = '\\,';
    const COMMA_SEPARATOR = ',';
    const REMOVE_ATTR_METHOD = 'removeAttr';
    const REMOVE_CLASS_METHOD = 'removeClass';
    const REMOVE_ATTR_ALIASES = scriptletList[REMOVE_ATTR_METHOD].names;
    const REMOVE_CLASS_ALIASES = scriptletList[REMOVE_CLASS_METHOD].names;
    const ADG_REMOVE_ATTR_NAME = REMOVE_ATTR_ALIASES[0];
    const ADG_REMOVE_CLASS_NAME = REMOVE_CLASS_ALIASES[0];
    const REMOVE_ATTR_CLASS_APPLYING = ['asap', 'stay', 'complete'];

    /**
     * Returns array of strings separated by space which is not in quotes
     *
     * @param {string} str arbitrary string
     * @returns {string[]} result array
     */
    const getSentences = function getSentences(str) {
      const reg = /'.*?'|".*?"|\S+/g;
      return str.match(reg);
    };

    /**
     * Replaces string with data by placeholders
     *
     * @param {string} str string with placeholders
     * @param {Object} data where keys are placeholders names
     * @returns {string} string filled with data
     */
    const replacePlaceholders = function replacePlaceholders(str, data) {
      return Object.keys(data).reduce(function (acc, key) {
        const reg = new RegExp("\\$\\{".concat(key, "\\}"), 'g');
        acc = acc.replace(reg, data[key]);
        return acc;
      }, str);
    };
    const splitArgs = function splitArgs(str) {
      const args = [];
      let prevArgStart = 0;
      for (let i = 0; i < str.length; i += 1) {
        // do not split args by escaped comma
        // https://github.com/AdguardTeam/Scriptlets/issues/133
        if (str[i] === COMMA_SEPARATOR && str[i - 1] !== '\\') {
          args.push(str.slice(prevArgStart, i).trim());
          prevArgStart = i + 1;
        }
      }
      // collect arg after last comma
      args.push(str.slice(prevArgStart, str.length).trim());
      return args;
    };

    /**
     * Validates remove-attr/class scriptlet args
     *
     * @param {string[]} parsedArgs scriptlet arguments
     * @returns {string[]|Error} valid args OR error for invalid selector
     */
    const validateRemoveAttrClassArgs = function validateRemoveAttrClassArgs(parsedArgs) {
      const _parsedArgs = toArray$1(parsedArgs),
        name = _parsedArgs[0],
        value = _parsedArgs[1],
        restArgs = _parsedArgs.slice(2);
      // no extra checking if there are only scriptlet name and value
      // https://github.com/AdguardTeam/Scriptlets/issues/235
      if (restArgs.length === 0) {
        return [name, value];
      }

      // remove-attr/class scriptlet might have multiple selectors separated by comma. so we should:
      // 1. check if last arg is 'applying' parameter
      // 2. join 'selector' into one arg
      // 3. combine all args
      // https://github.com/AdguardTeam/Scriptlets/issues/133
      const lastArg = restArgs.pop();
      let applying;
      // check the last parsed arg for matching possible 'applying' vale
      if (REMOVE_ATTR_CLASS_APPLYING.some(function (el) {
        return lastArg.indexOf(el) > -1;
      })) {
        applying = lastArg;
      } else {
        restArgs.push(lastArg);
      }
      const selector = replaceAll(restArgs.join(', '), ESCAPED_COMMA_SEPARATOR, COMMA_SEPARATOR);
      if (selector.length > 0 && typeof document !== 'undefined') {
        // empty selector is valid for these scriptlets as it applies to all elements,
        // all other selectors should be validated
        // e.g. #%#//scriptlet('ubo-remove-class.js', 'blur', ', html')
        document.querySelectorAll(selector);
      }
      const validArgs = applying ? [name, value, selector, applying] : [name, value, selector];
      return validArgs;
    };

    /**
     * Converts string of UBO scriptlet rule to AdGuard scriptlet rule
     *
     * @param {string} rule UBO scriptlet rule
     * @returns {string[]} array with one AdGuard scriptlet rule
     */
    const convertUboScriptletToAdg = function convertUboScriptletToAdg(rule) {
      const domains = getBeforeRegExp(rule, validator.UBO_SCRIPTLET_MASK_REG);
      const mask = rule.match(validator.UBO_SCRIPTLET_MASK_REG)[0];
      let template;
      if (mask.indexOf('@') > -1) {
        template = ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;
      } else {
        template = ADGUARD_SCRIPTLET_TEMPLATE;
      }
      const argsStr = getStringInBraces(rule);
      let parsedArgs = splitArgs(argsStr);
      const scriptletName = parsedArgs[0].indexOf(UBO_SCRIPTLET_JS_ENDING) > -1 ? "ubo-".concat(parsedArgs[0]) : "ubo-".concat(parsedArgs[0]).concat(UBO_SCRIPTLET_JS_ENDING);
      if (REMOVE_ATTR_ALIASES.indexOf(scriptletName) > -1 || REMOVE_CLASS_ALIASES.indexOf(scriptletName) > -1) {
        parsedArgs = validateRemoveAttrClassArgs(parsedArgs);
      }
      const args = parsedArgs.map(function (arg, index) {
        let outputArg = arg;
        if (index === 0) {
          outputArg = scriptletName;
        }
        // for example: example.org##+js(abort-current-inline-script, $, popup)
        if (arg === '$') {
          outputArg = '$$';
        }
        return outputArg;
      }).map(function (arg) {
        return wrapInSingleQuotes(arg);
      }).join("".concat(COMMA_SEPARATOR, " "));
      const adgRule = replacePlaceholders(template, {
        domains,
        args
      });
      return [adgRule];
    };

    /**
     * Convert string of ABP snippet rule to AdGuard scriptlet rule
     *
     * @param {string} rule ABP snippet rule
     * @returns {Array} array of AdGuard scriptlet rules, one or few items depends on Abp-rule
     */
    const convertAbpSnippetToAdg = function convertAbpSnippetToAdg(rule) {
      const SEMICOLON_DIVIDER = /;(?=(?:(?:[^"]*"){2})*[^"]*$)/g;
      const mask = rule.indexOf(validator.ABP_SCRIPTLET_MASK) > -1 ? validator.ABP_SCRIPTLET_MASK : validator.ABP_SCRIPTLET_EXCEPTION_MASK;
      const template = mask === validator.ABP_SCRIPTLET_MASK ? ADGUARD_SCRIPTLET_TEMPLATE : ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;
      const domains = substringBefore(rule, mask);
      const args = substringAfter$1(rule, mask);
      return args.split(SEMICOLON_DIVIDER)
      // abp-rule may have `;` at the end which makes last array item irrelevant
      // https://github.com/AdguardTeam/Scriptlets/issues/236
      .filter(isExisting).map(function (args) {
        return getSentences(args).map(function (arg, index) {
          return index === 0 ? "abp-".concat(arg) : arg;
        }).map(function (arg) {
          return wrapInSingleQuotes(arg);
        }).join("".concat(COMMA_SEPARATOR, " "));
      }).map(function (args) {
        return replacePlaceholders(template, {
          domains,
          args
        });
      });
    };

    /**
     * Validates ADG scriptlet rule syntax.
     *
     * IMPORTANT! The method is not very fast as it parses the rule and checks its syntax.
     *
     * @param {string} adgRuleText Single ADG scriptlet rule.
     *
     * @returns {boolean} False if ADG scriptlet rule syntax is not valid
     * or `adgRuleText` is not an ADG scriptlet rule.
     */
    const isValidAdgScriptletRuleSyntax = function isValidAdgScriptletRuleSyntax(adgRuleText) {
      if (!adgRuleText) {
        return false;
      }
      if (!validator.isAdgScriptletRule(adgRuleText)) {
        return false;
      }
      // isAdgScriptletRule() does not check the rule syntax
      let parsedRule;
      try {
        // parseRule() ensures that the rule syntax is valid
        // and it will throw an error if it is not
        parsedRule = parseRule(adgRuleText);
        return validator.isValidScriptletName(parsedRule.name);
      } catch (e) {
        return false;
      }
    };

    /**
     * Converts any scriptlet rule into AdGuard syntax rule.
     * Comment is returned as is.
     *
     * @param {string} rule Scriptlet rule.
     *
     * @returns {string[]} Array of AdGuard scriptlet rules: one array item for ADG and UBO or few items for ABP.
     * For the ADG `rule`, validates its syntax and returns an empty array if it is invalid.
     */
    const convertScriptletToAdg = function convertScriptletToAdg(rule) {
      let result;
      // TODO: multiple conditions may be refactored
      if (validator.isUboScriptletRule(rule)) {
        result = convertUboScriptletToAdg(rule);
      } else if (validator.isAbpSnippetRule(rule)) {
        result = convertAbpSnippetToAdg(rule);
      } else if (validator.isAdgScriptletRule(rule)) {
        if (isValidAdgScriptletRuleSyntax(rule)) {
          result = [rule];
        } else {
          // eslint-disable-next-line no-console
          console.log("Invalid AdGuard scriptlet rule: ".concat(rule));
          result = [];
        }
      } else if (validator.isComment(rule)) {
        result = [rule];
      }
      return result;
    };

    /**
     * Converts UBO scriptlet rule to AdGuard one
     *
     * @param {string} rule AdGuard scriptlet rule
     * @returns {string} UBO scriptlet rule
     */
    const convertAdgScriptletToUbo = function convertAdgScriptletToUbo(rule) {
      let res;
      if (validator.isAdgScriptletRule(rule)) {
        const _parseRule = parseRule(rule),
          parsedName = _parseRule.name,
          parsedParams = _parseRule.args;
        let preparedParams;
        if (parsedName === ADG_SET_CONSTANT_NAME
        // https://github.com/AdguardTeam/FiltersCompiler/issues/102
        && parsedParams[1] === ADG_SET_CONSTANT_EMPTY_STRING) {
          preparedParams = [parsedParams[0], UBO_SET_CONSTANT_EMPTY_STRING];
        } else if (parsedName === ADG_SET_CONSTANT_NAME
        // https://github.com/uBlockOrigin/uBlock-issues/issues/2411
        && parsedParams[1] === ADG_SET_CONSTANT_EMPTY_ARRAY) {
          preparedParams = [parsedParams[0], UBO_SET_CONSTANT_EMPTY_ARRAY];
        } else if (parsedName === ADG_SET_CONSTANT_NAME && parsedParams[1] === ADG_SET_CONSTANT_EMPTY_OBJECT) {
          preparedParams = [parsedParams[0], UBO_SET_CONSTANT_EMPTY_OBJECT];
        } else if (parsedName === ADG_PREVENT_FETCH_NAME
        // https://github.com/AdguardTeam/Scriptlets/issues/109
        && (parsedParams[0] === ADG_PREVENT_FETCH_WILDCARD || parsedParams[0] === ADG_PREVENT_FETCH_EMPTY_STRING)) {
          preparedParams = [UBO_NO_FETCH_IF_WILDCARD];
        } else if ((parsedName === ADG_REMOVE_ATTR_NAME || parsedName === ADG_REMOVE_CLASS_NAME) && parsedParams[1] && parsedParams[1].indexOf(COMMA_SEPARATOR) > -1) {
          preparedParams = [parsedParams[0], replaceAll(parsedParams[1], COMMA_SEPARATOR, ESCAPED_COMMA_SEPARATOR)];
        } else {
          preparedParams = parsedParams;
        }

        // object of name and aliases for the Adg-scriptlet
        const adgScriptletObject = Object.keys(scriptletList).map(function (el) {
          return scriptletList[el];
        }).map(function (s) {
          const _s$names = toArray$1(s.names),
            name = _s$names[0],
            aliases = _s$names.slice(1);
          return {
            name,
            aliases
          };
        }).find(function (el) {
          return el.name === parsedName || el.aliases.indexOf(parsedName) >= 0;
        });
        const aliases = adgScriptletObject.aliases;
        if (aliases.length > 0) {
          const uboAlias = adgScriptletObject.aliases
          // eslint-disable-next-line no-restricted-properties
          .find(function (alias) {
            return alias.includes(UBO_ALIAS_NAME_MARKER);
          });
          if (uboAlias) {
            const mask = rule.match(ADGUARD_SCRIPTLET_MASK_REG)[0];
            let template;
            if (mask.indexOf('@') > -1) {
              template = UBO_SCRIPTLET_EXCEPTION_TEMPLATE;
            } else {
              template = UBO_SCRIPTLET_TEMPLATE;
            }
            const domains = getBeforeRegExp(rule, ADGUARD_SCRIPTLET_MASK_REG);
            const uboName = uboAlias.replace(UBO_ALIAS_NAME_MARKER, '')
            // '.js' in the Ubo scriptlet name can be omitted
            // https://github.com/gorhill/uBlock/wiki/Resources-Library#general-purpose-scriptlets
            .replace(UBO_SCRIPTLET_JS_ENDING, '');
            const args = preparedParams.length > 0 ? "".concat(uboName, ", ").concat(preparedParams.join("".concat(COMMA_SEPARATOR, " "))) : uboName;
            const uboRule = replacePlaceholders(template, {
              domains,
              args
            });
            res = uboRule;
          }
        }
      }
      return res;
    };

    /**
     * Returns scriptlet name from `rule`.
     *
     * @param {string} rule AdGuard syntax scriptlet rule.
     * @returns {string|null} Scriptlet name or null.
     */
    const getAdgScriptletName = function getAdgScriptletName(rule) {
      // get substring after '#//scriptlet('
      let buffer = substringAfter$1(rule, "".concat(ADG_SCRIPTLET_MASK, "("));
      if (!buffer) {
        return null;
      }
      // get the quote used for the first scriptlet parameter which is a name
      const nameQuote = buffer[0];
      // delete the quote from the buffer
      buffer = buffer.slice(1);
      if (!buffer) {
        return null;
      }
      // get a supposed scriptlet name
      const name = substringBefore(buffer, nameQuote);
      return name === buffer ? null : name;
    };

    /**
     * 1. For ADG scriptlet checks whether the scriptlet syntax and name are valid.
     * 2. For UBO and ABP scriptlet first checks their compatibility with ADG
     * by converting them into ADG syntax, and after that checks the name.
     *
     * ADG or UBO rules are "single-scriptlet", but ABP rule may contain more than one snippet
     * so if at least one of them is not valid  whole `ruleText` rule is not valid too.
     *
     * @param {string} ruleText Any scriptlet rule  ADG or UBO or ABP.
     *
     * @returns {boolean} True if scriptlet name is valid in rule.
     */
    const isValidScriptletRule = function isValidScriptletRule(ruleText) {
      if (!ruleText) {
        return false;
      }

      // `ruleText` with ABP syntax may contain more than one snippet in one rule
      const rulesArray = convertScriptletToAdg(ruleText);

      // for ADG rule with invalid syntax convertScriptletToAdg() will return empty array
      if (rulesArray.length === 0) {
        return false;
      }

      // checking if each of parsed scriptlets is valid
      // if at least one of them is not valid - whole `ruleText` is not valid too
      const isValid = rulesArray.every(function (rule) {
        const name = getAdgScriptletName(rule);
        return validator.isValidScriptletName(name);
      });
      return isValid;
    };

    /**
     * Gets index and redirect resource marker from UBO/ADG modifiers array
     *
     * @param {string[]} modifiers rule modifiers
     * @param {Object} redirectsData validator.REDIRECT_RULE_TYPES.(UBO|ADG)
     * @param {string} rule rule string
     * @returns {Object} { index, marker }
     */
    const getMarkerData = function getMarkerData(modifiers, redirectsData, rule) {
      let marker;
      let index = modifiers.findIndex(function (m) {
        return m.indexOf(redirectsData.redirectRuleMarker) > -1;
      });
      if (index > -1) {
        marker = redirectsData.redirectRuleMarker;
      } else {
        index = modifiers.findIndex(function (m) {
          return m.indexOf(redirectsData.redirectMarker) > -1;
        });
        if (index > -1) {
          marker = redirectsData.redirectMarker;
        } else {
          throw new Error("No redirect resource modifier found in rule: ".concat(rule));
        }
      }
      return {
        index,
        marker
      };
    };

    /**
     * Converts Ubo redirect rule to Adg one
     *
     * @param {string} rule ubo redirect rule
     * @returns {string} converted adg rule
     */
    const convertUboRedirectToAdg = function convertUboRedirectToAdg(rule) {
      const firstPartOfRule = substringBefore(rule, '$');
      const uboModifiers = validator.parseModifiers(rule);
      const uboMarkerData = getMarkerData(uboModifiers, validator.REDIRECT_RULE_TYPES.UBO, rule);
      const adgModifiers = uboModifiers.map(function (modifier, index) {
        if (index === uboMarkerData.index) {
          const uboName = substringAfter$1(modifier, uboMarkerData.marker);
          const adgName = validator.REDIRECT_RULE_TYPES.UBO.compatibility[uboName];
          const adgMarker = uboMarkerData.marker === validator.ADG_UBO_REDIRECT_RULE_MARKER ? validator.REDIRECT_RULE_TYPES.ADG.redirectRuleMarker : validator.REDIRECT_RULE_TYPES.ADG.redirectMarker;
          return "".concat(adgMarker).concat(adgName);
        }
        if (modifier === UBO_XHR_TYPE) {
          return ADG_XHR_TYPE;
        }
        return modifier;
      }).join(COMMA_SEPARATOR);
      return "".concat(firstPartOfRule, "$").concat(adgModifiers);
    };

    /**
     * Converts Abp redirect rule to Adg one
     *
     * @param {string} rule abp redirect rule
     * @returns {string} converted adg rule
     */
    const convertAbpRedirectToAdg = function convertAbpRedirectToAdg(rule) {
      const firstPartOfRule = substringBefore(rule, '$');
      const abpModifiers = validator.parseModifiers(rule);
      const adgModifiers = abpModifiers.map(function (modifier) {
        if (modifier.indexOf(validator.REDIRECT_RULE_TYPES.ABP.redirectMarker) > -1) {
          const abpName = substringAfter$1(modifier, validator.REDIRECT_RULE_TYPES.ABP.redirectMarker);
          const adgName = validator.REDIRECT_RULE_TYPES.ABP.compatibility[abpName];
          return "".concat(validator.REDIRECT_RULE_TYPES.ADG.redirectMarker).concat(adgName);
        }
        return modifier;
      }).join(COMMA_SEPARATOR);
      return "".concat(firstPartOfRule, "$").concat(adgModifiers);
    };

    /**
     * Converts redirect rule to AdGuard one
     *
     * @param {string} rule redirect rule
     * @returns {string} converted adg rule
     */
    const convertRedirectToAdg = function convertRedirectToAdg(rule) {
      let result;
      if (validator.isUboRedirectCompatibleWithAdg(rule)) {
        result = convertUboRedirectToAdg(rule);
      } else if (validator.isAbpRedirectCompatibleWithAdg(rule)) {
        result = convertAbpRedirectToAdg(rule);
      } else if (validator.isValidAdgRedirectRule(rule)) {
        result = rule;
      }
      return result;
    };

    /**
     * Converts Adg redirect rule to Ubo one
     * 1. Checks if there is Ubo analog for Adg rule
     * 2. Parses the rule and checks if there are any source type modifiers which are required by Ubo
     *    and if there are no one we add it manually to the end.
     *    Source types are chosen according to redirect name
     *    e.g. ||ad.com^$redirect=<name>,important  ->>  ||ad.com^$redirect=<name>,important,script
     * 3. Replaces Adg redirect name by Ubo analog
     *
     * @param {string} rule adg rule
     * @returns {string} converted ubo rule
     * @throws on incompatible rule
     */
    const convertAdgRedirectToUbo = function convertAdgRedirectToUbo(rule) {
      if (!validator.isAdgRedirectCompatibleWithUbo(rule)) {
        throw new Error("Unable to convert for uBO - unsupported redirect in rule: ".concat(rule));
      }
      const basePart = substringBefore(rule, '$');
      const adgModifiers = validator.parseModifiers(rule);
      const adgMarkerData = getMarkerData(adgModifiers, validator.REDIRECT_RULE_TYPES.ADG, rule);
      const adgRedirectName = adgModifiers[adgMarkerData.index].slice(adgMarkerData.marker.length);
      if (!validator.hasValidContentType(rule)) {
        // add missed source types as content type modifiers
        const sourceTypesData = validator.ABSENT_SOURCE_TYPE_REPLACEMENT.find(function (el) {
          return el.NAME === adgRedirectName;
        });
        if (typeof sourceTypesData === 'undefined') {
          // eslint-disable-next-line max-len
          throw new Error("Unable to convert for uBO - no types to add for specific redirect in rule: ".concat(rule));
        }
        const additionModifiers = sourceTypesData.TYPES;
        adgModifiers.push(...additionModifiers);
      }
      const uboModifiers = adgModifiers.map(function (el, index) {
        if (index === adgMarkerData.index) {
          const uboMarker = adgMarkerData.marker === validator.ADG_UBO_REDIRECT_RULE_MARKER ? validator.REDIRECT_RULE_TYPES.UBO.redirectRuleMarker : validator.REDIRECT_RULE_TYPES.UBO.redirectMarker;
          // eslint-disable-next-line max-len
          const uboRedirectName = validator.REDIRECT_RULE_TYPES.ADG.compatibility[adgRedirectName];
          return "".concat(uboMarker).concat(uboRedirectName);
        }
        return el;
      }).join(COMMA_SEPARATOR);
      return "".concat(basePart, "$").concat(uboModifiers);
    };

    /**
     * @redirect google-analytics
     * @description
     * Mocks Google's Analytics and Tag Manager APIs.
     * [Covers obsolete googletagmanager-gtm redirect functionality](https://github.com/AdguardTeam/Scriptlets/issues/127).
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/8cd2a1d263a96421487b39040c1d23eb01169484/src/web_accessible_resources/google-analytics_analytics.js
     *
     * **Example**
     * ```
     * ||google-analytics.com/analytics.js$script,redirect=google-analytics
     * ||googletagmanager.com/gtm.js$script,redirect=googletagmanager-gtm
     * ```
     */
    function GoogleAnalytics(source) {
      // eslint-disable-next-line func-names
      const Tracker = function Tracker() {}; // constructor
      const proto = Tracker.prototype;
      proto.get = noopFunc;
      proto.set = noopFunc;
      proto.send = noopFunc;
      const googleAnalyticsName = window.GoogleAnalyticsObject || 'ga';
      // a -- fake arg for 'ga.length < 1' antiadblock checking
      // eslint-disable-next-line no-unused-vars
      function ga(a) {
        const len = arguments.length;
        if (len === 0) {
          return;
        }
        // eslint-disable-next-line prefer-rest-params
        const lastArg = arguments[len - 1];
        let replacer;
        if (lastArg instanceof Object && lastArg !== null && typeof lastArg.hitCallback === 'function') {
          replacer = lastArg.hitCallback;
        } else if (typeof lastArg === 'function') {
          // https://github.com/AdguardTeam/Scriptlets/issues/98
          replacer = function replacer() {
            lastArg(ga.create());
          };
        }
        try {
          setTimeout(replacer, 1);
          // eslint-disable-next-line no-empty
        } catch (ex) {}
      }
      ga.create = function () {
        return new Tracker();
      };
      // https://github.com/AdguardTeam/Scriptlets/issues/134
      ga.getByName = function () {
        return new Tracker();
      };
      ga.getAll = function () {
        return [new Tracker()];
      };
      ga.remove = noopFunc;
      ga.loaded = true;
      window[googleAnalyticsName] = ga;
      const _window = window,
        dataLayer = _window.dataLayer,
        google_optimize = _window.google_optimize; // eslint-disable-line camelcase
      if (dataLayer instanceof Object === false) {
        return;
      }
      if (dataLayer.hide instanceof Object && typeof dataLayer.hide.end === 'function') {
        dataLayer.hide.end();
      }

      /**
       * checks data object and delays callback
       *
       * @param {object|Array} dataObj gtag payload
       * @param {string} funcName callback prop name
       */
      const handleCallback = function handleCallback(dataObj, funcName) {
        if (dataObj && typeof dataObj[funcName] === 'function') {
          setTimeout(dataObj[funcName]);
        }
      };
      if (typeof dataLayer.push === 'function') {
        dataLayer.push = function (data) {
          if (data instanceof Object) {
            handleCallback(data, 'eventCallback');
            // eslint-disable-next-line no-restricted-syntax, guard-for-in
            for (const key in data) {
              handleCallback(data[key], 'event_callback');
            }
            // eslint-disable-next-line no-prototype-builtins
            if (!data.hasOwnProperty('eventCallback') && !data.hasOwnProperty('eventCallback')) {
              [].push.call(window.dataLayer, data);
            }
          }
          if (Array.isArray(data)) {
            data.forEach(function (arg) {
              handleCallback(arg, 'callback');
            });
          }
          return noopFunc;
        };
      }

      // https://github.com/AdguardTeam/Scriptlets/issues/81
      // eslint-disable-next-line camelcase
      if (google_optimize instanceof Object && typeof google_optimize.get === 'function') {
        const googleOptimizeWrapper = {
          get: noopFunc
        };
        window.google_optimize = googleOptimizeWrapper;
      }
      hit(source);
    }
    GoogleAnalytics.names = ['google-analytics', 'ubo-google-analytics_analytics.js', 'google-analytics_analytics.js',
    // https://github.com/AdguardTeam/Scriptlets/issues/127
    'googletagmanager-gtm', 'ubo-googletagmanager_gtm.js', 'googletagmanager_gtm.js'];
    GoogleAnalytics.injections = [hit, noopFunc, noopNull, noopArray];

    /* eslint-disable no-underscore-dangle */

    /**
     * @redirect google-analytics-ga
     * @description
     * Mocks old Google Analytics API.
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/google-analytics_ga.js
     *
     * **Example**
     * ```
     * ||google-analytics.com/ga.js$script,redirect=google-analytics-ga
     * ```
     */
    function GoogleAnalyticsGa(source) {
      // Gaq constructor
      function Gaq() {}
      Gaq.prototype.Na = noopFunc;
      Gaq.prototype.O = noopFunc;
      Gaq.prototype.Sa = noopFunc;
      Gaq.prototype.Ta = noopFunc;
      Gaq.prototype.Va = noopFunc;
      Gaq.prototype._createAsyncTracker = noopFunc;
      Gaq.prototype._getAsyncTracker = noopFunc;
      Gaq.prototype._getPlugin = noopFunc;
      Gaq.prototype.push = function (data) {
        if (typeof data === 'function') {
          data();
          return;
        }
        if (Array.isArray(data) === false) {
          return;
        }
        // https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiDomainDirectory#_gat.GA_Tracker_._link
        // https://github.com/uBlockOrigin/uBlock-issues/issues/1807
        if (typeof data[0] === 'string' && /(^|\.)_link$/.test(data[0]) && typeof data[1] === 'string') {
          window.location.assign(data[1]);
        }
        // https://github.com/gorhill/uBlock/issues/2162
        if (data[0] === '_set' && data[1] === 'hitCallback' && typeof data[2] === 'function') {
          data[2]();
        }
      };
      const gaq = new Gaq();
      const asyncTrackers = window._gaq || [];
      if (Array.isArray(asyncTrackers)) {
        while (asyncTrackers[0]) {
          gaq.push(asyncTrackers.shift());
        }
      }
      // eslint-disable-next-line no-multi-assign
      window._gaq = gaq.qf = gaq;

      // Gat constructor
      function Gat() {}

      // Mock tracker api
      const api = ['_addIgnoredOrganic', '_addIgnoredRef', '_addItem', '_addOrganic', '_addTrans', '_clearIgnoredOrganic', '_clearIgnoredRef', '_clearOrganic', '_cookiePathCopy', '_deleteCustomVar', '_getName', '_setAccount', '_getAccount', '_getClientInfo', '_getDetectFlash', '_getDetectTitle', '_getLinkerUrl', '_getLocalGifPath', '_getServiceMode', '_getVersion', '_getVisitorCustomVar', '_initData', '_link', '_linkByPost', '_setAllowAnchor', '_setAllowHash', '_setAllowLinker', '_setCampContentKey', '_setCampMediumKey', '_setCampNameKey', '_setCampNOKey', '_setCampSourceKey', '_setCampTermKey', '_setCampaignCookieTimeout', '_setCampaignTrack', '_setClientInfo', '_setCookiePath', '_setCookiePersistence', '_setCookieTimeout', '_setCustomVar', '_setDetectFlash', '_setDetectTitle', '_setDomainName', '_setLocalGifPath', '_setLocalRemoteServerMode', '_setLocalServerMode', '_setReferrerOverride', '_setRemoteServerMode', '_setSampleRate', '_setSessionTimeout', '_setSiteSpeedSampleRate', '_setSessionCookieTimeout', '_setVar', '_setVisitorCookieTimeout', '_trackEvent', '_trackPageLoadTime', '_trackPageview', '_trackSocial', '_trackTiming', '_trackTrans', '_visitCode'];
      const tracker = api.reduce(function (res, funcName) {
        res[funcName] = noopFunc;
        return res;
      }, {});
      tracker._getLinkerUrl = function (a) {
        return a;
      };
      // https://github.com/AdguardTeam/Scriptlets/issues/154
      tracker._link = function (url) {
        if (typeof url !== 'string') {
          return;
        }
        try {
          window.location.assign(url);
        } catch (e) {
          logMessage(source, e);
        }
      };
      Gat.prototype._anonymizeIP = noopFunc;
      Gat.prototype._createTracker = noopFunc;
      Gat.prototype._forceSSL = noopFunc;
      Gat.prototype._getPlugin = noopFunc;
      Gat.prototype._getTracker = function () {
        return tracker;
      };
      Gat.prototype._getTrackerByName = function () {
        return tracker;
      };
      Gat.prototype._getTrackers = noopFunc;
      Gat.prototype.aa = noopFunc;
      Gat.prototype.ab = noopFunc;
      Gat.prototype.hb = noopFunc;
      Gat.prototype.la = noopFunc;
      Gat.prototype.oa = noopFunc;
      Gat.prototype.pa = noopFunc;
      Gat.prototype.u = noopFunc;
      const gat = new Gat();
      window._gat = gat;
      hit(source);
    }
    GoogleAnalyticsGa.names = ['google-analytics-ga', 'ubo-google-analytics_ga.js', 'google-analytics_ga.js'];
    GoogleAnalyticsGa.injections = [hit, noopFunc, logMessage];

    /* eslint-disable max-len */
    /**
     * @redirect googlesyndication-adsbygoogle
     * @description
     * Mocks Google AdSense API.
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/googlesyndication_adsbygoogle.js
     *
     * **Example**
     * ```
     * ||pagead2.googlesyndication.com/pagead/js/adsbygoogle.js$script,redirect=googlesyndication-adsbygoogle
     * ```
     */
    /* eslint-enable max-len */
    function GoogleSyndicationAdsByGoogle(source) {
      window.adsbygoogle = {
        // https://github.com/AdguardTeam/Scriptlets/issues/113
        // length: 0,
        loaded: true,
        // https://github.com/AdguardTeam/Scriptlets/issues/184
        push(arg) {
          if (typeof this.length === 'undefined') {
            this.length = 0;
            this.length += 1;
          }
          if (arg !== null && arg instanceof Object && arg.constructor.name === 'Object') {
            // eslint-disable-next-line no-restricted-syntax
            for (var _i = 0, _Object$keys = Object.keys(arg); _i < _Object$keys.length; _i++) {
              const key = _Object$keys[_i];
              if (typeof arg[key] === 'function') {
                try {
                  // https://github.com/AdguardTeam/Scriptlets/issues/252
                  // argument "{}" is needed to fix issue with undefined argument
                  arg[key].call(this, {});
                } catch (_unused) {
                  /* empty */
                }
              }
            }
          }
        }
      };
      const adElems = document.querySelectorAll('.adsbygoogle');
      const css = 'height:1px!important;max-height:1px!important;max-width:1px!important;width:1px!important;';
      const statusAttrName = 'data-adsbygoogle-status';
      const ASWIFT_IFRAME_MARKER = 'aswift_';
      const GOOGLE_ADS_IFRAME_MARKER = 'google_ads_iframe_';
      let executed = false;
      for (let i = 0; i < adElems.length; i += 1) {
        const adElemChildNodes = adElems[i].childNodes;
        const childNodesQuantity = adElemChildNodes.length;
        // childNodes of .adsbygoogle can be defined if scriptlet was executed before
        // so we should check that childNodes are exactly defined by us
        // TODO: remake after scriptlets context developing in 1.3
        let areIframesDefined = false;
        if (childNodesQuantity > 0) {
          // it should be only 2 child iframes if scriptlet was executed
          areIframesDefined = childNodesQuantity === 2
          // the first of child nodes should be aswift iframe
          && adElemChildNodes[0].nodeName.toLowerCase() === 'iframe' && adElemChildNodes[0].id.indexOf(ASWIFT_IFRAME_MARKER) > -1
          // the second of child nodes should be google_ads iframe
          && adElemChildNodes[1].nodeName.toLowerCase() === 'iframe' && adElemChildNodes[1].id.indexOf(GOOGLE_ADS_IFRAME_MARKER) > -1;
        }
        if (!areIframesDefined) {
          // here we do the job if scriptlet has not been executed earlier
          adElems[i].setAttribute(statusAttrName, 'done');
          const aswiftIframe = document.createElement('iframe');
          aswiftIframe.id = "".concat(ASWIFT_IFRAME_MARKER).concat(i);
          aswiftIframe.style = css;
          adElems[i].appendChild(aswiftIframe);
          const innerAswiftIframe = document.createElement('iframe');
          aswiftIframe.contentWindow.document.body.appendChild(innerAswiftIframe);
          const googleadsIframe = document.createElement('iframe');
          googleadsIframe.id = "".concat(GOOGLE_ADS_IFRAME_MARKER).concat(i);
          googleadsIframe.style = css;
          adElems[i].appendChild(googleadsIframe);
          const innerGoogleadsIframe = document.createElement('iframe');
          googleadsIframe.contentWindow.document.body.appendChild(innerGoogleadsIframe);
          executed = true;
        }
      }
      if (executed) {
        hit(source);
      }
    }
    GoogleSyndicationAdsByGoogle.names = ['googlesyndication-adsbygoogle', 'ubo-googlesyndication_adsbygoogle.js', 'googlesyndication_adsbygoogle.js'];
    GoogleSyndicationAdsByGoogle.injections = [hit];

    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    var iterableToArrayLimit = _iterableToArrayLimit;

    function _slicedToArray(arr, i) {
      return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
    }
    var slicedToArray = _slicedToArray;

    /**
     * @redirect googletagservices-gpt
     * @description
     * Mocks Google Publisher Tag API.
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/googletagservices_gpt.js
     *
     * **Example**
     * ```
     * ||googletagservices.com/tag/js/gpt.js$script,redirect=googletagservices-gpt
     * ```
     */
    function GoogleTagServicesGpt(source) {
      const slots = new Map();
      const slotsById = new Map();
      const slotsPerPath = new Map();
      const slotCreatives = new Map();
      const eventCallbacks = new Map();
      const gTargeting = new Map();
      const addEventListener = function addEventListener(name, listener) {
        if (!eventCallbacks.has(name)) {
          eventCallbacks.set(name, new Set());
        }
        eventCallbacks.get(name).add(listener);
        return this;
      };
      const removeEventListener = function removeEventListener(name, listener) {
        if (eventCallbacks.has(name)) {
          return eventCallbacks.get(name).delete(listener);
        }
        return false;
      };
      const fireSlotEvent = function fireSlotEvent(name, slot) {
        return new Promise(function (resolve) {
          requestAnimationFrame(function () {
            const size = [0, 0];
            const callbacksSet = eventCallbacks.get(name) || [];
            const callbackArray = Array.from(callbacksSet);
            for (let i = 0; i < callbackArray.length; i += 1) {
              callbackArray[i]({
                isEmpty: true,
                size,
                slot
              });
            }
            resolve();
          });
        });
      };
      const emptySlotElement = function emptySlotElement(slot) {
        const node = document.getElementById(slot.getSlotElementId());
        while (node !== null && node !== void 0 && node.lastChild) {
          node.lastChild.remove();
        }
      };
      const recreateIframeForSlot = function recreateIframeForSlot(slot) {
        var _document$getElementB;
        const eid = "google_ads_iframe_".concat(slot.getId());
        (_document$getElementB = document.getElementById(eid)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.remove();
        const node = document.getElementById(slot.getSlotElementId());
        if (node) {
          const f = document.createElement('iframe');
          f.id = eid;
          f.srcdoc = '<body></body>';
          f.style = 'position:absolute; width:0; height:0; left:0; right:0; z-index:-1; border:0';
          f.setAttribute('width', 0);
          f.setAttribute('height', 0);
          // https://github.com/AdguardTeam/Scriptlets/issues/259
          f.setAttribute('data-load-complete', true);
          f.setAttribute('data-google-container-id', true);
          f.setAttribute('sandbox', true);
          node.appendChild(f);
        }
      };
      const displaySlot = function displaySlot(slot) {
        if (!slot) {
          return;
        }
        const id = slot.getSlotElementId();
        if (!document.getElementById(id)) {
          return;
        }
        const parent = document.getElementById(id);
        if (parent) {
          parent.appendChild(document.createElement('div'));
        }
        emptySlotElement(slot);
        recreateIframeForSlot(slot);
        fireSlotEvent('slotRenderEnded', slot);
        fireSlotEvent('slotRequested', slot);
        fireSlotEvent('slotResponseReceived', slot);
        fireSlotEvent('slotOnload', slot);
        fireSlotEvent('impressionViewable', slot);
      };
      const companionAdsService = {
        addEventListener,
        removeEventListener,
        enableSyncLoading: noopFunc,
        setRefreshUnfilledSlots: noopFunc,
        getSlots: noopArray
      };
      const contentService = {
        addEventListener,
        removeEventListener,
        setContent: noopFunc
      };
      function PassbackSlot() {} // constructor

      PassbackSlot.prototype.display = noopFunc;
      PassbackSlot.prototype.get = noopNull;
      PassbackSlot.prototype.set = noopThis;
      PassbackSlot.prototype.setClickUrl = noopThis;
      PassbackSlot.prototype.setTagForChildDirectedTreatment = noopThis;
      PassbackSlot.prototype.setTargeting = noopThis;
      PassbackSlot.prototype.updateTargetingFromMap = noopThis;
      function SizeMappingBuilder() {} // constructor
      SizeMappingBuilder.prototype.addSize = noopThis;
      SizeMappingBuilder.prototype.build = noopNull;
      const getTargetingValue = function getTargetingValue(v) {
        if (typeof v === 'string') {
          return [v];
        }
        try {
          return [Array.prototype.flat.call(v)[0]];
        } catch (_unused) {
          // do nothing
        }
        return [];
      };
      const updateTargeting = function updateTargeting(targeting, map) {
        if (typeof map === 'object') {
          const entries = Object.entries(map || {});
          for (var _i = 0, _entries = entries; _i < _entries.length; _i++) {
            const _entries$_i = slicedToArray(_entries[_i], 2),
              k = _entries$_i[0],
              v = _entries$_i[1];
            targeting.set(k, getTargetingValue(v));
          }
        }
      };
      const defineSlot = function defineSlot(adUnitPath, creatives, optDiv) {
        if (slotsById.has(optDiv)) {
          var _document$getElementB2;
          (_document$getElementB2 = document.getElementById(optDiv)) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.remove();
          return slotsById.get(optDiv);
        }
        const attributes = new Map();
        const targeting = new Map();
        const exclusions = new Set();
        const response = {
          advertiserId: undefined,
          campaignId: undefined,
          creativeId: undefined,
          creativeTemplateId: undefined,
          lineItemId: undefined
        };
        const sizes = [{
          getHeight: function getHeight() {
            return 2;
          },
          getWidth: function getWidth() {
            return 2;
          }
        }];
        const num = (slotsPerPath.get(adUnitPath) || 0) + 1;
        slotsPerPath.set(adUnitPath, num);
        const id = "".concat(adUnitPath, "_").concat(num);
        let clickUrl = '';
        let collapseEmptyDiv = null;
        const services = new Set();
        const slot = {
          addService(e) {
            services.add(e);
            return slot;
          },
          clearCategoryExclusions: noopThis,
          clearTargeting(k) {
            if (k === undefined) {
              targeting.clear();
            } else {
              targeting.delete(k);
            }
          },
          defineSizeMapping(mapping) {
            slotCreatives.set(optDiv, mapping);
            return this;
          },
          get: function get(k) {
            return attributes.get(k);
          },
          getAdUnitPath: function getAdUnitPath() {
            return adUnitPath;
          },
          getAttributeKeys: function getAttributeKeys() {
            return Array.from(attributes.keys());
          },
          getCategoryExclusions: function getCategoryExclusions() {
            return Array.from(exclusions);
          },
          getClickUrl: function getClickUrl() {
            return clickUrl;
          },
          getCollapseEmptyDiv: function getCollapseEmptyDiv() {
            return collapseEmptyDiv;
          },
          getContentUrl: function getContentUrl() {
            return '';
          },
          getDivStartsCollapsed: function getDivStartsCollapsed() {
            return null;
          },
          getDomId: function getDomId() {
            return optDiv;
          },
          getEscapedQemQueryId: function getEscapedQemQueryId() {
            return '';
          },
          getFirstLook: function getFirstLook() {
            return 0;
          },
          getId: function getId() {
            return id;
          },
          getHtml: function getHtml() {
            return '';
          },
          getName: function getName() {
            return id;
          },
          getOutOfPage: function getOutOfPage() {
            return false;
          },
          getResponseInformation: function getResponseInformation() {
            return response;
          },
          getServices: function getServices() {
            return Array.from(services);
          },
          getSizes: function getSizes() {
            return sizes;
          },
          getSlotElementId: function getSlotElementId() {
            return optDiv;
          },
          getSlotId: function getSlotId() {
            return slot;
          },
          getTargeting: function getTargeting(k) {
            return targeting.get(k) || gTargeting.get(k) || [];
          },
          getTargetingKeys: function getTargetingKeys() {
            return Array.from(new Set(Array.of(...gTargeting.keys(), ...targeting.keys())));
          },
          getTargetingMap: function getTargetingMap() {
            return Object.assign(Object.fromEntries(gTargeting.entries()), Object.fromEntries(targeting.entries()));
          },
          set(k, v) {
            attributes.set(k, v);
            return slot;
          },
          setCategoryExclusion(e) {
            exclusions.add(e);
            return slot;
          },
          setClickUrl(u) {
            clickUrl = u;
            return slot;
          },
          setCollapseEmptyDiv(v) {
            collapseEmptyDiv = !!v;
            return slot;
          },
          setSafeFrameConfig: noopThis,
          setTagForChildDirectedTreatment: noopThis,
          setTargeting(k, v) {
            targeting.set(k, getTargetingValue(v));
            return slot;
          },
          toString: function toString() {
            return id;
          },
          updateTargetingFromMap(map) {
            updateTargeting(targeting, map);
            return slot;
          }
        };
        slots.set(adUnitPath, slot);
        slotsById.set(optDiv, slot);
        slotCreatives.set(optDiv, creatives);
        return slot;
      };
      const pubAdsService = {
        addEventListener,
        removeEventListener,
        clear: noopFunc,
        clearCategoryExclusions: noopThis,
        clearTagForChildDirectedTreatment: noopThis,
        clearTargeting(k) {
          if (k === undefined) {
            gTargeting.clear();
          } else {
            gTargeting.delete(k);
          }
        },
        collapseEmptyDivs: noopFunc,
        defineOutOfPagePassback() {
          return new PassbackSlot();
        },
        definePassback() {
          return new PassbackSlot();
        },
        disableInitialLoad: noopFunc,
        display: noopFunc,
        enableAsyncRendering: noopFunc,
        enableLazyLoad: noopFunc,
        enableSingleRequest: noopFunc,
        enableSyncRendering: noopFunc,
        enableVideoAds: noopFunc,
        get: noopNull,
        getAttributeKeys: noopArray,
        getTargeting: noopArray,
        getTargetingKeys: noopArray,
        getSlots: noopArray,
        isInitialLoadDisabled: trueFunc,
        refresh: noopFunc,
        set: noopThis,
        setCategoryExclusion: noopThis,
        setCentering: noopFunc,
        setCookieOptions: noopThis,
        setForceSafeFrame: noopThis,
        setLocation: noopThis,
        setPublisherProvidedId: noopThis,
        setRequestNonPersonalizedAds: noopThis,
        setSafeFrameConfig: noopThis,
        setTagForChildDirectedTreatment: noopThis,
        setTargeting: noopThis,
        setVideoContent: noopThis,
        updateCorrelator: noopFunc
      };
      const _window = window,
        _window$googletag = _window.googletag,
        googletag = _window$googletag === void 0 ? {} : _window$googletag;
      const _googletag$cmd = googletag.cmd,
        cmd = _googletag$cmd === void 0 ? [] : _googletag$cmd;
      googletag.apiReady = true;
      googletag.cmd = [];
      googletag.cmd.push = function (a) {
        try {
          a();
          // eslint-disable-next-line no-empty
        } catch (ex) {}
        return 1;
      };
      googletag.companionAds = function () {
        return companionAdsService;
      };
      googletag.content = function () {
        return contentService;
      };
      googletag.defineOutOfPageSlot = defineSlot;
      googletag.defineSlot = defineSlot;
      googletag.destroySlots = function () {
        slots.clear();
        slotsById.clear();
      };
      googletag.disablePublisherConsole = noopFunc;
      googletag.display = function (arg) {
        let id;
        if (arg !== null && arg !== void 0 && arg.getSlotElementId) {
          id = arg.getSlotElementId();
        } else if (arg !== null && arg !== void 0 && arg.nodeType) {
          id = arg.id;
        } else {
          id = String(arg);
        }
        displaySlot(slotsById.get(id));
      };
      googletag.enableServices = noopFunc;
      googletag.getVersion = noopStr;
      googletag.pubads = function () {
        return pubAdsService;
      };
      googletag.pubadsReady = true;
      googletag.setAdIframeTitle = noopFunc;
      googletag.sizeMapping = function () {
        return new SizeMappingBuilder();
      };
      window.googletag = googletag;
      while (cmd.length !== 0) {
        googletag.cmd.push(cmd.shift());
      }
      hit(source);
    }
    GoogleTagServicesGpt.names = ['googletagservices-gpt', 'ubo-googletagservices_gpt.js', 'googletagservices_gpt.js'];
    GoogleTagServicesGpt.injections = [hit, noopFunc, noopThis, noopNull, noopArray, noopStr, trueFunc];

    /**
     * @redirect scorecardresearch-beacon
     * @description
     * Mocks Scorecard Research API.
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/scorecardresearch_beacon.js
     *
     * **Example**
     * ```
     * ||sb.scorecardresearch.com/beacon.js$script,redirect=scorecardresearch-beacon
     * ```
     */
    function ScoreCardResearchBeacon(source) {
      window.COMSCORE = {
        purge() {
          // eslint-disable-next-line no-underscore-dangle
          window._comscore = [];
        },
        beacon() {}
      };
      hit(source);
    }
    ScoreCardResearchBeacon.names = ['scorecardresearch-beacon', 'ubo-scorecardresearch_beacon.js', 'scorecardresearch_beacon.js'];
    ScoreCardResearchBeacon.injections = [hit];

    /**
     * @redirect metrika-yandex-tag
     * @description
     * Mocks Yandex Metrika API.
     * https://yandex.ru/support/metrica/objects/method-reference.html
     *
     * **Example**
     * ```
     * ||mc.yandex.ru/metrika/tag.js$script,redirect=metrika-yandex-tag
     * ```
     */
    function metrikaYandexTag(source) {
      const asyncCallbackFromOptions = function asyncCallbackFromOptions(id, param) {
        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        let callback = options.callback;
        const ctx = options.ctx;
        if (typeof callback === 'function') {
          callback = ctx !== undefined ? callback.bind(ctx) : callback;
          setTimeout(function () {
            return callback();
          });
        }
      };

      /**
       * https://yandex.ru/support/metrica/objects/addfileextension.html
       */
      const addFileExtension = noopFunc;

      /**
       * https://yandex.ru/support/metrica/objects/extlink.html
       */
      const extLink = asyncCallbackFromOptions;

      /**
       * https://yandex.ru/support/metrica/objects/file.html
       */
      const file = asyncCallbackFromOptions;

      /**
       * https://yandex.ru/support/metrica/objects/get-client-id.html
       *
       * @param {string} id
       * @param {Function} cb
       */
      const getClientID = function getClientID(id, cb) {
        if (!cb) {
          return;
        }
        setTimeout(cb(null));
      };

      /**
       * https://yandex.ru/support/metrica/objects/hit.html
       */
      const hitFunc = asyncCallbackFromOptions;

      /**
       * https://yandex.ru/support/metrica/objects/notbounce.html
       */
      const notBounce = asyncCallbackFromOptions;

      /**
       * https://yandex.ru/support/metrica/objects/params-method.html
       */
      const params = noopFunc;

      /**
       * https://yandex.ru/support/metrica/objects/reachgoal.html
       *
       * @param {string} id
       * @param {string} target
       * @param {Object} params
       * @param {Function} callback
       * @param {any} ctx
       */
      const reachGoal = function reachGoal(id, target, params, callback, ctx) {
        asyncCallbackFromOptions(null, null, {
          callback,
          ctx
        });
      };

      /**
       * https://yandex.ru/support/metrica/objects/set-user-id.html
       */
      const setUserID = noopFunc;

      /**
       * https://yandex.ru/support/metrica/objects/user-params.html
       */
      const userParams = noopFunc;

      // https://github.com/AdguardTeam/Scriptlets/issues/198
      const destruct = noopFunc;
      const api = {
        addFileExtension,
        extLink,
        file,
        getClientID,
        hit: hitFunc,
        notBounce,
        params,
        reachGoal,
        setUserID,
        userParams,
        destruct
      };
      function ym(id, funcName) {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return api[funcName] && api[funcName](id, ...args);
      }
      function init(id) {
        // yaCounter object should provide api
        window["yaCounter".concat(id)] = api;
        document.dispatchEvent(new Event("yacounter".concat(id, "inited")));
      }
      if (typeof window.ym === 'undefined') {
        window.ym = ym;
        ym.a = [];
      } else if (window.ym && window.ym.a) {
        // Keep initial counters array intact
        ym.a = window.ym.a;
        window.ym = ym;
        window.ym.a.forEach(function (params) {
          const id = params[0];
          init(id);
        });
      }
      hit(source);
    }
    metrikaYandexTag.names = ['metrika-yandex-tag'];
    metrikaYandexTag.injections = [hit, noopFunc];

    /**
     * @redirect metrika-yandex-watch
     * @description
     * Mocks the old Yandex Metrika API.
     * https://yandex.ru/support/metrica/objects/_method-reference.html
     *
     * **Example**
     * ```
     * ||mc.yandex.ru/metrika/watch.js$script,redirect=metrika-yandex-watch
     * ```
     */
    function metrikaYandexWatch(source) {
      const cbName = 'yandex_metrika_callbacks';

      /**
       * Gets callback and its context from options and call it in async way
       *
       * @param {Object} options Yandex Metrika API options
       */
      const asyncCallbackFromOptions = function asyncCallbackFromOptions() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        let callback = options.callback;
        const ctx = options.ctx;
        if (typeof callback === 'function') {
          callback = ctx !== undefined ? callback.bind(ctx) : callback;
          setTimeout(function () {
            return callback();
          });
        }
      };
      function Metrika() {} // constructor
      Metrika.counters = noopArray;
      // Methods without options
      Metrika.prototype.addFileExtension = noopFunc;
      Metrika.prototype.getClientID = noopFunc;
      Metrika.prototype.setUserID = noopFunc;
      Metrika.prototype.userParams = noopFunc;
      Metrika.prototype.params = noopFunc;
      Metrika.prototype.counters = noopArray;

      // Methods with options
      // The order of arguments should be kept in according to API
      Metrika.prototype.extLink = function (url, options) {
        asyncCallbackFromOptions(options);
      };
      Metrika.prototype.file = function (url, options) {
        asyncCallbackFromOptions(options);
      };
      Metrika.prototype.hit = function (url, options) {
        asyncCallbackFromOptions(options);
      };
      Metrika.prototype.reachGoal = function (target, params, cb, ctx) {
        asyncCallbackFromOptions({
          callback: cb,
          ctx
        });
      };
      Metrika.prototype.notBounce = asyncCallbackFromOptions;
      if (window.Ya) {
        window.Ya.Metrika = Metrika;
      } else {
        window.Ya = {
          Metrika
        };
      }
      if (window[cbName] && Array.isArray(window[cbName])) {
        window[cbName].forEach(function (func) {
          if (typeof func === 'function') {
            func();
          }
        });
      }
      hit(source);
    }
    metrikaYandexWatch.names = ['metrika-yandex-watch'];
    metrikaYandexWatch.injections = [hit, noopFunc, noopArray];

    /* eslint-disable func-names */

    /**
     * @redirect pardot-1.0
     * @description
     * Mocks the pd.js file of Salesforce.
     * https://pi.pardot.com/pd.js
     * https://developer.salesforce.com/docs/marketing/pardot/overview
     *
     * **Example**
     * ```
     * ||pi.pardot.com/pd.js$script,redirect=pardot
     * ||pacedg.com.au/pd.js$redirect=pardot
     * ```
     */

    function Pardot(source) {
      window.piVersion = '1.0.2';
      window.piScriptNum = 0;
      window.piScriptObj = [];
      window.checkNamespace = noopFunc;
      window.getPardotUrl = noopStr;
      window.piGetParameter = noopNull;
      window.piSetCookie = noopFunc;
      window.piGetCookie = noopStr;
      function piTracker() {
        window.pi = {
          tracker: {
            visitor_id: '',
            visitor_id_sign: '',
            pi_opt_in: '',
            campaign_id: ''
          }
        };
        window.piScriptNum += 1;
      }
      window.piResponse = noopFunc;
      window.piTracker = piTracker;
      piTracker();
      hit(source);
    }
    Pardot.names = ['pardot-1.0'];
    Pardot.injections = [hit, noopFunc, noopStr, noopNull];

    /**
     * @redirect prevent-bab
     * @description
     * Prevents BlockAdblock script from detecting an ad blocker.
     *
     * Mostly it is used as `scriptlet`.
     * See [scriptlet description](../wiki/about-scriptlets.md#prevent-bab).
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/nobab.js
     *
     * **Example**
     * ```
     * /blockadblock.$script,redirect=prevent-bab
     * ```
     */
    const preventBab$1 = preventBab$2;
    preventBab$1.names = ['prevent-bab',
    // list of prevent-bab redirect aliases
    'nobab.js', 'ubo-nobab.js', 'bab-defuser.js', 'ubo-bab-defuser.js', 'ubo-nobab', 'ubo-bab-defuser'];

    /**
     * @redirect amazon-apstag
     * @description
     * Mocks Amazon's apstag.js
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/f842ab6d3c1cf0394f95d27092bf59627262da40/src/web_accessible_resources/amazon_apstag.js
     *
     * **Example**
     * ```
     * ||amazon-adsystem.com/aax2/apstag.js$script,redirect=amazon-apstag
     * ```
     */
    function AmazonApstag(source) {
      const apstagWrapper = {
        fetchBids(a, b) {
          if (typeof b === 'function') {
            b([]);
          }
        },
        init: noopFunc,
        setDisplayBids: noopFunc,
        targetingKeys: noopFunc
      };
      window.apstag = apstagWrapper;
      hit(source);
    }
    AmazonApstag.names = ['amazon-apstag', 'ubo-amazon_apstag.js', 'amazon_apstag.js'];
    AmazonApstag.injections = [hit, noopFunc];

    /* eslint-disable func-names */

    /**
     * @redirect matomo
     * @description
     * Mocks the piwik.js file of Matomo (formerly Piwik).
     *
     * **Example**
     * ```
     * ||example.org/piwik.js$script,redirect=matomo
     * ```
     */

    function Matomo(source) {
      const Tracker = function Tracker() {};
      Tracker.prototype.setDoNotTrack = noopFunc;
      Tracker.prototype.setDomains = noopFunc;
      Tracker.prototype.setCustomDimension = noopFunc;
      Tracker.prototype.trackPageView = noopFunc;
      const AsyncTracker = function AsyncTracker() {};
      AsyncTracker.prototype.addListener = noopFunc;
      const matomoWrapper = {
        getTracker: Tracker,
        getAsyncTracker: AsyncTracker
      };
      window.Piwik = matomoWrapper;
      hit(source);
    }
    Matomo.names = ['matomo'];
    Matomo.injections = [hit, noopFunc];

    /* eslint-disable func-names */

    /**
     * @redirect fingerprintjs2
     * @description
     * Mocks FingerprintJS v2
     * https://github.com/fingerprintjs
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/master/src/web_accessible_resources/fingerprint2.js
     *
     * **Example**
     * ```
     * ||the-japan-news.com/modules/js/lib/fgp/fingerprint2.js$script,redirect=fingerprintjs2
     * ```
     */
    function Fingerprintjs2(source) {
      let browserId = '';
      for (let i = 0; i < 8; i += 1) {
        browserId += (Math.random() * 0x10000 + 0x1000).toString(16).slice(-4);
      }
      const Fingerprint2 = function Fingerprint2() {};
      Fingerprint2.get = function (options, callback) {
        if (!callback) {
          callback = options;
        }
        setTimeout(function () {
          if (callback) {
            callback(browserId, []);
          }
        }, 1);
      };
      Fingerprint2.prototype = {
        get: Fingerprint2.get
      };
      window.Fingerprint2 = Fingerprint2;
      hit(source);
    }
    Fingerprintjs2.names = ['fingerprintjs2',
    // redirect aliases are needed for conversion:
    // prefixed for us
    'ubo-fingerprint2.js',
    // original ubo name
    'fingerprint2.js'];
    Fingerprintjs2.injections = [hit];

    /* eslint-disable func-names */

    /**
     * @redirect fingerprintjs3
     * @description
     * Mocks FingerprintJS v3
     * https://github.com/fingerprintjs
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/master/src/web_accessible_resources/fingerprint3.js
     *
     * **Example**
     * ```
     * ||sephora.com/js/ufe/isomorphic/thirdparty/fp.min.js$script,redirect=fingerprintjs3
     * ```
     */
    function Fingerprintjs3(source) {
      const visitorId = function () {
        let id = '';
        for (let i = 0; i < 8; i += 1) {
          id += (Math.random() * 0x10000 + 0x1000).toString(16).slice(-4);
        }
        return id;
      }();
      const FingerprintJS = function FingerprintJS() {};
      FingerprintJS.prototype = {
        load() {
          return Promise.resolve(new FingerprintJS());
        },
        get() {
          return Promise.resolve({
            visitorId
          });
        },
        hashComponents: noopStr
      };
      window.FingerprintJS = new FingerprintJS();
      hit(source);
    }
    Fingerprintjs3.names = ['fingerprintjs3',
    // redirect aliases are needed for conversion:
    // prefixed for us
    'ubo-fingerprint3.js',
    // original ubo name
    'fingerprint3.js'];
    Fingerprintjs3.injections = [hit, noopStr];

    /* eslint-disable func-names */

    /**
     * @redirect gemius
     * @description
     * Mocks Gemius Analytics.
     * https://flowplayer.com/developers/plugins/gemius
     *
     * **Example**
     * ```
     * ||gapt.hit.gemius.pl/gplayer.js$script,redirect=gemius
     * ```
     */
    function Gemius(source) {
      const GemiusPlayer = function GemiusPlayer() {};
      GemiusPlayer.prototype = {
        setVideoObject: noopFunc,
        newProgram: noopFunc,
        programEvent: noopFunc,
        newAd: noopFunc,
        adEvent: noopFunc
      };
      window.GemiusPlayer = GemiusPlayer;
      hit(source);
    }
    Gemius.names = ['gemius'];
    Gemius.injections = [hit, noopFunc];

    /**
     * @redirect ati-smarttag
     * @description
     * Mocks AT Internat SmartTag.
     * https://developers.atinternet-solutions.com/as2-tagging-en/javascript-en/getting-started-javascript-en/tracker-initialisation-javascript-en/
     *
     * **Example**
     * ```
     * ||bloctel.gouv.fr/assets/scripts/smarttag.js$script,redirect=ati-smarttag
     * ```
     */
    function ATInternetSmartTag(source) {
      const setNoopFuncWrapper = {
        set: noopFunc
      };
      const sendNoopFuncWrapper = {
        send: noopFunc
      };
      const ecommerceWrapper = {
        displayCart: {
          products: setNoopFuncWrapper,
          cart: setNoopFuncWrapper
        },
        updateCart: {
          cart: setNoopFuncWrapper
        },
        displayProduct: {
          products: setNoopFuncWrapper
        },
        displayPageProduct: {
          products: setNoopFuncWrapper
        },
        addProduct: {
          products: setNoopFuncWrapper
        },
        removeProduct: {
          products: setNoopFuncWrapper
        }
      };

      // eslint-disable-next-line new-cap, func-names
      const tag = function tag() {};
      tag.prototype = {
        setConfig: noopFunc,
        setParam: noopFunc,
        dispatch: noopFunc,
        customVars: setNoopFuncWrapper,
        publisher: setNoopFuncWrapper,
        order: setNoopFuncWrapper,
        click: sendNoopFuncWrapper,
        clickListener: sendNoopFuncWrapper,
        internalSearch: {
          set: noopFunc,
          send: noopFunc
        },
        ecommerce: ecommerceWrapper,
        identifiedVisitor: {
          unset: noopFunc
        },
        page: {
          set: noopFunc,
          send: noopFunc
        },
        selfPromotion: {
          add: noopFunc,
          send: noopFunc
        },
        privacy: {
          setVisitorMode: noopFunc,
          getVisitorMode: noopFunc,
          hit: noopFunc
        },
        richMedia: {
          add: noopFunc,
          send: noopFunc,
          remove: noopFunc,
          removeAll: noopFunc
        }
      };
      const smartTagWrapper = {
        Tracker: {
          Tag: tag
        }
      };
      window.ATInternet = smartTagWrapper;
      hit(source);
    }
    ATInternetSmartTag.names = ['ati-smarttag'];
    ATInternetSmartTag.injections = [hit, noopFunc];

    /* eslint-disable consistent-return, no-eval */

    /**
     * @redirect prevent-bab2
     * @description
     * Prevents BlockAdblock script from detecting an ad blocker.
     *
     * Related UBO redirect:
     * https://github.com/gorhill/uBlock/blob/master/src/web_accessible_resources/nobab2.js
     *
     * See [redirect description](../wiki/about-redirects.md#prevent-bab2).
     *
     * **Syntax**
     * ```
     * /blockadblock.$script,redirect=prevent-bab2
     * ```
     */
    function preventBab2(source) {
      const script = document.currentScript;
      if (script === null) {
        return;
      }
      const url = script.src;
      if (typeof url !== 'string') {
        return;
      }
      const domainsStr = ['adclixx\\.net', 'adnetasia\\.com', 'adtrackers\\.net', 'bannertrack\\.net'].join('|');
      const matchStr = "^https?://[\\w-]+\\.(".concat(domainsStr, ")/.");
      const domainsRegex = new RegExp(matchStr);
      if (domainsRegex.test(url) === false) {
        return;
      }
      window.nH7eXzOsG = 858;
      hit(source);
    }
    preventBab2.names = ['prevent-bab2',
    // aliases are needed for matching the related scriptlet converted into our syntax
    'nobab2.js'];
    preventBab2.injections = [hit];

    /* eslint-disable func-names, no-underscore-dangle */

    /**
     * @redirect google-ima3
     * @description
     * Mocks the IMA SDK of Google.
     *
     * **Example**
     * ```
     * ||imasdk.googleapis.com/js/sdkloader/ima3.js$script,redirect=google-ima3
     * ```
     */

    function GoogleIma3(source) {
      const VERSION = '3.453.0';
      const ima = {};
      const AdDisplayContainer = function AdDisplayContainer() {};
      AdDisplayContainer.prototype.destroy = noopFunc;
      AdDisplayContainer.prototype.initialize = noopFunc;
      const ImaSdkSettings = function ImaSdkSettings() {};
      ImaSdkSettings.CompanionBackfillMode = {
        ALWAYS: 'always',
        ON_MASTER_AD: 'on_master_ad'
      };
      ImaSdkSettings.VpaidMode = {
        DISABLED: 0,
        ENABLED: 1,
        INSECURE: 2
      };
      ImaSdkSettings.prototype = {
        c: true,
        f: {},
        i: false,
        l: '',
        p: '',
        r: 0,
        t: '',
        v: '',
        getCompanionBackfill: noopFunc,
        getDisableCustomPlaybackForIOS10Plus() {
          return this.i;
        },
        getDisabledFlashAds: function getDisabledFlashAds() {
          return true;
        },
        getFeatureFlags() {
          return this.f;
        },
        getLocale() {
          return this.l;
        },
        getNumRedirects() {
          return this.r;
        },
        getPlayerType() {
          return this.t;
        },
        getPlayerVersion() {
          return this.v;
        },
        getPpid() {
          return this.p;
        },
        getVpaidMode() {
          return this.C;
        },
        isCookiesEnabled() {
          return this.c;
        },
        isVpaidAdapter() {
          return this.M;
        },
        setCompanionBackfill: noopFunc,
        setAutoPlayAdBreaks(a) {
          this.K = a;
        },
        setCookiesEnabled(c) {
          this.c = !!c;
        },
        setDisableCustomPlaybackForIOS10Plus(i) {
          this.i = !!i;
        },
        setDisableFlashAds: noopFunc,
        setFeatureFlags(f) {
          this.f = !!f;
        },
        setIsVpaidAdapter(a) {
          this.M = a;
        },
        setLocale(l) {
          this.l = !!l;
        },
        setNumRedirects(r) {
          this.r = !!r;
        },
        setPageCorrelator(a) {
          this.R = a;
        },
        setPlayerType(t) {
          this.t = !!t;
        },
        setPlayerVersion(v) {
          this.v = !!v;
        },
        setPpid(p) {
          this.p = !!p;
        },
        setVpaidMode(a) {
          this.C = a;
        },
        setSessionId: noopFunc,
        setStreamCorrelator: noopFunc,
        setVpaidAllowed: noopFunc,
        CompanionBackfillMode: {
          ALWAYS: 'always',
          ON_MASTER_AD: 'on_master_ad'
        },
        VpaidMode: {
          DISABLED: 0,
          ENABLED: 1,
          INSECURE: 2
        }
      };
      const EventHandler = function EventHandler() {
        this.listeners = new Map();
        this._dispatch = function (e) {
          const listeners = this.listeners.get(e.type) || [];
          // eslint-disable-next-line no-restricted-syntax
          for (var _i = 0, _Array$from = Array.from(listeners); _i < _Array$from.length; _i++) {
            const listener = _Array$from[_i];
            try {
              listener(e);
            } catch (r) {
              logMessage(source, r);
            }
          }
        };
        this.addEventListener = function (t, c) {
          if (!this.listeners.has(t)) {
            this.listeners.set(t, new Set());
          }
          this.listeners.get(t).add(c);
        };
        this.removeEventListener = function (t, c) {
          var _this$listeners$get;
          (_this$listeners$get = this.listeners.get(t)) === null || _this$listeners$get === void 0 ? void 0 : _this$listeners$get.delete(c);
        };
      };
      const AdsManager = new EventHandler();
      /* eslint-disable no-use-before-define */
      AdsManager.volume = 1;
      AdsManager.collapse = noopFunc;
      AdsManager.configureAdsManager = noopFunc;
      AdsManager.destroy = noopFunc;
      AdsManager.discardAdBreak = noopFunc;
      AdsManager.expand = noopFunc;
      AdsManager.focus = noopFunc;
      AdsManager.getAdSkippableState = function () {
        return false;
      };
      AdsManager.getCuePoints = function () {
        return [0];
      };
      AdsManager.getCurrentAd = function () {
        return currentAd;
      };
      AdsManager.getCurrentAdCuePoints = function () {
        return [];
      };
      AdsManager.getRemainingTime = function () {
        return 0;
      };
      AdsManager.getVolume = function () {
        return this.volume;
      };
      AdsManager.init = noopFunc;
      AdsManager.isCustomClickTrackingUsed = function () {
        return false;
      };
      AdsManager.isCustomPlaybackUsed = function () {
        return false;
      };
      AdsManager.pause = noopFunc;
      AdsManager.requestNextAdBreak = noopFunc;
      AdsManager.resize = noopFunc;
      AdsManager.resume = noopFunc;
      AdsManager.setVolume = function (v) {
        this.volume = v;
      };
      AdsManager.skip = noopFunc;
      AdsManager.start = function () {
        // eslint-disable-next-line no-restricted-syntax
        for (var _i2 = 0, _arr = [AdEvent.Type.ALL_ADS_COMPLETED, AdEvent.Type.CONTENT_RESUME_REQUESTED]; _i2 < _arr.length; _i2++) {
          const type = _arr[_i2];
          try {
            this._dispatch(new ima.AdEvent(type));
          } catch (e) {
            logMessage(source, e);
          }
        }
      };
      AdsManager.stop = noopFunc;
      AdsManager.updateAdsRenderingSettings = noopFunc;
      /* eslint-enable no-use-before-define */

      const manager = Object.create(AdsManager);
      const AdsManagerLoadedEvent = function AdsManagerLoadedEvent(type, adsRequest, userRequestContext) {
        this.type = type;
        this.adsRequest = adsRequest;
        this.userRequestContext = userRequestContext;
      };
      AdsManagerLoadedEvent.prototype = {
        getAdsManager: function getAdsManager() {
          return manager;
        },
        getUserRequestContext() {
          if (this.userRequestContext) {
            return this.userRequestContext;
          }
          return {};
        }
      };
      AdsManagerLoadedEvent.Type = {
        ADS_MANAGER_LOADED: 'adsManagerLoaded'
      };
      const AdsLoader = EventHandler;
      AdsLoader.prototype.settings = new ImaSdkSettings();
      AdsLoader.prototype.contentComplete = noopFunc;
      AdsLoader.prototype.destroy = noopFunc;
      AdsLoader.prototype.getSettings = function () {
        return this.settings;
      };
      AdsLoader.prototype.getVersion = function () {
        return VERSION;
      };
      AdsLoader.prototype.requestAds = function (adsRequest, userRequestContext) {
        var _this = this;
        requestAnimationFrame(function () {
          const ADS_MANAGER_LOADED = AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED;
          const event = new ima.AdsManagerLoadedEvent(ADS_MANAGER_LOADED, adsRequest, userRequestContext);
          _this._dispatch(event);
        });
        const e = new ima.AdError('adPlayError', 1205, 1205, 'The browser prevented playback initiated without user interaction.', adsRequest, userRequestContext);
        requestAnimationFrame(function () {
          _this._dispatch(new ima.AdErrorEvent(e));
        });
      };
      const AdsRenderingSettings = noopFunc;
      const AdsRequest = function AdsRequest() {};
      AdsRequest.prototype = {
        setAdWillAutoPlay: noopFunc,
        setAdWillPlayMuted: noopFunc,
        setContinuousPlayback: noopFunc
      };
      const AdPodInfo = function AdPodInfo() {};
      AdPodInfo.prototype = {
        getAdPosition: function getAdPosition() {
          return 1;
        },
        getIsBumper: function getIsBumper() {
          return false;
        },
        getMaxDuration: function getMaxDuration() {
          return -1;
        },
        getPodIndex: function getPodIndex() {
          return 1;
        },
        getTimeOffset: function getTimeOffset() {
          return 0;
        },
        getTotalAds: function getTotalAds() {
          return 1;
        }
      };
      const Ad = function Ad() {};
      Ad.prototype = {
        pi: new AdPodInfo(),
        getAdId: function getAdId() {
          return '';
        },
        getAdPodInfo() {
          return this.pi;
        },
        getAdSystem: function getAdSystem() {
          return '';
        },
        getAdvertiserName: function getAdvertiserName() {
          return '';
        },
        getApiFramework: function getApiFramework() {
          return null;
        },
        getCompanionAds: function getCompanionAds() {
          return [];
        },
        getContentType: function getContentType() {
          return '';
        },
        getCreativeAdId: function getCreativeAdId() {
          return '';
        },
        getDealId: function getDealId() {
          return '';
        },
        getDescription: function getDescription() {
          return '';
        },
        getDuration: function getDuration() {
          return 8.5;
        },
        getHeight: function getHeight() {
          return 0;
        },
        getMediaUrl: function getMediaUrl() {
          return null;
        },
        getMinSuggestedDuration: function getMinSuggestedDuration() {
          return -2;
        },
        getSkipTimeOffset: function getSkipTimeOffset() {
          return -1;
        },
        getSurveyUrl: function getSurveyUrl() {
          return null;
        },
        getTitle: function getTitle() {
          return '';
        },
        getTraffickingParametersString: function getTraffickingParametersString() {
          return '';
        },
        getUiElements: function getUiElements() {
          return [''];
        },
        getUniversalAdIdRegistry: function getUniversalAdIdRegistry() {
          return 'unknown';
        },
        getUniversalAdIds: function getUniversalAdIds() {
          return [''];
        },
        getUniversalAdIdValue: function getUniversalAdIdValue() {
          return 'unknown';
        },
        getVastMediaBitrate: function getVastMediaBitrate() {
          return 0;
        },
        getVastMediaHeight: function getVastMediaHeight() {
          return 0;
        },
        getVastMediaWidth: function getVastMediaWidth() {
          return 0;
        },
        getWidth: function getWidth() {
          return 0;
        },
        getWrapperAdIds: function getWrapperAdIds() {
          return [''];
        },
        getWrapperAdSystems: function getWrapperAdSystems() {
          return [''];
        },
        getWrapperCreativeIds: function getWrapperCreativeIds() {
          return [''];
        },
        isLinear: function isLinear() {
          return true;
        },
        isSkippable() {
          return true;
        }
      };
      const CompanionAd = function CompanionAd() {};
      CompanionAd.prototype = {
        getAdSlotId: function getAdSlotId() {
          return '';
        },
        getContent: function getContent() {
          return '';
        },
        getContentType: function getContentType() {
          return '';
        },
        getHeight: function getHeight() {
          return 1;
        },
        getWidth: function getWidth() {
          return 1;
        }
      };
      const AdError = function AdError(type, code, vast, message, adsRequest, userRequestContext) {
        this.errorCode = code;
        this.message = message;
        this.type = type;
        this.adsRequest = adsRequest;
        this.userRequestContext = userRequestContext;
        this.getErrorCode = function () {
          return this.errorCode;
        };
        this.getInnerError = function () {};
        this.getMessage = function () {
          return this.message;
        };
        this.getType = function () {
          return this.type;
        };
        this.getVastErrorCode = function () {
          return this.vastErrorCode;
        };
        this.toString = function () {
          return "AdError ".concat(this.errorCode, ": ").concat(this.message);
        };
      };
      AdError.ErrorCode = {};
      AdError.Type = {};
      const isEngadget = function isEngadget() {
        try {
          // eslint-disable-next-line no-restricted-syntax
          for (var _i3 = 0, _Object$values = Object.values(window.vidible._getContexts()); _i3 < _Object$values.length; _i3++) {
            var _ctx$getPlayer, _ctx$getPlayer$div;
            const ctx = _Object$values[_i3];
            // eslint-disable-next-line no-restricted-properties
            if ((_ctx$getPlayer = ctx.getPlayer()) !== null && _ctx$getPlayer !== void 0 && (_ctx$getPlayer$div = _ctx$getPlayer.div) !== null && _ctx$getPlayer$div !== void 0 && _ctx$getPlayer$div.innerHTML.includes('www.engadget.com')) {
              return true;
            }
          }
        } catch (e) {} // eslint-disable-line no-empty
        return false;
      };
      const currentAd = isEngadget() ? undefined : new Ad();
      const AdEvent = function AdEvent(type) {
        this.type = type;
      };
      AdEvent.prototype = {
        getAd: function getAd() {
          return currentAd;
        },
        getAdData: function getAdData() {}
      };
      AdEvent.Type = {
        AD_BREAK_READY: 'adBreakReady',
        AD_BUFFERING: 'adBuffering',
        AD_CAN_PLAY: 'adCanPlay',
        AD_METADATA: 'adMetadata',
        AD_PROGRESS: 'adProgress',
        ALL_ADS_COMPLETED: 'allAdsCompleted',
        CLICK: 'click',
        COMPLETE: 'complete',
        CONTENT_PAUSE_REQUESTED: 'contentPauseRequested',
        CONTENT_RESUME_REQUESTED: 'contentResumeRequested',
        DURATION_CHANGE: 'durationChange',
        EXPANDED_CHANGED: 'expandedChanged',
        FIRST_QUARTILE: 'firstQuartile',
        IMPRESSION: 'impression',
        INTERACTION: 'interaction',
        LINEAR_CHANGE: 'linearChange',
        LINEAR_CHANGED: 'linearChanged',
        LOADED: 'loaded',
        LOG: 'log',
        MIDPOINT: 'midpoint',
        PAUSED: 'pause',
        RESUMED: 'resume',
        SKIPPABLE_STATE_CHANGED: 'skippableStateChanged',
        SKIPPED: 'skip',
        STARTED: 'start',
        THIRD_QUARTILE: 'thirdQuartile',
        USER_CLOSE: 'userClose',
        VIDEO_CLICKED: 'videoClicked',
        VIDEO_ICON_CLICKED: 'videoIconClicked',
        VIEWABLE_IMPRESSION: 'viewable_impression',
        VOLUME_CHANGED: 'volumeChange',
        VOLUME_MUTED: 'mute'
      };
      const AdErrorEvent = function AdErrorEvent(error) {
        this.error = error;
        this.type = 'adError';
        this.getError = function () {
          return this.error;
        };
        this.getUserRequestContext = function () {
          var _this$error;
          if ((_this$error = this.error) !== null && _this$error !== void 0 && _this$error.userRequestContext) {
            return this.error.userRequestContext;
          }
          return {};
        };
      };
      AdErrorEvent.Type = {
        AD_ERROR: 'adError'
      };
      const CustomContentLoadedEvent = function CustomContentLoadedEvent() {};
      CustomContentLoadedEvent.Type = {
        CUSTOM_CONTENT_LOADED: 'deprecated-event'
      };
      const CompanionAdSelectionSettings = function CompanionAdSelectionSettings() {};
      CompanionAdSelectionSettings.CreativeType = {
        ALL: 'All',
        FLASH: 'Flash',
        IMAGE: 'Image'
      };
      CompanionAdSelectionSettings.ResourceType = {
        ALL: 'All',
        HTML: 'Html',
        IFRAME: 'IFrame',
        STATIC: 'Static'
      };
      CompanionAdSelectionSettings.SizeCriteria = {
        IGNORE: 'IgnoreSize',
        SELECT_EXACT_MATCH: 'SelectExactMatch',
        SELECT_NEAR_MATCH: 'SelectNearMatch'
      };
      const AdCuePoints = function AdCuePoints() {};
      AdCuePoints.prototype = {
        getCuePoints: function getCuePoints() {
          return [];
        },
        getAdIdRegistry: function getAdIdRegistry() {
          return '';
        },
        getAdIsValue: function getAdIsValue() {
          return '';
        }
      };
      const AdProgressData = noopFunc;
      const UniversalAdIdInfo = function UniversalAdIdInfo() {};
      Object.assign(ima, {
        AdCuePoints,
        AdDisplayContainer,
        AdError,
        AdErrorEvent,
        AdEvent,
        AdPodInfo,
        AdProgressData,
        AdsLoader,
        AdsManager: manager,
        AdsManagerLoadedEvent,
        AdsRenderingSettings,
        AdsRequest,
        CompanionAd,
        CompanionAdSelectionSettings,
        CustomContentLoadedEvent,
        gptProxyInstance: {},
        ImaSdkSettings,
        OmidAccessMode: {
          DOMAIN: 'domain',
          FULL: 'full',
          LIMITED: 'limited'
        },
        settings: new ImaSdkSettings(),
        UiElements: {
          AD_ATTRIBUTION: 'adAttribution',
          COUNTDOWN: 'countdown'
        },
        UniversalAdIdInfo,
        VERSION,
        ViewMode: {
          FULLSCREEN: 'fullscreen',
          NORMAL: 'normal'
        }
      });
      if (!window.google) {
        window.google = {};
      }
      window.google.ima = ima;
      hit(source);
    }
    GoogleIma3.names = ['google-ima3',
    // prefixed name
    'ubo-google-ima.js',
    // original ubo name
    'google-ima.js'];
    GoogleIma3.injections = [hit, noopFunc, logMessage];

    /* eslint-disable func-names, no-underscore-dangle */

    /**
     * @redirect didomi-loader
     * @description
     * Mocks Didomi's CMP loader script.
     * https://developers.didomi.io/
     *
     * **Example**
     * ```
     * ||sdk.privacy-center.org/fbf86806f86e/loader.js$script,redirect=didomi-loader
     * ```
     */
    function DidomiLoader(source) {
      function UserConsentStatusForVendorSubscribe() {}
      UserConsentStatusForVendorSubscribe.prototype.filter = function () {
        return new UserConsentStatusForVendorSubscribe();
      };
      UserConsentStatusForVendorSubscribe.prototype.subscribe = noopFunc;
      function UserConsentStatusForVendor() {}
      UserConsentStatusForVendor.prototype.first = function () {
        return new UserConsentStatusForVendorSubscribe();
      };
      UserConsentStatusForVendor.prototype.filter = function () {
        return new UserConsentStatusForVendorSubscribe();
      };
      UserConsentStatusForVendor.prototype.subscribe = noopFunc;
      const DidomiWrapper = {
        isConsentRequired: falseFunc,
        getUserConsentStatusForPurpose: trueFunc,
        getUserConsentStatus: trueFunc,
        getUserStatus: noopFunc,
        getRequiredPurposes: noopArray,
        getUserConsentStatusForVendor: trueFunc,
        Purposes: {
          Cookies: 'cookies'
        },
        notice: {
          configure: noopFunc,
          hide: noopFunc,
          isVisible: falseFunc,
          show: noopFunc,
          showDataProcessing: trueFunc
        },
        isUserConsentStatusPartial: falseFunc,
        on() {
          return {
            actions: {},
            emitter: {},
            services: {},
            store: {}
          };
        },
        shouldConsentBeCollected: falseFunc,
        getUserConsentStatusForAll: noopFunc,
        getObservableOnUserConsentStatusForVendor() {
          return new UserConsentStatusForVendor();
        }
      };
      window.Didomi = DidomiWrapper;
      const didomiStateWrapper = {
        didomiExperimentId: '',
        didomiExperimentUserGroup: '',
        didomiGDPRApplies: 1,
        didomiIABConsent: '',
        didomiPurposesConsent: '',
        didomiPurposesConsentDenied: '',
        didomiPurposesConsentUnknown: '',
        didomiVendorsConsent: '',
        didomiVendorsConsentDenied: '',
        didomiVendorsConsentUnknown: '',
        didomiVendorsRawConsent: '',
        didomiVendorsRawConsentDenied: '',
        didomiVendorsRawConsentUnknown: ''
      };
      window.didomiState = didomiStateWrapper;
      const tcData = {
        eventStatus: 'tcloaded',
        gdprApplies: false,
        listenerId: noopFunc,
        vendor: {
          consents: []
        },
        purpose: {
          consents: []
        }
      };

      // https://github.com/InteractiveAdvertisingBureau/GDPR-Transparency-and-Consent-Framework/blob/master/TCFv2/IAB%20Tech%20Lab%20-%20CMP%20API%20v2.md#how-does-the-cmp-provide-the-api
      const __tcfapiWrapper = function __tcfapiWrapper(command, version, callback) {
        if (typeof callback !== 'function' || command === 'removeEventListener') {
          return;
        }
        callback(tcData, true);
      };
      window.__tcfapi = __tcfapiWrapper;
      const didomiEventListenersWrapper = {
        stub: true,
        push: noopFunc
      };
      window.didomiEventListeners = didomiEventListenersWrapper;
      const didomiOnReadyWrapper = {
        stub: true,
        push(arg) {
          if (typeof arg !== 'function') {
            return;
          }
          if (document.readyState !== 'complete') {
            window.addEventListener('load', function () {
              setTimeout(arg(window.Didomi));
            });
          } else {
            setTimeout(arg(window.Didomi));
          }
        }
      };
      window.didomiOnReady = window.didomiOnReady || didomiOnReadyWrapper;
      if (Array.isArray(window.didomiOnReady)) {
        window.didomiOnReady.forEach(function (arg) {
          if (typeof arg === 'function') {
            try {
              setTimeout(arg(window.Didomi));
            } catch (e) {
              /* empty */
            }
          }
        });
      }
      hit(source);
    }
    DidomiLoader.names = ['didomi-loader'];
    DidomiLoader.injections = [hit, noopFunc, noopArray, trueFunc, falseFunc];

    /* eslint-disable func-names */

    /**
     * @redirect prebid
     * @description
     * Mocks the prebid.js header bidding suit.
     * https://docs.prebid.org/
     *
     * **Example**
     * ```
     * ||tmgrup.com.tr/bd/hb/prebid.js$script,redirect=prebid
     * ```
     */

    function Prebid(source) {
      const pushFunction = function pushFunction(arg) {
        if (typeof arg === 'function') {
          try {
            arg.call();
          } catch (ex) {
            /* empty */
          }
        }
      };
      const pbjsWrapper = {
        addAdUnits() {},
        adServers: {
          dfp: {
            // https://docs.prebid.org/dev-docs/publisher-api-reference/adServers.dfp.buildVideoUrl.html
            // returns ad URL
            buildVideoUrl: noopStr
          }
        },
        adUnits: [],
        aliasBidder() {},
        cmd: [],
        enableAnalytics() {},
        getHighestCpmBids: noopArray,
        libLoaded: true,
        que: [],
        requestBids(arg) {
          if (arg instanceof Object && arg.bidsBackHandler) {
            try {
              arg.bidsBackHandler.call(); // https://docs.prebid.org/dev-docs/publisher-api-reference/requestBids.html
            } catch (ex) {
              /* empty */
            }
          }
        },
        removeAdUnit() {},
        setBidderConfig() {},
        setConfig() {},
        setTargetingForGPTAsync() {}
      };
      pbjsWrapper.cmd.push = pushFunction;
      pbjsWrapper.que.push = pushFunction;
      window.pbjs = pbjsWrapper;
      hit(source);
    }
    Prebid.names = ['prebid'];
    Prebid.injections = [hit, noopFunc, noopStr, noopArray];

    /* eslint-disable func-names */

    /**
     * @redirect prebid-ads
     * @description
     * Sets predefined constants on a page:
     * - `canRunAds`: `true`
     * - `isAdBlockActive`: `false`
     *
     * **Example**
     * ```
     * ||playerdrive.me/assets/js/prebid-ads.js$script,redirect=prebid-ads
     * ```
     */
    function prebidAds(source) {
      window.canRunAds = true;
      window.isAdBlockActive = false;
      hit(source);
    }
    prebidAds.names = ['prebid-ads', 'ubo-prebid-ads.js', 'prebid-ads.js'];
    prebidAds.injections = [hit];

    /* eslint-disable func-names */

    /**
     * @redirect naver-wcslog
     * @description
     * Mocks wcslog.js of Naver Analytics.
     *
     * **Example**
     * ```
     * ||wcs.naver.net/wcslog.js$script,redirect=naver-wcslog
     * ```
     */

    function NaverWcslog(source) {
      window.wcs_add = {};
      window.wcs_do = noopFunc;
      window.wcs = {
        inflow: noopFunc
      };
      hit(source);
    }
    NaverWcslog.names = ['naver-wcslog'];
    NaverWcslog.injections = [hit, noopFunc];

    var redirectsList = /*#__PURE__*/Object.freeze({
        __proto__: null,
        noeval: noeval$1,
        GoogleAnalytics: GoogleAnalytics,
        GoogleAnalyticsGa: GoogleAnalyticsGa,
        GoogleSyndicationAdsByGoogle: GoogleSyndicationAdsByGoogle,
        GoogleTagServicesGpt: GoogleTagServicesGpt,
        ScoreCardResearchBeacon: ScoreCardResearchBeacon,
        metrikaYandexTag: metrikaYandexTag,
        metrikaYandexWatch: metrikaYandexWatch,
        Pardot: Pardot,
        preventFab: preventFab$1,
        preventBab: preventBab$1,
        setPopadsDummy: setPopadsDummy$1,
        preventPopadsNet: preventPopadsNet$1,
        AmazonApstag: AmazonApstag,
        Matomo: Matomo,
        Fingerprintjs2: Fingerprintjs2,
        Fingerprintjs3: Fingerprintjs3,
        Gemius: Gemius,
        ATInternetSmartTag: ATInternetSmartTag,
        preventBab2: preventBab2,
        GoogleIma3: GoogleIma3,
        DidomiLoader: DidomiLoader,
        Prebid: Prebid,
        prebidAds: prebidAds,
        NaverWcslog: NaverWcslog
    });

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var defineProperty = _defineProperty;

    function isNothing(subject) {
      return typeof subject === 'undefined' || subject === null;
    }
    function isObject(subject) {
      return typeof subject === 'object' && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];
      return [sequence];
    }
    function extend(target, source) {
      var index, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key = sourceKeys[index];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = '',
        cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    var isNothing_1 = isNothing;
    var isObject_1 = isObject;
    var toArray_1 = toArray;
    var repeat_1 = repeat;
    var isNegativeZero_1 = isNegativeZero;
    var extend_1 = extend;
    var common = {
      isNothing: isNothing_1,
      isObject: isObject_1,
      toArray: toArray_1,
      repeat: repeat_1,
      isNegativeZero: isNegativeZero_1,
      extend: extend_1
    };

    // YAML error class. http://stackoverflow.com/questions/8458984

    function YAMLException$1(reason, mark) {
      // Super constructor
      Error.call(this);
      this.name = 'YAMLException';
      this.reason = reason;
      this.mark = mark;
      this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

      // Include stack trace in error object
      if (Error.captureStackTrace) {
        // Chrome and NodeJS
        Error.captureStackTrace(this, this.constructor);
      } else {
        // FF, IE 10+ and Safari 6+. Fallback for others
        this.stack = new Error().stack || '';
      }
    }

    // Inherit from Error
    YAMLException$1.prototype = Object.create(Error.prototype);
    YAMLException$1.prototype.constructor = YAMLException$1;
    YAMLException$1.prototype.toString = function toString(compact) {
      var result = this.name + ': ';
      result += this.reason || '(unknown reason)';
      if (!compact && this.mark) {
        result += ' ' + this.mark.toString();
      }
      return result;
    };
    var exception = YAMLException$1;

    function Mark(name, buffer, position, line, column) {
      this.name = name;
      this.buffer = buffer;
      this.position = position;
      this.line = line;
      this.column = column;
    }
    Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
      var head, start, tail, end, snippet;
      if (!this.buffer) return null;
      indent = indent || 4;
      maxLength = maxLength || 75;
      head = '';
      start = this.position;
      while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
        start -= 1;
        if (this.position - start > maxLength / 2 - 1) {
          head = ' ... ';
          start += 5;
          break;
        }
      }
      tail = '';
      end = this.position;
      while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
        end += 1;
        if (end - this.position > maxLength / 2 - 1) {
          tail = ' ... ';
          end -= 5;
          break;
        }
      }
      snippet = this.buffer.slice(start, end);
      return common.repeat(' ', indent) + head + snippet + tail + '\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';
    };
    Mark.prototype.toString = function toString(compact) {
      var snippet,
        where = '';
      if (this.name) {
        where += 'in "' + this.name + '" ';
      }
      where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);
      if (!compact) {
        snippet = this.getSnippet();
        if (snippet) {
          where += ':\n' + snippet;
        }
      }
      return where;
    };
    var mark = Mark;

    var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];
    var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function (style) {
          map[style].forEach(function (alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type$1(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function (name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });

      // TODO: Add tag format check.
      this.tag = tag;
      this.kind = options['kind'] || null;
      this.resolve = options['resolve'] || function () {
        return true;
      };
      this.construct = options['construct'] || function (data) {
        return data;
      };
      this.instanceOf = options['instanceOf'] || null;
      this.predicate = options['predicate'] || null;
      this.represent = options['represent'] || null;
      this.defaultStyle = options['defaultStyle'] || null;
      this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    var type = Type$1;

    /*eslint-disable max-len*/

    function compileList(schema, name, result) {
      var exclude = [];
      schema.include.forEach(function (includedSchema) {
        result = compileList(includedSchema, name, result);
      });
      schema[name].forEach(function (currentType) {
        result.forEach(function (previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
            exclude.push(previousIndex);
          }
        });
        result.push(currentType);
      });
      return result.filter(function (type, index) {
        return exclude.indexOf(index) === -1;
      });
    }
    function compileMap( /* lists... */
    ) {
      var result = {
          scalar: {},
          sequence: {},
          mapping: {},
          fallback: {}
        },
        index,
        length;
      function collectType(type) {
        result[type.kind][type.tag] = result['fallback'][type.tag] = type;
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema$1(definition) {
      this.include = definition.include || [];
      this.implicit = definition.implicit || [];
      this.explicit = definition.explicit || [];
      this.implicit.forEach(function (type) {
        if (type.loadKind && type.loadKind !== 'scalar') {
          throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
        }
      });
      this.compiledImplicit = compileList(this, 'implicit', []);
      this.compiledExplicit = compileList(this, 'explicit', []);
      this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
    }
    Schema$1.DEFAULT = null;
    Schema$1.create = function createSchema() {
      var schemas, types;
      switch (arguments.length) {
        case 1:
          schemas = Schema$1.DEFAULT;
          types = arguments[0];
          break;
        case 2:
          schemas = arguments[0];
          types = arguments[1];
          break;
        default:
          throw new exception('Wrong number of arguments for Schema.create function');
      }
      schemas = common.toArray(schemas);
      types = common.toArray(types);
      if (!schemas.every(function (schema) {
        return schema instanceof Schema$1;
      })) {
        throw new exception('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
      }
      if (!types.every(function (type$1) {
        return type$1 instanceof type;
      })) {
        throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
      }
      return new Schema$1({
        include: schemas,
        explicit: types
      });
    };
    var schema = Schema$1;

    var str = new type('tag:yaml.org,2002:str', {
      kind: 'scalar',
      construct: function construct(data) {
        return data !== null ? data : '';
      }
    });

    var seq = new type('tag:yaml.org,2002:seq', {
      kind: 'sequence',
      construct: function construct(data) {
        return data !== null ? data : [];
      }
    });

    var map = new type('tag:yaml.org,2002:map', {
      kind: 'mapping',
      construct: function construct(data) {
        return data !== null ? data : {};
      }
    });

    var failsafe = new schema({
      explicit: [str, seq, map]
    });

    function resolveYamlNull(data) {
      if (data === null) return true;
      var max = data.length;
      return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    var _null = new type('tag:yaml.org,2002:null', {
      kind: 'scalar',
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function canonical() {
          return '~';
        },
        lowercase: function lowercase() {
          return 'null';
        },
        uppercase: function uppercase() {
          return 'NULL';
        },
        camelcase: function camelcase() {
          return 'Null';
        }
      },
      defaultStyle: 'lowercase'
    });

    function resolveYamlBoolean(data) {
      if (data === null) return false;
      var max = data.length;
      return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
    }
    function constructYamlBoolean(data) {
      return data === 'true' || data === 'True' || data === 'TRUE';
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === '[object Boolean]';
    }
    var bool = new type('tag:yaml.org,2002:bool', {
      kind: 'scalar',
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function lowercase(object) {
          return object ? 'true' : 'false';
        },
        uppercase: function uppercase(object) {
          return object ? 'TRUE' : 'FALSE';
        },
        camelcase: function camelcase(object) {
          return object ? 'True' : 'False';
        }
      },
      defaultStyle: 'lowercase'
    });

    function isHexCode(c) {
      return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */ || 0x41 /* A */ <= c && c <= 0x46 /* F */ || 0x61 /* a */ <= c && c <= 0x66 /* f */;
    }

    function isOctCode(c) {
      return 0x30 /* 0 */ <= c && c <= 0x37 /* 7 */;
    }

    function isDecCode(c) {
      return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */;
    }

    function resolveYamlInteger(data) {
      if (data === null) return false;
      var max = data.length,
        index = 0,
        hasDigits = false,
        ch;
      if (!max) return false;
      ch = data[index];

      // sign
      if (ch === '-' || ch === '+') {
        ch = data[++index];
      }
      if (ch === '0') {
        // 0
        if (index + 1 === max) return true;
        ch = data[++index];

        // base 2, base 8, base 16

        if (ch === 'b') {
          // base 2
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === '_') continue;
            if (ch !== '0' && ch !== '1') return false;
            hasDigits = true;
          }
          return hasDigits && ch !== '_';
        }
        if (ch === 'x') {
          // base 16
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === '_') continue;
            if (!isHexCode(data.charCodeAt(index))) return false;
            hasDigits = true;
          }
          return hasDigits && ch !== '_';
        }

        // base 8
        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (!isOctCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }

      // base 10 (except 0) or base 60

      // value should not start with `_`;
      if (ch === '_') return false;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch === ':') break;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }

      // Should have digits and should not end with `_`
      if (!hasDigits || ch === '_') return false;

      // if !base60 - done;
      if (ch !== ':') return true;

      // base60 almost not used, no needs to optimize
      return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
    }
    function constructYamlInteger(data) {
      var value = data,
        sign = 1,
        ch,
        base,
        digits = [];
      if (value.indexOf('_') !== -1) {
        value = value.replace(/_/g, '');
      }
      ch = value[0];
      if (ch === '-' || ch === '+') {
        if (ch === '-') sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === '0') return 0;
      if (ch === '0') {
        if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
        if (value[1] === 'x') return sign * parseInt(value, 16);
        return sign * parseInt(value, 8);
      }
      if (value.indexOf(':') !== -1) {
        value.split(':').forEach(function (v) {
          digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function (d) {
          value += d * base;
          base *= 60;
        });
        return sign * value;
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);
    }
    var int = new type('tag:yaml.org,2002:int', {
      kind: 'scalar',
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function binary(obj) {
          return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);
        },
        octal: function octal(obj) {
          return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1);
        },
        decimal: function decimal(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function hexadecimal(obj) {
          return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: 'decimal',
      styleAliases: {
        binary: [2, 'bin'],
        octal: [8, 'oct'],
        decimal: [10, 'dec'],
        hexadecimal: [16, 'hex']
      }
    });

    var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
    // .2e4, .2
    // special case, seems not from spec
    '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
    // 20:59
    '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
    // .inf
    '|[-+]?\\.(?:inf|Inf|INF)' +
    // .nan
    '|\\.(?:nan|NaN|NAN))$');
    function resolveYamlFloat(data) {
      if (data === null) return false;
      if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign, base, digits;
      value = data.replace(/_/g, '').toLowerCase();
      sign = value[0] === '-' ? -1 : 1;
      digits = [];
      if ('+-'.indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === '.inf') {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === '.nan') {
        return NaN;
      } else if (value.indexOf(':') >= 0) {
        value.split(':').forEach(function (v) {
          digits.unshift(parseFloat(v, 10));
        });
        value = 0.0;
        base = 1;
        digits.forEach(function (d) {
          value += d * base;
          base *= 60;
        });
        return sign * value;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case 'lowercase':
            return '.nan';
          case 'uppercase':
            return '.NAN';
          case 'camelcase':
            return '.NaN';
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case 'lowercase':
            return '.inf';
          case 'uppercase':
            return '.INF';
          case 'camelcase':
            return '.Inf';
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case 'lowercase':
            return '-.inf';
          case 'uppercase':
            return '-.INF';
          case 'camelcase':
            return '-.Inf';
        }
      } else if (common.isNegativeZero(object)) {
        return '-0.0';
      }
      res = object.toString(10);

      // JS stringifier can build scientific format without dots: 5e-100,
      // while YAML requres dot: 5.e-100. Fix it with simple hack

      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    var float = new type('tag:yaml.org,2002:float', {
      kind: 'scalar',
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: 'lowercase'
    });

    var json = new schema({
      include: [failsafe],
      implicit: [_null, bool, int, float]
    });

    var core = new schema({
      include: [json]
    });

    var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +
    // [1] year
    '-([0-9][0-9])' +
    // [2] month
    '-([0-9][0-9])$'); // [3] day

    var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +
    // [1] year
    '-([0-9][0-9]?)' +
    // [2] month
    '-([0-9][0-9]?)' +
    // [3] day
    '(?:[Tt]|[ \\t]+)' +
    // ...
    '([0-9][0-9]?)' +
    // [4] hour
    ':([0-9][0-9])' +
    // [5] minute
    ':([0-9][0-9])' +
    // [6] second
    '(?:\\.([0-9]*))?' +
    // [7] fraction
    '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' +
    // [8] tz [9] tz_sign [10] tz_hour
    '(?::([0-9][0-9]))?))?$'); // [11] tz_minute

    function resolveYamlTimestamp(data) {
      if (data === null) return false;
      if (YAML_DATE_REGEXP.exec(data) !== null) return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match,
        year,
        month,
        day,
        hour,
        minute,
        second,
        fraction = 0,
        delta = null,
        tz_hour,
        tz_minute,
        date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null) throw new Error('Date resolve error');

      // match: [1] year [2] month [3] day

      year = +match[1];
      month = +match[2] - 1; // JS month starts with 0
      day = +match[3];
      if (!match[4]) {
        // no hour
        return new Date(Date.UTC(year, month, day));
      }

      // match: [4] hour [5] minute [6] second [7] fraction

      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          // milli-seconds
          fraction += '0';
        }
        fraction = +fraction;
      }

      // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
        if (match[9] === '-') delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta) date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object /*, style*/) {
      return object.toISOString();
    }
    var timestamp = new type('tag:yaml.org,2002:timestamp', {
      kind: 'scalar',
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });

    function resolveYamlMerge(data) {
      return data === '<<' || data === null;
    }
    var merge = new type('tag:yaml.org,2002:merge', {
      kind: 'scalar',
      resolve: resolveYamlMerge
    });

    function commonjsRequire (target) {
    	throw new Error('Could not dynamically require "' + target + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
    }

    /*eslint-disable no-bitwise*/

    var NodeBuffer;
    try {
      // A trick for browserified version, to not include `Buffer` shim
      var _require$1 = commonjsRequire;
      NodeBuffer = _require$1('buffer').Buffer;
    } catch (__) {}

    // [ 64, 65, 66 ] -> [ padding, CR, LF ]
    var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
    function resolveYamlBinary(data) {
      if (data === null) return false;
      var code,
        idx,
        bitlen = 0,
        max = data.length,
        map = BASE64_MAP;

      // Convert one by one.
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));

        // Skip CR/LF
        if (code > 64) continue;

        // Fail on illegal characters
        if (code < 0) return false;
        bitlen += 6;
      }

      // If there are any bits left, source was corrupted
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx,
        tailbits,
        input = data.replace(/[\r\n=]/g, ''),
        // remove CR/LF & padding to simplify scan
        max = input.length,
        map = BASE64_MAP,
        bits = 0,
        result = [];

      // Collect by 6*4 bits (3 bytes)

      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 0xFF);
          result.push(bits >> 8 & 0xFF);
          result.push(bits & 0xFF);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }

      // Dump tail

      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 0xFF);
        result.push(bits >> 8 & 0xFF);
        result.push(bits & 0xFF);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 0xFF);
        result.push(bits >> 2 & 0xFF);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 0xFF);
      }

      // Wrap into Buffer for NodeJS and leave Array for browser
      if (NodeBuffer) {
        // Support node 6.+ Buffer API when available
        return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
      }
      return result;
    }
    function representYamlBinary(object /*, style*/) {
      var result = '',
        bits = 0,
        idx,
        tail,
        max = object.length,
        map = BASE64_MAP;

      // Convert every three bytes to 4 ASCII characters.

      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 0x3F];
          result += map[bits >> 12 & 0x3F];
          result += map[bits >> 6 & 0x3F];
          result += map[bits & 0x3F];
        }
        bits = (bits << 8) + object[idx];
      }

      // Dump tail

      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 0x3F];
        result += map[bits >> 12 & 0x3F];
        result += map[bits >> 6 & 0x3F];
        result += map[bits & 0x3F];
      } else if (tail === 2) {
        result += map[bits >> 10 & 0x3F];
        result += map[bits >> 4 & 0x3F];
        result += map[bits << 2 & 0x3F];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 0x3F];
        result += map[bits << 4 & 0x3F];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(object) {
      return NodeBuffer && NodeBuffer.isBuffer(object);
    }
    var binary = new type('tag:yaml.org,2002:binary', {
      kind: 'scalar',
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });

    var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    var _toString$2 = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null) return true;
      var objectKeys = [],
        index,
        length,
        pair,
        pairKey,
        pairHasKey,
        object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString$2.call(pair) !== '[object Object]') return false;
        for (pairKey in pair) {
          if (_hasOwnProperty$3.call(pair, pairKey)) {
            if (!pairHasKey) pairHasKey = true;else return false;
          }
        }
        if (!pairHasKey) return false;
        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    var omap = new type('tag:yaml.org,2002:omap', {
      kind: 'sequence',
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });

    var _toString$1 = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null) return true;
      var index,
        length,
        pair,
        keys,
        result,
        object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString$1.call(pair) !== '[object Object]') return false;
        keys = Object.keys(pair);
        if (keys.length !== 1) return false;
        result[index] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null) return [];
      var index,
        length,
        pair,
        keys,
        result,
        object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    var pairs = new type('tag:yaml.org,2002:pairs', {
      kind: 'sequence',
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });

    var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null) return true;
      var key,
        object = data;
      for (key in object) {
        if (_hasOwnProperty$2.call(object, key)) {
          if (object[key] !== null) return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    var set = new type('tag:yaml.org,2002:set', {
      kind: 'mapping',
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });

    var default_safe = new schema({
      include: [core],
      implicit: [timestamp, merge],
      explicit: [binary, omap, pairs, set]
    });

    function resolveJavascriptUndefined() {
      return true;
    }
    function constructJavascriptUndefined() {
      /*eslint-disable no-undefined*/
      return undefined;
    }
    function representJavascriptUndefined() {
      return '';
    }
    function isUndefined(object) {
      return typeof object === 'undefined';
    }
    var _undefined = new type('tag:yaml.org,2002:js/undefined', {
      kind: 'scalar',
      resolve: resolveJavascriptUndefined,
      construct: constructJavascriptUndefined,
      predicate: isUndefined,
      represent: representJavascriptUndefined
    });

    function resolveJavascriptRegExp(data) {
      if (data === null) return false;
      if (data.length === 0) return false;
      var regexp = data,
        tail = /\/([gim]*)$/.exec(data),
        modifiers = '';

      // if regexp starts with '/' it can have modifiers and must be properly closed
      // `/foo/gim` - modifiers tail can be maximum 3 chars
      if (regexp[0] === '/') {
        if (tail) modifiers = tail[1];
        if (modifiers.length > 3) return false;
        // if expression starts with /, is should be properly terminated
        if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
      }
      return true;
    }
    function constructJavascriptRegExp(data) {
      var regexp = data,
        tail = /\/([gim]*)$/.exec(data),
        modifiers = '';

      // `/foo/gim` - tail can be maximum 4 chars
      if (regexp[0] === '/') {
        if (tail) modifiers = tail[1];
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
      }
      return new RegExp(regexp, modifiers);
    }
    function representJavascriptRegExp(object /*, style*/) {
      var result = '/' + object.source + '/';
      if (object.global) result += 'g';
      if (object.multiline) result += 'm';
      if (object.ignoreCase) result += 'i';
      return result;
    }
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === '[object RegExp]';
    }
    var regexp = new type('tag:yaml.org,2002:js/regexp', {
      kind: 'scalar',
      resolve: resolveJavascriptRegExp,
      construct: constructJavascriptRegExp,
      predicate: isRegExp,
      represent: representJavascriptRegExp
    });

    var esprima;

    // Browserified version does not have esprima
    //
    // 1. For node.js just require module as deps
    // 2. For browser try to require mudule via external AMD system.
    //    If not found - try to fallback to window.esprima. If not
    //    found too - then fail to parse.
    //
    try {
      // workaround to exclude package from browserify list.
      var _require = commonjsRequire;
      esprima = _require('esprima');
    } catch (_) {
      /* eslint-disable no-redeclare */
      /* global window */
      if (typeof window !== 'undefined') esprima = window.esprima;
    }
    function resolveJavascriptFunction(data) {
      if (data === null) return false;
      try {
        var source = '(' + data + ')',
          ast = esprima.parse(source, {
            range: true
          });
        if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    function constructJavascriptFunction(data) {
      /*jslint evil:true*/

      var source = '(' + data + ')',
        ast = esprima.parse(source, {
          range: true
        }),
        params = [],
        body;
      if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
        throw new Error('Failed to resolve function');
      }
      ast.body[0].expression.params.forEach(function (param) {
        params.push(param.name);
      });
      body = ast.body[0].expression.body.range;

      // Esprima's ranges include the first '{' and the last '}' characters on
      // function expressions. So cut them out.
      if (ast.body[0].expression.body.type === 'BlockStatement') {
        /*eslint-disable no-new-func*/
        return new Function(params, source.slice(body[0] + 1, body[1] - 1));
      }
      // ES6 arrow functions can omit the BlockStatement. In that case, just return
      // the body.
      /*eslint-disable no-new-func*/
      return new Function(params, 'return ' + source.slice(body[0], body[1]));
    }
    function representJavascriptFunction(object /*, style*/) {
      return object.toString();
    }
    function isFunction(object) {
      return Object.prototype.toString.call(object) === '[object Function]';
    }
    var _function = new type('tag:yaml.org,2002:js/function', {
      kind: 'scalar',
      resolve: resolveJavascriptFunction,
      construct: constructJavascriptFunction,
      predicate: isFunction,
      represent: representJavascriptFunction
    });

    var default_full = schema.DEFAULT = new schema({
      include: [default_safe],
      explicit: [_undefined, regexp, _function]
    });

    /*eslint-disable max-len,no-use-before-define*/

    var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 0x0A /* LF */ || c === 0x0D /* CR */;
    }

    function is_WHITE_SPACE(c) {
      return c === 0x09 /* Tab */ || c === 0x20 /* Space */;
    }

    function is_WS_OR_EOL(c) {
      return c === 0x09 /* Tab */ || c === 0x20 /* Space */ || c === 0x0A /* LF */ || c === 0x0D /* CR */;
    }

    function is_FLOW_INDICATOR(c) {
      return c === 0x2C /* , */ || c === 0x5B /* [ */ || c === 0x5D /* ] */ || c === 0x7B /* { */ || c === 0x7D /* } */;
    }

    function fromHexCode(c) {
      var lc;
      if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
        return c - 0x30;
      }

      /*eslint-disable no-bitwise*/
      lc = c | 0x20;
      if (0x61 /* a */ <= lc && lc <= 0x66 /* f */) {
        return lc - 0x61 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 0x78 /* x */) {
        return 2;
      }
      if (c === 0x75 /* u */) {
        return 4;
      }
      if (c === 0x55 /* U */) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
        return c - 0x30;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      /* eslint-disable indent */
      return c === 0x30 /* 0 */ ? '\x00' : c === 0x61 /* a */ ? '\x07' : c === 0x62 /* b */ ? '\x08' : c === 0x74 /* t */ ? '\x09' : c === 0x09 /* Tab */ ? '\x09' : c === 0x6E /* n */ ? '\x0A' : c === 0x76 /* v */ ? '\x0B' : c === 0x66 /* f */ ? '\x0C' : c === 0x72 /* r */ ? '\x0D' : c === 0x65 /* e */ ? '\x1B' : c === 0x20 /* Space */ ? ' ' : c === 0x22 /* " */ ? '\x22' : c === 0x2F /* / */ ? '/' : c === 0x5C /* \ */ ? '\x5C' : c === 0x4E /* N */ ? '\x85' : c === 0x5F /* _ */ ? '\xA0' : c === 0x4C /* L */ ? "\u2028" : c === 0x50 /* P */ ? "\u2029" : '';
    }
    function charFromCodepoint(c) {
      if (c <= 0xFFFF) {
        return String.fromCharCode(c);
      }
      // Encode UTF-16 surrogate pair
      // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
      return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
    }
    var simpleEscapeCheck = new Array(256); // integer, for fast access
    var simpleEscapeMap = new Array(256);
    for (var i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    function State$1(input, options) {
      this.input = input;
      this.filename = options['filename'] || null;
      this.schema = options['schema'] || default_full;
      this.onWarning = options['onWarning'] || null;
      this.legacy = options['legacy'] || false;
      this.json = options['json'] || false;
      this.listener = options['listener'] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.documents = [];

      /*
      this.version;
      this.checkLineBreaks;
      this.tagMap;
      this.anchorMap;
      this.tag;
      this.anchor;
      this.kind;
      this.result;*/
    }

    function generateError(state, message) {
      return new exception(message, new mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, 'duplication of %YAML directive');
        }
        if (args.length !== 1) {
          throwError(state, 'YAML directive accepts exactly one argument');
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, 'ill-formed argument of the YAML directive');
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, 'unacceptable YAML version of the document');
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, 'unsupported YAML version of the document');
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, 'TAG directive accepts exactly two arguments');
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
        }
        if (_hasOwnProperty$1.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
              throwError(state, 'expected valid JSON character');
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, 'the stream contains non-printable characters');
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common.isObject(source)) {
        throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty$1.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
      var index, quantity;

      // The output is a plain object here, so keys can only be strings.
      // We need to convert keyNode to a string, but doing so can hang the process
      // (deeply nested arrays that explode exponentially using aliases).
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, 'nested arrays are not supported inside keys');
          }
          if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
            keyNode[index] = '[object Object]';
          }
        }
      }

      // Avoid code execution in load() via toString property
      // (still use its own toString for arrays, timestamps,
      // and whatever user schema extensions happen to have @@toStringTag)
      if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
        keyNode = '[object Object]';
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === 'tag:yaml.org,2002:merge') {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.position = startPos || state.position;
          throwError(state, 'duplicated mapping key');
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 0x0A /* LF */) {
        state.position++;
      } else if (ch === 0x0D /* CR */) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 0x0A /* LF */) {
          state.position++;
        }
      } else {
        throwError(state, 'a line break is expected');
      }
      state.line += 1;
      state.lineStart = state.position;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0,
        ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 0x23 /* # */) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0x0A /* LF */ && ch !== 0x0D /* CR */ && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 0x20 /* Space */) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, 'deficient indentation');
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position,
        ch;
      ch = state.input.charCodeAt(_position);

      // Condition state.position === state.lineStart is tested
      // in parent on each call, for efficiency. No needs to test here again.
      if ((ch === 0x2D /* - */ || ch === 0x2E /* . */) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += ' ';
      } else if (count > 1) {
        state.result += common.repeat('\n', count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding,
        following,
        captureStart,
        captureEnd,
        hasPendingContent,
        _line,
        _lineStart,
        _lineIndent,
        _kind = state.kind,
        _result = state.result,
        ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */ || ch === 0x26 /* & */ || ch === 0x2A /* * */ || ch === 0x21 /* ! */ || ch === 0x7C /* | */ || ch === 0x3E /* > */ || ch === 0x27 /* ' */ || ch === 0x22 /* " */ || ch === 0x25 /* % */ || ch === 0x40 /* @ */ || ch === 0x60 /* ` */) {
        return false;
      }
      if (ch === 0x3F /* ? */ || ch === 0x2D /* - */) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = 'scalar';
      state.result = '';
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 0x3A /* : */) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 0x23 /* # */) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 0x27 /* ' */) {
        return false;
      }
      state.kind = 'scalar';
      state.result = '';
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 0x27 /* ' */) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 0x27 /* ' */) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, 'unexpected end of the document within a single quoted scalar');
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, 'unexpected end of the stream within a single quoted scalar');
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 0x22 /* " */) {
        return false;
      }
      state.kind = 'scalar';
      state.result = '';
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 0x22 /* " */) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 0x5C /* \ */) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);

            // TODO: rework to inline fn with no type cast?
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, 'expected hexadecimal character');
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, 'unknown escape sequence');
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, 'unexpected end of the document within a double quoted scalar');
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, 'unexpected end of the stream within a double quoted scalar');
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true,
        _line,
        _tag = state.tag,
        _result,
        _anchor = state.anchor,
        following,
        terminator,
        isPair,
        isExplicitPair,
        isMapping,
        overridableKeys = {},
        keyNode,
        keyTag,
        valueNode,
        ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 0x5B /* [ */) {
        terminator = 0x5D; /* ] */
        isMapping = false;
        _result = [];
      } else if (ch === 0x7B /* { */) {
        terminator = 0x7D; /* } */
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? 'mapping' : 'sequence';
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, 'missed comma between flow collection entries');
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 0x3F /* ? */) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 0x2C /* , */) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, 'unexpected end of the stream within a flow collection');
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart,
        folding,
        chomping = CHOMPING_CLIP,
        didReadContent = false,
        detectedIndent = false,
        textIndent = nodeIndent,
        emptyLines = 0,
        atMoreIndented = false,
        tmp,
        ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 0x7C /* | */) {
        folding = false;
      } else if (ch === 0x3E /* > */) {
        folding = true;
      } else {
        return false;
      }
      state.kind = 'scalar';
      state.result = '';
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 0x2B /* + */ || ch === 0x2D /* - */) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 0x2B /* + */ ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, 'repeat of a chomping mode identifier');
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, 'repeat of an indentation width identifier');
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 0x23 /* # */) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }

        // End of the scalar.
        if (state.lineIndent < textIndent) {
          // Perform the chomping.
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              // i.e. only if the scalar is not empty.
              state.result += '\n';
            }
          }

          // Break this `while` cycle and go to the funciton's epilogue.
          break;
        }

        // Folded style: use fancy rules to handle line breaks.
        if (folding) {
          // Lines starting with white space characters (more-indented lines) are not folded.
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            // except for the first content line (cf. Example 8.1)
            state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

            // End of more-indented block.
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat('\n', emptyLines + 1);

            // Just one line break - perceive as the same line.
          } else if (emptyLines === 0) {
            if (didReadContent) {
              // i.e. only if we have already read some scalar content.
              state.result += ' ';
            }

            // Several line breaks - perceive as different lines.
          } else {
            state.result += common.repeat('\n', emptyLines);
          }

          // Literal style: just add exact number of line breaks between content lines.
        } else {
          // Keep all line breaks except the header line break.
          state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line,
        _tag = state.tag,
        _anchor = state.anchor,
        _result = [],
        following,
        detected = false,
        ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (ch !== 0x2D /* - */) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, 'bad indentation of a sequence entry');
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = 'sequence';
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following,
        allowCompact,
        _line,
        _pos,
        _tag = state.tag,
        _anchor = state.anchor,
        _result = {},
        overridableKeys = {},
        keyTag = null,
        keyNode = null,
        valueNode = null,
        atExplicitKey = false,
        detected = false,
        ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line; // Save the current line.
        _pos = state.position;

        //
        // Explicit notation case. There are two separate blocks:
        // first for the key (denoted by "?") and second for the value (denoted by ":")
        //
        if ((ch === 0x3F /* ? */ || ch === 0x3A /* : */) && is_WS_OR_EOL(following)) {
          if (ch === 0x3F /* ? */) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            // i.e. 0x3A/* : */ === character after the explicit key.
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
          }
          state.position += 1;
          ch = following;

          //
          // Implicit notation case. Flow-style node as the key first, then ":", and the value.
          //
        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 0x3A /* : */) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, 'can not read an implicit mapping pair; a colon is missed');
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true; // Keep the result of `composeNode`.
            }
          } else if (detected) {
            throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true; // Keep the result of `composeNode`.
          }
        } else {
          break; // Reading is done. Go to the epilogue.
        }

        //
        // Common reading code for both explicit and implicit notations.
        //
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) {
          throwError(state, 'bad indentation of a mapping entry');
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }

      //
      // Epilogue.
      //

      // Special case: last mapping's node contains only the key in explicit notation.
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
      }

      // Expose the resulting mapping.
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = 'mapping';
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position,
        isVerbatim = false,
        isNamed = false,
        tagHandle,
        tagName,
        ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 0x21 /* ! */) return false;
      if (state.tag !== null) {
        throwError(state, 'duplication of a tag property');
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 0x3C /* < */) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 0x21 /* ! */) {
        isNamed = true;
        tagHandle = '!!';
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = '!';
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 0x3E /* > */);

        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, 'unexpected end of the stream within a verbatim tag');
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 0x21 /* ! */) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, 'named tag handle cannot contain such characters');
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, 'tag suffix cannot contain exclamation marks');
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, 'tag suffix cannot contain flow indicator characters');
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, 'tag name cannot contain such characters: ' + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === '!') {
        state.tag = '!' + tagName;
      } else if (tagHandle === '!!') {
        state.tag = 'tag:yaml.org,2002:' + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 0x26 /* & */) return false;
      if (state.anchor !== null) {
        throwError(state, 'duplication of an anchor property');
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, 'name of an anchor node must contain at least one character');
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 0x2A /* * */) return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, 'name of an alias node must contain at least one character');
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles,
        allowBlockScalars,
        allowBlockCollections,
        indentStatus = 1,
        // 1: this>parent, 0: this=parent, -1: this<parent
        atNewLine = false,
        hasContent = false,
        typeIndex,
        typeQuantity,
        type,
        flowIndent,
        blockIndent;
      if (state.listener !== null) {
        state.listener('open', state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, 'alias node should not have any properties');
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = '?';
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          // Special case: block sequences are allowed to have same indentation level as the parent.
          // http://www.yaml.org/spec/1.2/spec.html#id2799784
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag !== null && state.tag !== '!') {
        if (state.tag === '?') {
          // Implicit resolving is not allowed for non-scalar types, and '?'
          // non-specific tag is only automatically assigned to plain scalars.
          //
          // We only need to check kind conformity in case user explicitly assigns '?'
          // tag, for example like this: "!<?> [0]"
          //
          if (state.result !== null && state.kind !== 'scalar') {
            throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
          }
          for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
            type = state.implicitTypes[typeIndex];
            if (type.resolve(state.result)) {
              // `state.result` updated in resolver if matched
              state.result = type.construct(state.result);
              state.tag = type.tag;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
              break;
            }
          }
        } else if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
          type = state.typeMap[state.kind || 'fallback'][state.tag];
          if (state.result !== null && type.kind !== state.kind) {
            throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
          }
          if (!type.resolve(state.result)) {
            // `state.result` updated in resolver if matched
            throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
          } else {
            state.result = type.construct(state.result);
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else {
          throwError(state, 'unknown tag !<' + state.tag + '>');
        }
      }
      if (state.listener !== null) {
        state.listener('close', state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position,
        _position,
        directiveName,
        directiveArgs,
        hasDirectives = false,
        ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = {};
      state.anchorMap = {};
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 0x25 /* % */) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, 'directive name must not be less than one character in length');
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 0x23 /* # */) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch)) break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0) readLineBreak(state);
        if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */ && state.input.charCodeAt(state.position + 1) === 0x2D /* - */ && state.input.charCodeAt(state.position + 2) === 0x2D /* - */) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, 'directives end mark is expected');
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, 'non-ASCII line breaks are interpreted as content');
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 0x2E /* . */) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, 'end of the stream or a document separator is expected');
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        // Add tailing `\n` if not exists
        if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */ && input.charCodeAt(input.length - 1) !== 0x0D /* CR */) {
          input += '\n';
        }

        // Strip BOM
        if (input.charCodeAt(0) === 0xFEFF) {
          input = input.slice(1);
        }
      }
      var state = new State$1(input, options);
      var nullpos = input.indexOf('\0');
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, 'null byte is not allowed in input');
      }

      // Use 0 as string terminator. That significantly simplifies bounds check.
      state.input += '\0';
      while (state.input.charCodeAt(state.position) === 0x20 /* Space */) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll$1(input, iterator, options) {
      if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
        options = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options);
      if (typeof iterator !== 'function') {
        return documents;
      }
      for (var index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load$1(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        /*eslint-disable no-undefined*/
        return undefined;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new exception('expected a single document in the stream, but found more');
    }
    function safeLoadAll$1(input, iterator, options) {
      if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
        options = iterator;
        iterator = null;
      }
      return loadAll$1(input, iterator, common.extend({
        schema: default_safe
      }, options));
    }
    function safeLoad$1(input, options) {
      return load$1(input, common.extend({
        schema: default_safe
      }, options));
    }
    var loadAll_1 = loadAll$1;
    var load_1 = load$1;
    var safeLoadAll_1 = safeLoadAll$1;
    var safeLoad_1 = safeLoad$1;
    var loader = {
      loadAll: loadAll_1,
      load: load_1,
      safeLoadAll: safeLoadAll_1,
      safeLoad: safeLoad_1
    };

    /*eslint-disable no-use-before-define*/

    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_TAB = 0x09; /* Tab */
    var CHAR_LINE_FEED = 0x0A; /* LF */
    var CHAR_CARRIAGE_RETURN = 0x0D; /* CR */
    var CHAR_SPACE = 0x20; /* Space */
    var CHAR_EXCLAMATION = 0x21; /* ! */
    var CHAR_DOUBLE_QUOTE = 0x22; /* " */
    var CHAR_SHARP = 0x23; /* # */
    var CHAR_PERCENT = 0x25; /* % */
    var CHAR_AMPERSAND = 0x26; /* & */
    var CHAR_SINGLE_QUOTE = 0x27; /* ' */
    var CHAR_ASTERISK = 0x2A; /* * */
    var CHAR_COMMA = 0x2C; /* , */
    var CHAR_MINUS = 0x2D; /* - */
    var CHAR_COLON = 0x3A; /* : */
    var CHAR_EQUALS = 0x3D; /* = */
    var CHAR_GREATER_THAN = 0x3E; /* > */
    var CHAR_QUESTION = 0x3F; /* ? */
    var CHAR_COMMERCIAL_AT = 0x40; /* @ */
    var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */
    var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
    var CHAR_GRAVE_ACCENT = 0x60; /* ` */
    var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */
    var CHAR_VERTICAL_LINE = 0x7C; /* | */
    var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */

    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0x00] = '\\0';
    ESCAPE_SEQUENCES[0x07] = '\\a';
    ESCAPE_SEQUENCES[0x08] = '\\b';
    ESCAPE_SEQUENCES[0x09] = '\\t';
    ESCAPE_SEQUENCES[0x0A] = '\\n';
    ESCAPE_SEQUENCES[0x0B] = '\\v';
    ESCAPE_SEQUENCES[0x0C] = '\\f';
    ESCAPE_SEQUENCES[0x0D] = '\\r';
    ESCAPE_SEQUENCES[0x1B] = '\\e';
    ESCAPE_SEQUENCES[0x22] = '\\"';
    ESCAPE_SEQUENCES[0x5C] = '\\\\';
    ESCAPE_SEQUENCES[0x85] = '\\N';
    ESCAPE_SEQUENCES[0xA0] = '\\_';
    ESCAPE_SEQUENCES[0x2028] = '\\L';
    ESCAPE_SEQUENCES[0x2029] = '\\P';
    var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];
    function compileStyleMap(schema, map) {
      var result, keys, index, length, tag, style, type;
      if (map === null) return {};
      result = {};
      keys = Object.keys(map);
      for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === '!!') {
          tag = 'tag:yaml.org,2002:' + tag.slice(2);
        }
        type = schema.compiledTypeMap['fallback'][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 0xFF) {
        handle = 'x';
        length = 2;
      } else if (character <= 0xFFFF) {
        handle = 'u';
        length = 4;
      } else if (character <= 0xFFFFFFFF) {
        handle = 'U';
        length = 8;
      } else {
        throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
      }
      return '\\' + handle + common.repeat('0', length - string.length) + string;
    }
    function State(options) {
      this.schema = options['schema'] || default_full;
      this.indent = Math.max(1, options['indent'] || 2);
      this.noArrayIndent = options['noArrayIndent'] || false;
      this.skipInvalid = options['skipInvalid'] || false;
      this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
      this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
      this.sortKeys = options['sortKeys'] || false;
      this.lineWidth = options['lineWidth'] || 80;
      this.noRefs = options['noRefs'] || false;
      this.noCompatMode = options['noCompatMode'] || false;
      this.condenseFlow = options['condenseFlow'] || false;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = '';
      this.duplicates = [];
      this.usedDuplicates = null;
    }

    // Indents every line in a string. Empty lines (\n only) are not indented.
    function indentString(string, spaces) {
      var ind = common.repeat(' ', spaces),
        position = 0,
        next = -1,
        result = '',
        line,
        length = string.length;
      while (position < length) {
        next = string.indexOf('\n', position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== '\n') result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return '\n' + common.repeat(' ', state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }

    // [33] s-white ::= s-space | s-tab
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }

    // Returns true if the character can be printed without escaping.
    // From YAML 1.2: "any allowed characters known to be non-printable
    // should also be escaped. [However,] This isnt mandatory"
    // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
    function isPrintable(c) {
      return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF /* BOM */ || 0x10000 <= c && c <= 0x10FFFF;
    }

    // [34] ns-char ::= nb-char - s-white
    // [27] nb-char ::= c-printable - b-char - c-byte-order-mark
    // [26] b-char  ::= b-line-feed | b-carriage-return
    // [24] b-line-feed       ::=     #xA    /* LF */
    // [25] b-carriage-return ::=     #xD    /* CR */
    // [3]  c-byte-order-mark ::=     #xFEFF
    function isNsChar(c) {
      return isPrintable(c) && !isWhitespace(c)
      // byte-order-mark
      && c !== 0xFEFF
      // b-char
      && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }

    // Simplified test for values allowed after the first character in plain style.
    function isPlainSafe(c, prev) {
      // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
      // where nb-char ::= c-printable - b-char - c-byte-order-mark.
      return isPrintable(c) && c !== 0xFEFF
      // - c-flow-indicator
      && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
      // - ":" - "#"
      // /* An ns-char preceding */ "#"
      && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
    }

    // Simplified test for values allowed as the first character in plain style.
    function isPlainSafeFirst(c) {
      // Uses a subset of ns-char - c-indicator
      // where ns-char = nb-char - s-white.
      return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white
      // - (c-indicator ::=
      // - | ? | : | , | [ | ] | { | }
      && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
      // | # | & | * | ! | | | = | > | ' | "
      && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE
      // | % | @ | `)
      && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }

    // Determines whether block indentation indicator is required.
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1,
      STYLE_SINGLE = 2,
      STYLE_LITERAL = 3,
      STYLE_FOLDED = 4,
      STYLE_DOUBLE = 5;

    // Determines which scalar styles are possible and returns the preferred style.
    // lineWidth = -1 => no limit.
    // Pre-conditions: str.length > 0.
    // Post-conditions:
    //    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
    //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
    //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
      var i;
      var char, prev_char;
      var hasLineBreak = false;
      var hasFoldableLine = false; // only checked if shouldTrackWidth
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1; // count the first line correctly
      var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
      if (singleLineOnly) {
        // Case: no block styles.
        // Check for disallowed characters to rule out plain and single.
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
      } else {
        // Case: block styles permitted.
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            // Check if any line can be folded.
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine ||
              // Foldable line = too long, and not more-indented.
              i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
              previousLineBreak = i;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
        // in case the end is missing a \n
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
      }
      // Although every style can represent \n without escaping, prefer block styles
      // for multiline, since they're more readable and they don't add empty lines.
      // Also prefer folding a super-long line.
      if (!hasLineBreak && !hasFoldableLine) {
        // Strings interpretable as another type have to be quoted;
        // e.g. the string 'true' vs. the boolean true.
        return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
      }
      // Edge case: block indentation indicator can only have one digit.
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      // At this point we know block styles are valid.
      // Prefer literal style unless we want to fold.
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }

    // Note: line breaking/folding is implemented for only the folded style.
    // NB. We drop the last trailing newline (if any) of a returned block scalar
    //  since the dumper adds its own newline. This always works:
    //     No ending newline => unaffected; already using strip "-" chomping.
    //     Ending newline    => removed then restored.
    //  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
    function writeScalar(state, string, level, iskey) {
      state.dump = function () {
        if (string.length === 0) {
          return "''";
        }
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
          return "'" + string + "'";
        }
        var indent = state.indent * Math.max(1, level); // no 0-indent scalars
        // As indentation gets deeper, let the width decrease monotonically
        // to the lower bound min(state.lineWidth, 40).
        // Note that this implies
        //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
        //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
        // This behaves better than a constant minimum width which disallows narrower options,
        // or an indent threshold which causes the width to suddenly increase.
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

        // Without knowing if keys are implicit/explicit, assume implicit for safety.
        var singleLineOnly = iskey
        // No block styles in flow mode.
        || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string) {
          return testImplicitResolving(state, string);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string) + '"';
          default:
            throw new exception('impossible error: invalid scalar style');
        }
      }();
    }

    // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

      // note the special case: the string '\n' counts as a "trailing" empty line.
      var clip = string[string.length - 1] === '\n';
      var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
      var chomp = keep ? '+' : clip ? '' : '-';
      return indentIndicator + chomp + '\n';
    }

    // (See the note for writeScalar.)
    function dropEndingNewline(string) {
      return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
    }

    // Note: a long line without a suitable break point will exceed the width limit.
    // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
    function foldString(string, width) {
      // In folded style, $k$ consecutive newlines output as $k+1$ newlines
      // unless they're before or after a more-indented line, or at the very
      // beginning or end, in which case $k$ maps to $k$.
      // Therefore, parse each chunk as newline(s) followed by a content line.
      var lineRe = /(\n+)([^\n]*)/g;

      // first line (possibly an empty line)
      var result = function () {
        var nextLF = string.indexOf('\n');
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      // If we haven't reached the first content line yet, don't add an extra \n.
      var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
      var moreIndented;

      // rest of the lines
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1],
          line = match[2];
        moreIndented = line[0] === ' ';
        result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }

    // Greedy line breaking.
    // Picks the longest line under the limit each time,
    // otherwise settles for the shortest line over the limit.
    // NB. More-indented lines *cannot* be folded, as that would add an extra \n.
    function foldLine(line, width) {
      if (line === '' || line[0] === ' ') return line;

      // Since a more-indented line adds a \n, breaks can't be followed by a space.
      var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
      var match;
      // start is an inclusive index. end, curr, and next are exclusive.
      var start = 0,
        end,
        curr = 0,
        next = 0;
      var result = '';

      // Invariants: 0 <= start <= length-1.
      //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
      // Inside the loop:
      //   A match implies length >= 2, so curr and next are <= length-2.
      while (match = breakRe.exec(line)) {
        next = match.index;
        // maintain invariant: curr - start <= width
        if (next - start > width) {
          end = curr > start ? curr : next; // derive end <= length-2
          result += '\n' + line.slice(start, end);
          // skip the space that was output as \n
          start = end + 1; // derive start <= length-1
        }

        curr = next;
      }

      // By the invariants, start <= length-1, so there is something left over.
      // It is either the whole string or a part starting from non-whitespace.
      result += '\n';
      // Insert a break if the remainder is too long and there is a break available.
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1); // drop extra \n joiner
    }

    // Escapes a double-quoted string.
    function escapeString(string) {
      var result = '';
      var char, nextChar;
      var escapeSeq;
      for (var i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
        if (char >= 0xD800 && char <= 0xDBFF /* high surrogate */) {
          nextChar = string.charCodeAt(i + 1);
          if (nextChar >= 0xDC00 && nextChar <= 0xDFFF /* low surrogate */) {
            // Combine the surrogate pair and store it escaped.
            result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
            // Advance index one extra since we already used that char here.
            i++;
            continue;
          }
        }
        escapeSeq = ESCAPE_SEQUENCES[char];
        result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = '',
        _tag = state.tag,
        index,
        length;
      for (index = 0, length = object.length; index < length; index += 1) {
        // Write only valid elements.
        if (writeNode(state, level, object[index], false, false)) {
          if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = '[' + _result + ']';
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = '',
        _tag = state.tag,
        index,
        length;
      for (index = 0, length = object.length; index < length; index += 1) {
        // Write only valid elements.
        if (writeNode(state, level + 1, object[index], true, true)) {
          if (!compact || index !== 0) {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += '-';
          } else {
            _result += '- ';
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || '[]'; // Empty sequence if no valid values.
    }

    function writeFlowMapping(state, level, object) {
      var _result = '',
        _tag = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = '';
        if (index !== 0) pairBuffer += ', ';
        if (state.condenseFlow) pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level, objectKey, false, false)) {
          continue; // Skip this pair because of invalid key;
        }

        if (state.dump.length > 1024) pairBuffer += '? ';
        pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');
        if (!writeNode(state, level, objectValue, false, false)) {
          continue; // Skip this pair because of invalid value.
        }

        pairBuffer += state.dump;

        // Both key and value are valid.
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = '{' + _result + '}';
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = '',
        _tag = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        explicitPair,
        pairBuffer;

      // Allow sorting keys so that the output file is deterministic
      if (state.sortKeys === true) {
        // Default sorting
        objectKeyList.sort();
      } else if (typeof state.sortKeys === 'function') {
        // Custom sort function
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        // Something is wrong
        throw new exception('sortKeys must be a boolean or a function');
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = '';
        if (!compact || index !== 0) {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue; // Skip this pair because of invalid key.
        }

        explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += '?';
          } else {
            pairBuffer += '? ';
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue; // Skip this pair because of invalid value.
        }

        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ':';
        } else {
          pairBuffer += ': ';
        }
        pairBuffer += state.dump;

        // Both key and value are valid.
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || '{}'; // Empty mapping if no valid pairs.
    }

    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          state.tag = explicit ? type.tag : '?';
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === '[object Function]') {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }

    // Serializes `object` and writes it to global `result`.
    // Returns true on success, or false on invalid object.
    //
    function writeNode(state, level, object, block, compact, iskey) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === '[object Object]' || type === '[object Array]',
        duplicateIndex,
        duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = '*ref_' + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === '[object Object]') {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = '&ref_' + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
            }
          }
        } else if (type === '[object Array]') {
          var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
          if (block && state.dump.length !== 0) {
            writeBlockSequence(state, arrayLevel, state.dump, compact);
            if (duplicate) {
              state.dump = '&ref_' + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, arrayLevel, state.dump);
            if (duplicate) {
              state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
            }
          }
        } else if (type === '[object String]') {
          if (state.tag !== '?') {
            writeScalar(state, state.dump, level, iskey);
          }
        } else {
          if (state.skipInvalid) return false;
          throw new exception('unacceptable kind of an object to dump ' + type);
        }
        if (state.tag !== null && state.tag !== '?') {
          state.dump = '!<' + state.tag + '> ' + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [],
        duplicatesIndexes = [],
        index,
        length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === 'object') {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump$1(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs) getDuplicateReferences(input, state);
      if (writeNode(state, 0, input, true, true)) return state.dump + '\n';
      return '';
    }
    function safeDump$1(input, options) {
      return dump$1(input, common.extend({
        schema: default_safe
      }, options));
    }
    var dump_1 = dump$1;
    var safeDump_1 = safeDump$1;
    var dumper = {
      dump: dump_1,
      safeDump: safeDump_1
    };

    function deprecated(name) {
      return function () {
        throw new Error('Function ' + name + ' is deprecated and cannot be used.');
      };
    }
    var Type = type;
    var Schema = schema;
    var FAILSAFE_SCHEMA = failsafe;
    var JSON_SCHEMA = json;
    var CORE_SCHEMA = core;
    var DEFAULT_SAFE_SCHEMA = default_safe;
    var DEFAULT_FULL_SCHEMA = default_full;
    var load = loader.load;
    var loadAll = loader.loadAll;
    var safeLoad = loader.safeLoad;
    var safeLoadAll = loader.safeLoadAll;
    var dump = dumper.dump;
    var safeDump = dumper.safeDump;
    var YAMLException = exception;

    // Deprecated schema names from JS-YAML 2.0.x
    var MINIMAL_SCHEMA = failsafe;
    var SAFE_SCHEMA = default_safe;
    var DEFAULT_SCHEMA = default_full;

    // Deprecated functions from JS-YAML 1.x.x
    var scan = deprecated('scan');
    var parse = deprecated('parse');
    var compose = deprecated('compose');
    var addConstructor = deprecated('addConstructor');
    var jsYaml$1 = {
      Type: Type,
      Schema: Schema,
      FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
      JSON_SCHEMA: JSON_SCHEMA,
      CORE_SCHEMA: CORE_SCHEMA,
      DEFAULT_SAFE_SCHEMA: DEFAULT_SAFE_SCHEMA,
      DEFAULT_FULL_SCHEMA: DEFAULT_FULL_SCHEMA,
      load: load,
      loadAll: loadAll,
      safeLoad: safeLoad,
      safeLoadAll: safeLoadAll,
      dump: dump,
      safeDump: safeDump,
      YAMLException: YAMLException,
      MINIMAL_SCHEMA: MINIMAL_SCHEMA,
      SAFE_SCHEMA: SAFE_SCHEMA,
      DEFAULT_SCHEMA: DEFAULT_SCHEMA,
      scan: scan,
      parse: parse,
      compose: compose,
      addConstructor: addConstructor
    };

    var jsYaml = jsYaml$1;

    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

    /**
     * Redirect - object used to redirect some requests
     * e.g.
     * {
     *      title: 1x1-transparent.gif
     *      comment: http://probablyprogramming.com/2009/03/15/the-tiniest-gif-ever
     *      contentType: image/gif;base64
     *      content: R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
     * }
     *
     * @typedef {Object} Redirect
     * @property {string} title resource name
     * @property {string} comment resource description
     * @property {string} content encoded resource content
     * @property {string} contentType MIME type
     * @property {boolean} [isBlocking] e.g click2load redirect
     * @property {string} [sha] hash
     */

    class Redirects {
      /**
       * Converts rawYaml into JS object with sources titles used as keys
       *
       * @param {string} rawYaml
       * @returns {Object<Redirect>} - return object with titles in the keys and RedirectSources
       * in the values
       */
      constructor(rawYaml) {
        try {
          const arrOfRedirects = jsYaml.safeLoad(rawYaml);
          this.redirects = arrOfRedirects.reduce(function (acc, redirect) {
            return _objectSpread(_objectSpread({}, acc), {}, {
              [redirect.title]: redirect
            });
          }, {});
        } catch (e) {
          // eslint-disable-next-line no-console
          console.log("Was unable to load YAML into JS due to: ".concat(e.message));
          throw e;
        }
      }

      /**
       * Returns redirect source object
       *
       * @param {string} title
       * @returns {Redirect|undefined} Found redirect source object, or `undefined` if not found.
       */
      getRedirect(title) {
        var _this = this;
        if (Object.prototype.hasOwnProperty.call(this.redirects, title)) {
          return this.redirects[title];
        }

        // look title among aliases
        const values = Object.keys(this.redirects).map(function (key) {
          return _this.redirects[key];
        });
        return values.find(function (redirect) {
          const aliases = redirect.aliases;
          if (!aliases) {
            return false;
          }
          return aliases.indexOf(title) > -1;
        });
      }

      /**
       * Checks if redirect is blocking like click2load.html
       *
       * @param {string} title Title of the redirect.
       * @returns {boolean} True if redirect is blocking otherwise returns `false` even if redirect name is
       * unknown.
       */
      isBlocking(title) {
        const redirect = this.redirects[title];
        if (redirect) {
          return !!redirect.isBlocking;
        }
        return false;
      }
    }

    const redirectsMap = {
      "1x1-transparent.gif": "1x1-transparent.gif",
      "1x1.gif": "1x1-transparent.gif",
      "1x1-transparent-gif": "1x1-transparent.gif",
      "2x2-transparent.png": "2x2-transparent.png",
      "2x2.png": "2x2-transparent.png",
      "2x2-transparent-png": "2x2-transparent.png",
      "3x2-transparent.png": "3x2-transparent.png",
      "3x2.png": "3x2-transparent.png",
      "3x2-transparent-png": "3x2-transparent.png",
      "32x32-transparent.png": "32x32-transparent.png",
      "32x32.png": "32x32-transparent.png",
      "32x32-transparent-png": "32x32-transparent.png",
      noopframe: "noopframe.html",
      "noop.html": "noopframe.html",
      "blank-html": "noopframe.html",
      noopcss: "noopcss.css",
      "noop.css": "noopcss.css",
      "blank-css": "noopcss.css",
      noopjs: "noopjs.js",
      "noop.js": "noopjs.js",
      "blank-js": "noopjs.js",
      noopjson: "noopjson.json",
      nooptext: "nooptext.js",
      "noop.txt": "nooptext.js",
      "blank-text": "nooptext.js",
      empty: "nooptext.js",
      "noopvmap-1.0": "noopvmap01.xml",
      "noop-vmap1.0.xml": "noopvmap01.xml",
      "noopvast-2.0": "noopvast02.xml",
      "noopvast-3.0": "noopvast03.xml",
      "noopvast-4.0": "noopvast04.xml",
      "noopmp3-0.1s": "noopmp3.mp3",
      "blank-mp3": "noopmp3.mp3",
      "noopmp4-1s": "noopmp4.mp4",
      "noop-1s.mp4": "noopmp4.mp4",
      "blank-mp4": "noopmp4.mp4",
      "click2load.html": "click2load.html",
      "ubo-click2load.html": "click2load.html",
      "amazon-apstag": "amazon-apstag.js",
      "ubo-amazon_apstag.js": "amazon-apstag.js",
      "amazon_apstag.js": "amazon-apstag.js",
      "ati-smarttag": "ati-smarttag.js",
      "didomi-loader": "didomi-loader.js",
      fingerprintjs2: "fingerprintjs2.js",
      "ubo-fingerprint2.js": "fingerprintjs2.js",
      "fingerprint2.js": "fingerprintjs2.js",
      fingerprintjs3: "fingerprintjs3.js",
      "ubo-fingerprint3.js": "fingerprintjs3.js",
      "fingerprint3.js": "fingerprintjs3.js",
      gemius: "gemius.js",
      "google-analytics-ga": "google-analytics-ga.js",
      "ubo-google-analytics_ga.js": "google-analytics-ga.js",
      "google-analytics_ga.js": "google-analytics-ga.js",
      "google-analytics": "google-analytics.js",
      "ubo-google-analytics_analytics.js": "google-analytics.js",
      "google-analytics_analytics.js": "google-analytics.js",
      "googletagmanager-gtm": "google-analytics.js",
      "ubo-googletagmanager_gtm.js": "google-analytics.js",
      "googletagmanager_gtm.js": "google-analytics.js",
      "google-ima3": "google-ima3.js",
      "ubo-google-ima.js": "google-ima3.js",
      "google-ima.js": "google-ima3.js",
      "googlesyndication-adsbygoogle": "googlesyndication-adsbygoogle.js",
      "ubo-googlesyndication_adsbygoogle.js": "googlesyndication-adsbygoogle.js",
      "googlesyndication_adsbygoogle.js": "googlesyndication-adsbygoogle.js",
      "googletagservices-gpt": "googletagservices-gpt.js",
      "ubo-googletagservices_gpt.js": "googletagservices-gpt.js",
      "googletagservices_gpt.js": "googletagservices-gpt.js",
      matomo: "matomo.js",
      "metrika-yandex-tag": "metrika-yandex-tag.js",
      "metrika-yandex-watch": "metrika-yandex-watch.js",
      "naver-wcslog": "naver-wcslog.js",
      noeval: "noeval.js",
      "noeval.js": "noeval.js",
      "silent-noeval.js": "noeval.js",
      "ubo-noeval.js": "noeval.js",
      "ubo-silent-noeval.js": "noeval.js",
      "ubo-noeval": "noeval.js",
      "ubo-silent-noeval": "noeval.js",
      "pardot-1.0": "pardot-1.0.js",
      "prebid-ads": "prebid-ads.js",
      "ubo-prebid-ads.js": "prebid-ads.js",
      "prebid-ads.js": "prebid-ads.js",
      prebid: "prebid.js",
      "prevent-bab": "prevent-bab.js",
      "nobab.js": "prevent-bab.js",
      "ubo-nobab.js": "prevent-bab.js",
      "bab-defuser.js": "prevent-bab.js",
      "ubo-bab-defuser.js": "prevent-bab.js",
      "ubo-nobab": "prevent-bab.js",
      "ubo-bab-defuser": "prevent-bab.js",
      "prevent-bab2": "prevent-bab2.js",
      "nobab2.js": "prevent-bab2.js",
      "prevent-fab-3.2.0": "prevent-fab-3.2.0.js",
      "nofab.js": "prevent-fab-3.2.0.js",
      "ubo-nofab.js": "prevent-fab-3.2.0.js",
      "fuckadblock.js-3.2.0": "prevent-fab-3.2.0.js",
      "ubo-fuckadblock.js-3.2.0": "prevent-fab-3.2.0.js",
      "ubo-nofab": "prevent-fab-3.2.0.js",
      "prevent-popads-net": "prevent-popads-net.js",
      "popads.net.js": "prevent-popads-net.js",
      "ubo-popads.net.js": "prevent-popads-net.js",
      "ubo-popads.net": "prevent-popads-net.js",
      "scorecardresearch-beacon": "scorecardresearch-beacon.js",
      "ubo-scorecardresearch_beacon.js": "scorecardresearch-beacon.js",
      "scorecardresearch_beacon.js": "scorecardresearch-beacon.js",
      "set-popads-dummy": "set-popads-dummy.js",
      "popads-dummy.js": "set-popads-dummy.js",
      "ubo-popads-dummy.js": "set-popads-dummy.js",
      "ubo-popads-dummy": "set-popads-dummy.js"
    };

    /**
     * Finds redirect resource by it's name
     *
     * @param {string} name - redirect name
     * @returns {Function}
     */
    const getRedirectByName = function getRedirectByName(name) {
      const redirects = Object.keys(redirectsList).map(function (key) {
        return redirectsList[key];
      });
      return redirects.find(function (r) {
        return r.names && r.names.indexOf(name) > -1;
      });
    };

    /**
     * @typedef {Object} Source - redirect properties
     * @property {string} name redirect name
     * @property {Array<string>} args Arguments for redirect function
     * @property {'extension'|'test'} [engine] -
     * Defines the final form of redirect string presentation
     * @property {boolean} [verbose] flag to enable printing to console debug information
     */

    /**
     * Returns redirect code by param
     *
     * @param {Source} source
     * @returns {string} redirect code
     */
    const getRedirectCode = function getRedirectCode(source) {
      const redirect = getRedirectByName(source.name);
      let result = attachDependencies(redirect);
      result = addCall(redirect, result);

      // redirect code for different sources is checked in tests
      // so it should be just a code without any source and props passed
      result = source.engine === 'test' ? wrapInNonameFunc(result) : passSourceAndProps(source, result, true);
      return result;
    };
    const getRedirectFilename = function getRedirectFilename(name) {
      return redirectsMap[name];
    };
    const redirects = {
      Redirects,
      getRedirectFilename,
      getCode: getRedirectCode,
      isAdgRedirectRule: validator.isAdgRedirectRule,
      isValidAdgRedirectRule: validator.isValidAdgRedirectRule,
      isAdgRedirectCompatibleWithUbo: validator.isAdgRedirectCompatibleWithUbo,
      isUboRedirectCompatibleWithAdg: validator.isUboRedirectCompatibleWithAdg,
      isAbpRedirectCompatibleWithAdg: validator.isAbpRedirectCompatibleWithAdg,
      convertUboRedirectToAdg,
      convertAbpRedirectToAdg,
      convertRedirectToAdg,
      convertAdgRedirectToUbo
    };

    function abortCurrentInlineScript(source, args) {
      function abortCurrentInlineScript(source, property, search) {
        const searchRegexp = toRegExp(search);
        const rid = randomId();
        const SRC_DATA_MARKER = "data:text/javascript;base64,";
        const getCurrentScript = function getCurrentScript() {
          if ("currentScript" in document) {
            return document.currentScript;
          }
          const scripts = document.getElementsByTagName("script");
          return scripts[scripts.length - 1];
        };
        const ourScript = getCurrentScript();
        const abort = function abort() {
          const scriptEl = getCurrentScript();
          if (!scriptEl) {
            return;
          }
          let content = scriptEl.textContent;
          try {
            const textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, "textContent").get;
            content = textContentGetter.call(scriptEl);
          } catch (e) {}
          if (content.length === 0 && typeof scriptEl.src !== "undefined" && startsWith(scriptEl.src, SRC_DATA_MARKER)) {
            const encodedContent = scriptEl.src.slice(SRC_DATA_MARKER.length);
            content = window.atob(encodedContent);
          }
          if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
            hit(source);
            throw new ReferenceError(rid);
          }
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (base instanceof Object === false && base === null) {
            const props = property.split(".");
            const propIndex = props.indexOf(prop);
            const baseName = props[propIndex - 1];
            const message = "The scriptlet had been executed before the ".concat(baseName, " was loaded.");
            logMessage(source, message);
            return;
          }
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          let currentValue = base[prop];
          let origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
          if (origDescriptor instanceof Object === false || origDescriptor.get instanceof Function === false) {
            currentValue = base[prop];
            origDescriptor = undefined;
          }
          const descriptorWrapper = Object.assign(getDescriptorAddon(), {
            currentValue: currentValue,
            get() {
              if (!this.isAbortingSuspended) {
                this.isolateCallback(abort);
              }
              if (origDescriptor instanceof Object) {
                return origDescriptor.get.call(base);
              }
              return this.currentValue;
            },
            set(newValue) {
              if (!this.isAbortingSuspended) {
                this.isolateCallback(abort);
              }
              if (origDescriptor instanceof Object) {
                origDescriptor.set.call(base, newValue);
              } else {
                this.currentValue = newValue;
              }
            }
          });
          setPropertyAccess(base, prop, {
            get() {
              return descriptorWrapper.get.call(descriptorWrapper);
            },
            set(newValue) {
              descriptorWrapper.set.call(descriptorWrapper, newValue);
            }
          });
        };
        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function startsWith(str, prefix) {
        return !!str && str.indexOf(prefix) === 0;
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getDescriptorAddon() {
        return {
          isAbortingSuspended: false,
          isolateCallback(cb) {
            this.isAbortingSuspended = true;
            try {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              const result = cb(...args);
              this.isAbortingSuspended = false;
              return result;
            } catch (_unused) {
              const rid = randomId();
              this.isAbortingSuspended = false;
              throw new ReferenceError(rid);
            }
          }
        };
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        abortCurrentInlineScript.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function abortOnPropertyRead(source, args) {
      function abortOnPropertyRead(source, property) {
        if (!property) {
          return;
        }
        const rid = randomId();
        const abort = function abort() {
          hit(source);
          throw new ReferenceError(rid);
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          setPropertyAccess(base, prop, {
            get: abort,
            set: function set() {}
          });
        };
        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        abortOnPropertyRead.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function abortOnPropertyWrite(source, args) {
      function abortOnPropertyWrite(source, property) {
        if (!property) {
          return;
        }
        const rid = randomId();
        const abort = function abort() {
          hit(source);
          throw new ReferenceError(rid);
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          setPropertyAccess(base, prop, {
            set: abort
          });
        };
        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        abortOnPropertyWrite.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function abortOnStackTrace(source, args) {
      function abortOnStackTrace(source, property, stack) {
        if (!property || !stack) {
          return;
        }
        const rid = randomId();
        const abort = function abort() {
          hit(source);
          throw new ReferenceError(rid);
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          if (!stack.match(/^(inlineScript|injectedScript)$/) && !isValidStrPattern(stack)) {
            logMessage(source, "Invalid parameter: ".concat(stack));
            return;
          }
          const descriptorWrapper = Object.assign(getDescriptorAddon(), {
            value: base[prop],
            get() {
              if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
                abort();
              }
              return this.value;
            },
            set(newValue) {
              if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
                abort();
              }
              this.value = newValue;
            }
          });
          setPropertyAccess(base, prop, {
            get() {
              return descriptorWrapper.get.call(descriptorWrapper);
            },
            set(newValue) {
              descriptorWrapper.set.call(descriptorWrapper, newValue);
            }
          });
        };
        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
          return true;
        }
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
          return true;
        }
        const stackRegexp = toRegExp(stackMatch);
        const refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        }).join("\n");
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
      }
      function getDescriptorAddon() {
        return {
          isAbortingSuspended: false,
          isolateCallback(cb) {
            this.isAbortingSuspended = true;
            try {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              const result = cb(...args);
              this.isAbortingSuspended = false;
              return result;
            } catch (_unused) {
              const rid = randomId();
              this.isAbortingSuspended = false;
              throw new ReferenceError(rid);
            }
          }
        };
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getNativeRegexpTest() {
        return Object.getOwnPropertyDescriptor(RegExp.prototype, "test").value;
      }
      function startsWith(str, prefix) {
        return !!str && str.indexOf(prefix) === 0;
      }
      function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        const INLINE_SCRIPT_STRING = "inlineScript";
        const INJECTED_SCRIPT_STRING = "injectedScript";
        const INJECTED_SCRIPT_MARKER = "<anonymous>";
        const isInlineScript = function isInlineScript(stackMatch) {
          return stackMatch.indexOf(INLINE_SCRIPT_STRING) > -1;
        };
        const isInjectedScript = function isInjectedScript(stackMatch) {
          return stackMatch.indexOf(INJECTED_SCRIPT_STRING) > -1;
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
          return false;
        }
        let documentURL = window.location.href;
        const pos = documentURL.indexOf("#");
        if (pos !== -1) {
          documentURL = documentURL.slice(0, pos);
        }
        const stackSteps = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        });
        const stackLines = stackSteps.map(function (line) {
          let stack;
          const getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
          if (getStackTraceURL) {
            let stackURL = getStackTraceURL[2];
            if (startsWith(stackURL, "(")) {
              stackURL = stackURL.slice(1);
            }
            if (startsWith(stackURL, INJECTED_SCRIPT_MARKER)) {
              stackURL = INJECTED_SCRIPT_STRING;
              let stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
              if (startsWith(stackFunction, "at")) {
                stackFunction = stackFunction.slice(2).trim();
              }
              stack = "".concat(stackFunction, " ").concat(stackURL).trim();
            } else {
              stack = stackURL;
            }
          } else {
            stack = line;
          }
          return stack;
        });
        if (stackLines) {
          for (let index = 0; index < stackLines.length; index += 1) {
            if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
              return true;
            }
            if (isInjectedScript(stackMatch) && startsWith(stackLines[index], INJECTED_SCRIPT_STRING)) {
              return true;
            }
          }
        }
        return false;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        abortOnStackTrace.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function adjustSetInterval(source, args) {
      function adjustSetInterval(source, matchCallback, matchDelay, boost) {
        const nativeSetInterval = window.setInterval;
        const matchRegexp = toRegExp(matchCallback);
        const intervalWrapper = function intervalWrapper(callback, delay) {
          if (!isValidCallback(callback)) {
            const message = "Scriptlet can't be applied because of invalid callback: '".concat(String(callback), "'");
            logMessage(source, message);
          } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
            delay *= getBoostMultiplier(boost);
            hit(source);
          }
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }
          return nativeSetInterval.apply(window, [callback, delay, ...args]);
        };
        window.setInterval = intervalWrapper;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function isValidCallback(callback) {
        return callback instanceof Function || typeof callback === "string";
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function getBoostMultiplier(boost) {
        const DEFAULT_MULTIPLIER = .05;
        const MIN_MULTIPLIER = .001;
        const MAX_MULTIPLIER = 50;
        const parsedBoost = parseFloat(boost);
        let boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER : parsedBoost;
        if (boostMultiplier < MIN_MULTIPLIER) {
          boostMultiplier = MIN_MULTIPLIER;
        }
        if (boostMultiplier > MAX_MULTIPLIER) {
          boostMultiplier = MAX_MULTIPLIER;
        }
        return boostMultiplier;
      }
      function isDelayMatched(inputDelay, realDelay) {
        return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function nativeIsFinite(num) {
        const native = Number.isFinite || window.isFinite;
        return native(num);
      }
      function getMatchDelay(delay) {
        const DEFAULT_DELAY = 1e3;
        const parsedDelay = parseInt(delay, 10);
        const delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY : parsedDelay;
        return delayMatch;
      }
      function shouldMatchAnyDelay(delay) {
        return delay === "*";
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        adjustSetInterval.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function adjustSetTimeout(source, args) {
      function adjustSetTimeout(source, matchCallback, matchDelay, boost) {
        const nativeSetTimeout = window.setTimeout;
        const matchRegexp = toRegExp(matchCallback);
        const timeoutWrapper = function timeoutWrapper(callback, delay) {
          if (!isValidCallback(callback)) {
            const message = "Scriptlet can't be applied because of invalid callback: '".concat(String(callback), "'");
            logMessage(source, message);
          } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
            delay *= getBoostMultiplier(boost);
            hit(source);
          }
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }
          return nativeSetTimeout.apply(window, [callback, delay, ...args]);
        };
        window.setTimeout = timeoutWrapper;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function isValidCallback(callback) {
        return callback instanceof Function || typeof callback === "string";
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function getBoostMultiplier(boost) {
        const DEFAULT_MULTIPLIER = .05;
        const MIN_MULTIPLIER = .001;
        const MAX_MULTIPLIER = 50;
        const parsedBoost = parseFloat(boost);
        let boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER : parsedBoost;
        if (boostMultiplier < MIN_MULTIPLIER) {
          boostMultiplier = MIN_MULTIPLIER;
        }
        if (boostMultiplier > MAX_MULTIPLIER) {
          boostMultiplier = MAX_MULTIPLIER;
        }
        return boostMultiplier;
      }
      function isDelayMatched(inputDelay, realDelay) {
        return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function nativeIsFinite(num) {
        const native = Number.isFinite || window.isFinite;
        return native(num);
      }
      function getMatchDelay(delay) {
        const DEFAULT_DELAY = 1e3;
        const parsedDelay = parseInt(delay, 10);
        const delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY : parsedDelay;
        return delayMatch;
      }
      function shouldMatchAnyDelay(delay) {
        return delay === "*";
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        adjustSetTimeout.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function debugCurrentInlineScript(source, args) {
      function debugCurrentInlineScript(source, property, search) {
        const searchRegexp = toRegExp(search);
        const rid = randomId();
        const getCurrentScript = function getCurrentScript() {
          if ("currentScript" in document) {
            return document.currentScript;
          }
          const scripts = document.getElementsByTagName("script");
          return scripts[scripts.length - 1];
        };
        const ourScript = getCurrentScript();
        const abort = function abort() {
          const scriptEl = getCurrentScript();
          if (!scriptEl) {
            return;
          }
          let content = scriptEl.textContent;
          try {
            const textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, "textContent").get;
            content = textContentGetter.call(scriptEl);
          } catch (e) {}
          if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
            hit(source);
            debugger;
          }
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (base instanceof Object === false && base === null) {
            const props = property.split(".");
            const propIndex = props.indexOf(prop);
            const baseName = props[propIndex - 1];
            const message = "The scriptlet had been executed before the ".concat(baseName, " was loaded.");
            logMessage(message, source.verbose);
            return;
          }
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          let currentValue = base[prop];
          setPropertyAccess(base, prop, {
            set: function set(value) {
              abort();
              currentValue = value;
            },
            get: function get() {
              abort();
              return currentValue;
            }
          });
        };
        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        debugCurrentInlineScript.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function debugOnPropertyRead(source, args) {
      function debugOnPropertyRead(source, property) {
        if (!property) {
          return;
        }
        const rid = randomId();
        const abort = function abort() {
          hit(source);
          debugger;
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          setPropertyAccess(base, prop, {
            get: abort,
            set: noopFunc
          });
        };
        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function noopFunc() {}
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        debugOnPropertyRead.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function debugOnPropertyWrite(source, args) {
      function debugOnPropertyWrite(source, property) {
        if (!property) {
          return;
        }
        const rid = randomId();
        const abort = function abort() {
          hit(source);
          debugger;
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          setPropertyAccess(base, prop, {
            set: abort
          });
        };
        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        debugOnPropertyWrite.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function dirString(source, args) {
      function dirString(source, times) {
        const _console = console,
          dir = _console.dir;
        function dirWrapper(object) {
          if (typeof dir === "function") {
            dir.call(this, object);
          }
          hit(source);
        }
        console.dir = dirWrapper;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        dirString.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function disableNewtabLinks(source, args) {
      function disableNewtabLinks(source) {
        document.addEventListener("click", function (ev) {
          let target = ev.target;
          while (target !== null) {
            if (target.localName === "a" && target.hasAttribute("target")) {
              ev.stopPropagation();
              ev.preventDefault();
              hit(source);
              break;
            }
            target = target.parentNode;
          }
        });
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        disableNewtabLinks.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function forceWindowClose(source, args) {
      function forceWindowClose(source) {
        let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        if (typeof window.close !== "function") {
          const message = "window.close() is not a function so 'close-window' scriptlet is unavailable";
          logMessage(source, message);
          return;
        }
        const closeImmediately = function closeImmediately() {
          try {
            hit(source);
            window.close();
          } catch (e) {
            logMessage(source, e);
          }
        };
        const closeByExtension = function closeByExtension() {
          const extCall = function extCall() {
            dispatchEvent(new Event("adguard:scriptlet-close-window"));
          };
          window.addEventListener("adguard:subscribed-to-close-window", extCall, {
            once: true
          });
          setTimeout(function () {
            window.removeEventListener("adguard:subscribed-to-close-window", extCall, {
              once: true
            });
          }, 5e3);
        };
        const shouldClose = function shouldClose() {
          if (path === "") {
            return true;
          }
          const pathRegexp = toRegExp(path);
          const currentPath = "".concat(window.location.pathname).concat(window.location.search);
          return pathRegexp.test(currentPath);
        };
        if (shouldClose()) {
          closeImmediately();
          if (navigator.userAgent.indexOf("Chrome") > -1) {
            closeByExtension();
          }
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        forceWindowClose.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function hideInShadowDom(source, args) {
      function hideInShadowDom(source, selector, baseSelector) {
        if (!Element.prototype.attachShadow) {
          return;
        }
        const hideElement = function hideElement(targetElement) {
          const DISPLAY_NONE_CSS = "display:none!important;";
          targetElement.style.cssText = DISPLAY_NONE_CSS;
        };
        const hideHandler = function hideHandler() {
          let hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
          while (hostElements.length !== 0) {
            let isHidden = false;
            const _pierceShadowDom = pierceShadowDom(selector, hostElements),
              targets = _pierceShadowDom.targets,
              innerHosts = _pierceShadowDom.innerHosts;
            targets.forEach(function (targetEl) {
              hideElement(targetEl);
              isHidden = true;
            });
            if (isHidden) {
              hit(source);
            }
            hostElements = innerHosts;
          }
        };
        hideHandler();
        observeDOMChanges(hideHandler, true);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function observeDOMChanges(callback) {
        let observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        const THROTTLE_DELAY_MS = 20;
        const observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        const connect = function connect() {
          if (attrsToObserve.length > 0) {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs,
              attributeFilter: attrsToObserve
            });
          } else {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs
            });
          }
        };
        const disconnect = function disconnect() {
          observer.disconnect();
        };
        function callbackWrapper() {
          disconnect();
          callback();
          connect();
        }
        connect();
      }
      function findHostElements(rootElement) {
        const hosts = [];
        const domElems = rootElement.querySelectorAll("*");
        domElems.forEach(function (el) {
          if (el.shadowRoot) {
            hosts.push(el);
          }
        });
        return hosts;
      }
      function pierceShadowDom(selector, hostElements) {
        let targets = [];
        const innerHostsAcc = [];
        hostElements.forEach(function (host) {
          const simpleElems = host.querySelectorAll(selector);
          targets = targets.concat([].slice.call(simpleElems));
          const shadowRootElem = host.shadowRoot;
          const shadowChildren = shadowRootElem.querySelectorAll(selector);
          targets = targets.concat([].slice.call(shadowChildren));
          innerHostsAcc.push(findHostElements(shadowRootElem));
        });
        const innerHosts = flatten(innerHostsAcc);
        return {
          targets: targets,
          innerHosts: innerHosts
        };
      }
      function flatten(input) {
        const stack = [];
        input.forEach(function (el) {
          return stack.push(el);
        });
        const res = [];
        while (stack.length) {
          const next = stack.pop();
          if (Array.isArray(next)) {
            next.forEach(function (el) {
              return stack.push(el);
            });
          } else {
            res.push(next);
          }
        }
        return res.reverse();
      }
      function throttle(cb, delay) {
        let wait = false;
        let savedArgs;
        const wrapper = function wrapper() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (wait) {
            savedArgs = args;
            return;
          }
          cb(...args);
          wait = true;
          setTimeout(function () {
            wait = false;
            if (savedArgs) {
              wrapper(...savedArgs);
              savedArgs = null;
            }
          }, delay);
        };
        return wrapper;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        hideInShadowDom.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function injectCssInShadowDom(source, args) {
      function injectCssInShadowDom(source, cssRule) {
        let hostSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        if (!Element.prototype.attachShadow || typeof Proxy === "undefined" || typeof Reflect === "undefined") {
          return;
        }
        if (cssRule.match(/(url|image-set)\(.*\)/i)) {
          logMessage(source, '"url()" function is not allowed for css rules');
          return;
        }
        const callback = function callback(shadowRoot) {
          try {
            const stylesheet = new CSSStyleSheet();
            try {
              stylesheet.insertRule(cssRule);
            } catch (e) {
              logMessage(source, "Unable to apply the rule '".concat(cssRule, "' due to: \n'").concat(e.message, "'"));
              return;
            }
            shadowRoot.adoptedStyleSheets = [...shadowRoot.adoptedStyleSheets, stylesheet];
          } catch (_unused) {
            const styleTag = document.createElement("style");
            styleTag.innerText = cssRule;
            shadowRoot.appendChild(styleTag);
          }
          hit(source);
        };
        hijackAttachShadow(window, hostSelector, callback);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function hijackAttachShadow(context, hostSelector, callback) {
        const handlerWrapper = function handlerWrapper(target, thisArg, args) {
          const shadowRoot = Reflect.apply(target, thisArg, args);
          if (thisArg && thisArg.matches(hostSelector || "*")) {
            callback(shadowRoot);
          }
          return shadowRoot;
        };
        const attachShadowHandler = {
          apply: handlerWrapper
        };
        context.Element.prototype.attachShadow = new Proxy(context.Element.prototype.attachShadow, attachShadowHandler);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        injectCssInShadowDom.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function jsonPrune(source, args) {
      function jsonPrune(source, propsToRemove, requiredInitialProps, stack) {
        if (!!stack && !matchStackTrace(stack, new Error().stack)) {
          return;
        }
        const prunePaths = propsToRemove !== undefined && propsToRemove !== "" ? propsToRemove.split(/ +/) : [];
        const requiredPaths = requiredInitialProps !== undefined && requiredInitialProps !== "" ? requiredInitialProps.split(/ +/) : [];
        function isPruningNeeded(root) {
          if (!root) {
            return false;
          }
          let shouldProcess;
          if (prunePaths.length === 0 && requiredPaths.length > 0) {
            const rootString = JSON.stringify(root);
            const matchRegex = toRegExp(requiredPaths.join(""));
            const shouldLog = matchRegex.test(rootString);
            if (shouldLog) {
              logMessage(source, "".concat(window.location.hostname, "\n").concat(JSON.stringify(root, null, 2)), true);
              if (root && typeof root === "object") {
                logMessage(source, root, true, false);
              }
              shouldProcess = false;
              return shouldProcess;
            }
          }
          for (let i = 0; i < requiredPaths.length; i += 1) {
            const requiredPath = requiredPaths[i];
            const lastNestedPropName = requiredPath.split(".").pop();
            const hasWildcard = requiredPath.indexOf(".*.") > -1 || requiredPath.indexOf("*.") > -1 || requiredPath.indexOf(".*") > -1 || requiredPath.indexOf(".[].") > -1 || requiredPath.indexOf("[].") > -1 || requiredPath.indexOf(".[]") > -1;
            const details = getWildcardPropertyInChain(root, requiredPath, hasWildcard);
            shouldProcess = !hasWildcard;
            for (let i = 0; i < details.length; i += 1) {
              if (hasWildcard) {
                shouldProcess = !(details[i].base[lastNestedPropName] === undefined) || shouldProcess;
              } else {
                shouldProcess = !(details[i].base[lastNestedPropName] === undefined) && shouldProcess;
              }
            }
          }
          return shouldProcess;
        }
        const jsonPruner = function jsonPruner(root) {
          if (prunePaths.length === 0 && requiredPaths.length === 0) {
            logMessage(source, "".concat(window.location.hostname, "\n").concat(JSON.stringify(root, null, 2)), true);
            if (root && typeof root === "object") {
              logMessage(source, root, true, false);
            }
            return root;
          }
          try {
            if (isPruningNeeded(root) === false) {
              return root;
            }
            prunePaths.forEach(function (path) {
              const ownerObjArr = getWildcardPropertyInChain(root, path, true);
              ownerObjArr.forEach(function (ownerObj) {
                if (ownerObj !== undefined && ownerObj.base) {
                  delete ownerObj.base[ownerObj.prop];
                  hit(source);
                }
              });
            });
          } catch (e) {
            logMessage(source, e);
          }
          return root;
        };
        const nativeJSONParse = JSON.parse;
        const jsonParseWrapper = function jsonParseWrapper() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          const root = nativeJSONParse.apply(JSON, args);
          return jsonPruner(root);
        };
        jsonParseWrapper.toString = nativeJSONParse.toString.bind(nativeJSONParse);
        JSON.parse = jsonParseWrapper;
        const nativeResponseJson = Response.prototype.json;
        const responseJsonWrapper = function responseJsonWrapper() {
          const promise = nativeResponseJson.apply(this);
          return promise.then(function (obj) {
            return jsonPruner(obj);
          });
        };
        if (typeof Response === "undefined") {
          return;
        }
        Response.prototype.json = responseJsonWrapper;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
          return true;
        }
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
          return true;
        }
        const stackRegexp = toRegExp(stackMatch);
        const refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        }).join("\n");
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
      }
      function getWildcardPropertyInChain(base, chain) {
        let lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
        const pos = chain.indexOf(".");
        if (pos === -1) {
          if (chain === "*" || chain === "[]") {
            for (const key in base) {
              if (Object.prototype.hasOwnProperty.call(base, key)) {
                output.push({
                  base: base,
                  prop: key
                });
              }
            }
          } else {
            output.push({
              base: base,
              prop: chain
            });
          }
          return output;
        }
        const prop = chain.slice(0, pos);
        const shouldLookThrough = prop === "[]" && Array.isArray(base) || prop === "*" && base instanceof Object;
        if (shouldLookThrough) {
          const nextProp = chain.slice(pos + 1);
          const baseKeys = Object.keys(base);
          baseKeys.forEach(function (key) {
            const item = base[key];
            getWildcardPropertyInChain(item, nextProp, lookThrough, output);
          });
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if (nextBase !== undefined) {
          getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
        }
        return output;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function getNativeRegexpTest() {
        return Object.getOwnPropertyDescriptor(RegExp.prototype, "test").value;
      }
      function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        const INLINE_SCRIPT_STRING = "inlineScript";
        const INJECTED_SCRIPT_STRING = "injectedScript";
        const INJECTED_SCRIPT_MARKER = "<anonymous>";
        const isInlineScript = function isInlineScript(stackMatch) {
          return stackMatch.indexOf(INLINE_SCRIPT_STRING) > -1;
        };
        const isInjectedScript = function isInjectedScript(stackMatch) {
          return stackMatch.indexOf(INJECTED_SCRIPT_STRING) > -1;
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
          return false;
        }
        let documentURL = window.location.href;
        const pos = documentURL.indexOf("#");
        if (pos !== -1) {
          documentURL = documentURL.slice(0, pos);
        }
        const stackSteps = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        });
        const stackLines = stackSteps.map(function (line) {
          let stack;
          const getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
          if (getStackTraceURL) {
            let stackURL = getStackTraceURL[2];
            if (startsWith(stackURL, "(")) {
              stackURL = stackURL.slice(1);
            }
            if (startsWith(stackURL, INJECTED_SCRIPT_MARKER)) {
              stackURL = INJECTED_SCRIPT_STRING;
              let stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
              if (startsWith(stackFunction, "at")) {
                stackFunction = stackFunction.slice(2).trim();
              }
              stack = "".concat(stackFunction, " ").concat(stackURL).trim();
            } else {
              stack = stackURL;
            }
          } else {
            stack = line;
          }
          return stack;
        });
        if (stackLines) {
          for (let index = 0; index < stackLines.length; index += 1) {
            if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
              return true;
            }
            if (isInjectedScript(stackMatch) && startsWith(stackLines[index], INJECTED_SCRIPT_STRING)) {
              return true;
            }
          }
        }
        return false;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        jsonPrune.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function log(source, args) {
      function log() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        console.log(args);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        log.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function logAddEventListener(source, args) {
      function logAddEventListener(source) {
        const nativeAddEventListener = window.EventTarget.prototype.addEventListener;
        function addEventListenerWrapper(type, listener) {
          var _this$constructor;
          if (validateType(type) && validateListener(listener)) {
            const message = 'addEventListener("'.concat(type, '", ').concat(listenerToString(listener), ")");
            logMessage(source, message, true);
            hit(source);
          }
          const message = "Invalid event type or listener passed to addEventListener:\ntype: ".concat(convertTypeToString(type), "\nlistener: ").concat(convertTypeToString(listener));
          logMessage(source, message, true);
          let context = this;
          if (this && ((_this$constructor = this.constructor) === null || _this$constructor === void 0 ? void 0 : _this$constructor.name) === "Window" && this !== window) {
            context = window;
          }
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }
          return nativeAddEventListener.apply(context, [type, listener, ...args]);
        }
        const descriptor = {
          configurable: true,
          set: function set() {},
          get: function get() {
            return addEventListenerWrapper;
          }
        };
        Object.defineProperty(window.EventTarget.prototype, "addEventListener", descriptor);
        Object.defineProperty(window, "addEventListener", descriptor);
        Object.defineProperty(document, "addEventListener", descriptor);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function validateType(type) {
        return typeof type !== "undefined";
      }
      function validateListener(listener) {
        return typeof listener !== "undefined" && (typeof listener === "function" || typeof listener === "object" && listener !== null && typeof listener.handleEvent === "function");
      }
      function listenerToString(listener) {
        return typeof listener === "function" ? listener.toString() : listener.handleEvent.toString();
      }
      function convertTypeToString(value) {
        let output;
        if (typeof value === "undefined") {
          output = "undefined";
        } else if (typeof value === "object") {
          if (value === null) {
            output = "null";
          } else {
            output = objectToString(value);
          }
        } else {
          output = value.toString();
        }
        return output;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
          return String(obj);
        }
        return isEmptyObject(obj) ? "{}" : getObjectEntries(obj).map(function (pair) {
          const key = pair[0];
          const value = pair[1];
          let recordValueStr = value;
          if (value instanceof Object) {
            recordValueStr = "{ ".concat(objectToString(value), " }");
          }
          return "".concat(key, ':"').concat(recordValueStr, '"');
        }).join(" ");
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getObjectEntries(object) {
        const keys = Object.keys(object);
        const entries = [];
        keys.forEach(function (key) {
          return entries.push([key, object[key]]);
        });
        return entries;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        logAddEventListener.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function logEval(source, args) {
      function logEval(source) {
        const nativeEval = window.eval;
        function evalWrapper(str) {
          hit(source);
          logMessage(source, 'eval("'.concat(str, '")'), true);
          return nativeEval(str);
        }
        window.eval = evalWrapper;
        const nativeFunction = window.Function;
        function FunctionWrapper() {
          hit(source);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          logMessage(source, "new Function(".concat(args.join(", "), ")"), true);
          return nativeFunction.apply(this, [...args]);
        }
        FunctionWrapper.prototype = Object.create(nativeFunction.prototype);
        FunctionWrapper.prototype.constructor = FunctionWrapper;
        window.Function = FunctionWrapper;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        logEval.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function logOnStacktrace(source, args) {
      function logOnStacktrace(source, property) {
        if (!property) {
          return;
        }
        const refineStackTrace = function refineStackTrace(stackString) {
          const stackSteps = stackString.split("\n").slice(2).map(function (line) {
            return line.replace(/ {4}at /, "");
          });
          const logInfoArray = stackSteps.map(function (line) {
            let funcName;
            let funcFullPath;
            const reg = /\(([^\)]+)\)/;
            const regFirefox = /(.*?@)(\S+)(:\d+):\d+\)?$/;
            if (line.match(reg)) {
              funcName = line.split(" ").slice(0, -1).join(" ");
              funcFullPath = line.match(reg)[1];
            } else if (line.match(regFirefox)) {
              funcName = line.split("@").slice(0, -1).join(" ");
              funcFullPath = line.match(regFirefox)[2];
            } else {
              funcName = "function name is not available";
              funcFullPath = line;
            }
            return [funcName, funcFullPath];
          });
          const logInfoObject = {};
          logInfoArray.forEach(function (pair) {
            logInfoObject[pair[0]] = pair[1];
          });
          return logInfoObject;
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          let value = base[prop];
          setPropertyAccess(base, prop, {
            get() {
              hit(source);
              logMessage(source, "Get ".concat(prop), true);
              console.table(refineStackTrace(new Error().stack));
              return value;
            },
            set(newValue) {
              hit(source);
              logMessage(source, "Set ".concat(prop), true);
              console.table(refineStackTrace(new Error().stack));
              value = newValue;
            }
          });
        };
        setChainPropAccess(window, property);
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        logOnStacktrace.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function m3uPrune(source, args) {
      function m3uPrune(source, propsToRemove, urlToMatch) {
        if (typeof Reflect === "undefined" || typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
          return;
        }
        let shouldPruneResponse = false;
        const urlMatchRegexp = toRegExp(urlToMatch);
        const SEGMENT_MARKER = "#";
        const AD_MARKER = {
          ASSET: "#EXT-X-ASSET:",
          CUE: "#EXT-X-CUE:",
          CUE_IN: "#EXT-X-CUE-IN",
          DISCONTINUITY: "#EXT-X-DISCONTINUITY",
          EXTINF: "#EXTINF",
          EXTM3U: "#EXTM3U",
          SCTE35: "#EXT-X-SCTE35:"
        };
        const COMCAST_AD_MARKER = {
          AD: "-AD-",
          VAST: "-VAST-",
          VMAP_AD: "-VMAP-AD-",
          VMAP_AD_BREAK: "#EXT-X-VMAP-AD-BREAK:"
        };
        const TAGS_ALLOWLIST = ["#EXT-X-TARGETDURATION", "#EXT-X-MEDIA-SEQUENCE", "#EXT-X-DISCONTINUITY-SEQUENCE", "#EXT-X-ENDLIST", "#EXT-X-PLAYLIST-TYPE", "#EXT-X-I-FRAMES-ONLY", "#EXT-X-MEDIA", "#EXT-X-STREAM-INF", "#EXT-X-I-FRAME-STREAM-INF", "#EXT-X-SESSION-DATA", "#EXT-X-SESSION-KEY", "#EXT-X-INDEPENDENT-SEGMENTS", "#EXT-X-START"];
        const isAllowedTag = function isAllowedTag(str) {
          return TAGS_ALLOWLIST.some(function (el) {
            return str.startsWith(el);
          });
        };
        const pruneExtinfFromVmapBlock = function pruneExtinfFromVmapBlock(lines, i) {
          let array = lines.slice();
          let index = i;
          if (array[index].includes(AD_MARKER.EXTINF)) {
            array[index] = undefined;
            index += 1;
            if (array[index].includes(AD_MARKER.DISCONTINUITY)) {
              array[index] = undefined;
              index += 1;
              const prunedExtinf = pruneExtinfFromVmapBlock(array, index);
              array = prunedExtinf.array;
              index = prunedExtinf.index;
            }
          }
          return {
            array: array,
            index: index
          };
        };
        const pruneVmapBlock = function pruneVmapBlock(lines) {
          let array = lines.slice();
          for (let i = 0; i < array.length - 1; i += 1) {
            if (array[i].includes(COMCAST_AD_MARKER.VMAP_AD) || array[i].includes(COMCAST_AD_MARKER.VAST) || array[i].includes(COMCAST_AD_MARKER.AD)) {
              array[i] = undefined;
              if (array[i + 1].includes(AD_MARKER.EXTINF)) {
                i += 1;
                const prunedExtinf = pruneExtinfFromVmapBlock(array, i);
                array = prunedExtinf.array;
                i = prunedExtinf.index - 1;
              }
            }
          }
          return array;
        };
        const pruneSpliceoutBlock = function pruneSpliceoutBlock(line, index, array) {
          if (!line.startsWith(AD_MARKER.CUE)) {
            return line;
          }
          line = undefined;
          index += 1;
          if (array[index].startsWith(AD_MARKER.ASSET)) {
            array[index] = undefined;
            index += 1;
          }
          if (array[index].startsWith(AD_MARKER.SCTE35)) {
            array[index] = undefined;
            index += 1;
          }
          if (array[index].startsWith(AD_MARKER.CUE_IN)) {
            array[index] = undefined;
            index += 1;
          }
          if (array[index].startsWith(AD_MARKER.SCTE35)) {
            array[index] = undefined;
          }
          return line;
        };
        const removeM3ULineRegexp = toRegExp(propsToRemove);
        const pruneInfBlock = function pruneInfBlock(line, index, array) {
          if (!line.startsWith(AD_MARKER.EXTINF)) {
            return line;
          }
          if (!removeM3ULineRegexp.test(array[index + 1])) {
            return line;
          }
          if (!isAllowedTag(array[index])) {
            array[index] = undefined;
          }
          index += 1;
          if (!isAllowedTag(array[index])) {
            array[index] = undefined;
          }
          index += 1;
          if (array[index].startsWith(AD_MARKER.DISCONTINUITY)) {
            array[index] = undefined;
          }
          return line;
        };
        const pruneSegments = function pruneSegments(lines) {
          for (let i = 0; i < lines.length - 1; i += 1) {
            var _lines$i;
            if ((_lines$i = lines[i]) !== null && _lines$i !== void 0 && _lines$i.startsWith(SEGMENT_MARKER) && removeM3ULineRegexp.test(lines[i])) {
              const segmentName = lines[i].substring(0, lines[i].indexOf(":"));
              if (!segmentName) {
                return lines;
              }
              lines[i] = undefined;
              i += 1;
              for (let j = i; j < lines.length; j += 1) {
                if (!lines[j].includes(segmentName) && !isAllowedTag(lines[j])) {
                  lines[j] = undefined;
                } else {
                  i = j - 1;
                  break;
                }
              }
            }
          }
          return lines;
        };
        const isM3U = function isM3U(text) {
          if (typeof text === "string") {
            const trimmedText = text.trim();
            return trimmedText.startsWith(AD_MARKER.EXTM3U) || trimmedText.startsWith(COMCAST_AD_MARKER.VMAP_AD_BREAK);
          }
          return false;
        };
        const isPruningNeeded = function isPruningNeeded(text, regexp) {
          return isM3U(text) && regexp.test(text);
        };
        const pruneM3U = function pruneM3U(text) {
          let lines = text.split(/\n\r|\n|\r/);
          if (text.includes(COMCAST_AD_MARKER.VMAP_AD_BREAK)) {
            lines = pruneVmapBlock(lines);
            return lines.filter(function (l) {
              return !!l;
            }).join("\n");
          }
          lines = pruneSegments(lines);
          return lines.map(function (line, index, array) {
            if (typeof line === "undefined") {
              return line;
            }
            line = pruneSpliceoutBlock(line, index, array);
            if (typeof line !== "undefined") {
              line = pruneInfBlock(line, index, array);
            }
            return line;
          }).filter(function (l) {
            return !!l;
          }).join("\n");
        };
        const xhrWrapper = function xhrWrapper(target, thisArg, args) {
          const xhrURL = args[1];
          if (typeof xhrURL !== "string" || xhrURL.length === 0) {
            return Reflect.apply(target, thisArg, args);
          }
          if (urlMatchRegexp.test(xhrURL)) {
            thisArg.addEventListener("readystatechange", function pruneResponse() {
              if (thisArg.readyState === 4) {
                const response = thisArg.response;
                thisArg.removeEventListener("readystatechange", pruneResponse);
                if (!propsToRemove) {
                  if (isM3U(response)) {
                    const message = "XMLHttpRequest.open() URL: ".concat(xhrURL, "\nresponse: ").concat(response);
                    logMessage(source, message);
                  }
                } else {
                  shouldPruneResponse = isPruningNeeded(response, removeM3ULineRegexp);
                }
                if (shouldPruneResponse) {
                  const prunedResponseContent = pruneM3U(response);
                  Object.defineProperty(thisArg, "response", {
                    value: prunedResponseContent
                  });
                  Object.defineProperty(thisArg, "responseText", {
                    value: prunedResponseContent
                  });
                  hit(source);
                }
              }
            });
          }
          return Reflect.apply(target, thisArg, args);
        };
        const xhrHandler = {
          apply: xhrWrapper
        };
        window.XMLHttpRequest.prototype.open = new Proxy(window.XMLHttpRequest.prototype.open, xhrHandler);
        const nativeFetch = window.fetch;
        const fetchWrapper = async function fetchWrapper(target, thisArg, args) {
          const fetchURL = args[0] instanceof Request ? args[0].url : args[0];
          if (typeof fetchURL !== "string" || fetchURL.length === 0) {
            return Reflect.apply(target, thisArg, args);
          }
          if (urlMatchRegexp.test(fetchURL)) {
            const response = await nativeFetch(...args);
            const responseText = await response.text();
            if (!propsToRemove && isM3U(responseText)) {
              const message = "fetch URL: ".concat(fetchURL, "\nresponse text: ").concat(responseText);
              logMessage(source, message);
              return Reflect.apply(target, thisArg, args);
            }
            if (isPruningNeeded(responseText, removeM3ULineRegexp)) {
              const prunedText = pruneM3U(responseText);
              hit(source);
              return new Response(prunedText, {
                status: response.status,
                statusText: response.statusText,
                headers: response.headers
              });
            }
            return Reflect.apply(target, thisArg, args);
          }
          return Reflect.apply(target, thisArg, args);
        };
        const fetchHandler = {
          apply: fetchWrapper
        };
        window.fetch = new Proxy(window.fetch, fetchHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        m3uPrune.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function noTopics(source, args) {
      function noTopics(source) {
        const TOPICS_PROPERTY_NAME = "browsingTopics";
        if (Document instanceof Object === false) {
          return;
        }
        if (!Object.prototype.hasOwnProperty.call(Document.prototype, TOPICS_PROPERTY_NAME) || Document.prototype[TOPICS_PROPERTY_NAME] instanceof Function === false) {
          return;
        }
        Document.prototype[TOPICS_PROPERTY_NAME] = function () {
          return noopPromiseResolve("[]");
        };
        hit(source);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function noopPromiseResolve() {
        let responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "{}";
        let responseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        let responseType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "default";
        if (typeof Response === "undefined") {
          return;
        }
        const response = new Response(responseBody, {
          status: 200,
          statusText: "OK"
        });
        Object.defineProperties(response, {
          url: {
            value: responseUrl
          },
          type: {
            value: responseType
          }
        });
        return Promise.resolve(response);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        noTopics.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function noeval(source, args) {
      function noeval(source) {
        window.eval = function evalWrapper(s) {
          hit(source);
          logMessage(source, "AdGuard has prevented eval:\n".concat(s), true);
        }.bind();
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        noeval.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function nowebrtc(source, args) {
      function nowebrtc(source) {
        let propertyName = "";
        if (window.RTCPeerConnection) {
          propertyName = "RTCPeerConnection";
        } else if (window.webkitRTCPeerConnection) {
          propertyName = "webkitRTCPeerConnection";
        }
        if (propertyName === "") {
          return;
        }
        const rtcReplacement = function rtcReplacement(config) {
          const message = "Document tried to create an RTCPeerConnection: ".concat(convertRtcConfigToString(config));
          logMessage(source, message);
          hit(source);
        };
        rtcReplacement.prototype = {
          close: noopFunc,
          createDataChannel: noopFunc,
          createOffer: noopFunc,
          setRemoteDescription: noopFunc
        };
        const rtc = window[propertyName];
        window[propertyName] = rtcReplacement;
        if (rtc.prototype) {
          rtc.prototype.createDataChannel = function (a, b) {
            return {
              close: noopFunc,
              send: noopFunc
            };
          }.bind(null);
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function noopFunc() {}
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function convertRtcConfigToString(config) {
        const UNDEF_STR = "undefined";
        let str = UNDEF_STR;
        if (config === null) {
          str = "null";
        } else if (config instanceof Object) {
          const SERVERS_PROP_NAME = "iceServers";
          const URLS_PROP_NAME = "urls";
          if (Object.prototype.hasOwnProperty.call(config, SERVERS_PROP_NAME) && Object.prototype.hasOwnProperty.call(config[SERVERS_PROP_NAME][0], URLS_PROP_NAME) && !!config[SERVERS_PROP_NAME][0][URLS_PROP_NAME]) {
            str = config[SERVERS_PROP_NAME][0][URLS_PROP_NAME].toString();
          }
        }
        return str;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        nowebrtc.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventAddEventListener(source, args) {
      function preventAddEventListener(source, typeSearch, listenerSearch) {
        const typeSearchRegexp = toRegExp(typeSearch);
        const listenerSearchRegexp = toRegExp(listenerSearch);
        const nativeAddEventListener = window.EventTarget.prototype.addEventListener;
        function addEventListenerWrapper(type, listener) {
          var _this$constructor;
          let shouldPrevent = false;
          if (validateType(type) && validateListener(listener)) {
            shouldPrevent = typeSearchRegexp.test(type.toString()) && listenerSearchRegexp.test(listenerToString(listener));
          }
          if (shouldPrevent) {
            hit(source);
            return undefined;
          }
          let context = this;
          if (this && ((_this$constructor = this.constructor) === null || _this$constructor === void 0 ? void 0 : _this$constructor.name) === "Window" && this !== window) {
            context = window;
          }
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }
          return nativeAddEventListener.apply(context, [type, listener, ...args]);
        }
        const descriptor = {
          configurable: true,
          set: function set() {},
          get: function get() {
            return addEventListenerWrapper;
          }
        };
        Object.defineProperty(window.EventTarget.prototype, "addEventListener", descriptor);
        Object.defineProperty(window, "addEventListener", descriptor);
        Object.defineProperty(document, "addEventListener", descriptor);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function validateType(type) {
        return typeof type !== "undefined";
      }
      function validateListener(listener) {
        return typeof listener !== "undefined" && (typeof listener === "function" || typeof listener === "object" && listener !== null && typeof listener.handleEvent === "function");
      }
      function listenerToString(listener) {
        return typeof listener === "function" ? listener.toString() : listener.handleEvent.toString();
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventAddEventListener.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventAdfly(source, args) {
      function preventAdfly(source) {
        const isDigit = function isDigit(data) {
          return /^\d$/.test(data);
        };
        const handler = function handler(encodedURL) {
          let evenChars = "";
          let oddChars = "";
          for (let i = 0; i < encodedURL.length; i += 1) {
            if (i % 2 === 0) {
              evenChars += encodedURL.charAt(i);
            } else {
              oddChars = encodedURL.charAt(i) + oddChars;
            }
          }
          let data = (evenChars + oddChars).split("");
          for (let i = 0; i < data.length; i += 1) {
            if (isDigit(data[i])) {
              for (let ii = i + 1; ii < data.length; ii += 1) {
                if (isDigit(data[ii])) {
                  const temp = parseInt(data[i], 10) ^ parseInt(data[ii], 10);
                  if (temp < 10) {
                    data[i] = temp.toString();
                  }
                  i = ii;
                  break;
                }
              }
            }
          }
          data = data.join("");
          const decodedURL = window.atob(data).slice(16, -16);
          if (window.stop) {
            window.stop();
          }
          window.onbeforeunload = null;
          window.location.href = decodedURL;
        };
        let val;
        let applyHandler = true;
        const result = setPropertyAccess(window, "ysmm", {
          configurable: false,
          set: function set(value) {
            if (applyHandler) {
              applyHandler = false;
              try {
                if (typeof value === "string") {
                  handler(value);
                }
              } catch (err) {}
            }
            val = value;
          },
          get: function get() {
            return val;
          }
        });
        if (result) {
          hit(source);
        } else {
          logMessage(source, "Failed to set up prevent-adfly scriptlet");
        }
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventAdfly.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventBab(source, args) {
      function preventBab(source) {
        const nativeSetTimeout = window.setTimeout;
        const babRegex = /\.bab_elementid.$/;
        const timeoutWrapper = function timeoutWrapper(callback) {
          if (typeof callback !== "string" || !babRegex.test(callback)) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeSetTimeout.apply(window, [callback, ...args]);
          }
          hit(source);
        };
        window.setTimeout = timeoutWrapper;
        const signatures = [["blockadblock"], ["babasbm"], [/getItem\('babn'\)/], ["getElementById", "String.fromCharCode", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", "charAt", "DOMContentLoaded", "AdBlock", "addEventListener", "doScroll", "fromCharCode", "<<2|r>>4", "sessionStorage", "clientWidth", "localStorage", "Math", "random"]];
        const check = function check(str) {
          if (typeof str !== "string") {
            return false;
          }
          for (let i = 0; i < signatures.length; i += 1) {
            const tokens = signatures[i];
            let match = 0;
            for (let j = 0; j < tokens.length; j += 1) {
              const token = tokens[j];
              const found = token instanceof RegExp ? token.test(str) : str.indexOf(token) > -1;
              if (found) {
                match += 1;
              }
            }
            if (match / tokens.length >= .8) {
              return true;
            }
          }
          return false;
        };
        const nativeEval = window.eval;
        const evalWrapper = function evalWrapper(str) {
          if (!check(str)) {
            return nativeEval(str);
          }
          hit(source);
          const bodyEl = document.body;
          if (bodyEl) {
            bodyEl.style.removeProperty("visibility");
          }
          const el = document.getElementById("babasbmsgx");
          if (el) {
            el.parentNode.removeChild(el);
          }
        };
        window.eval = evalWrapper.bind(window);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventBab.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventElementSrcLoading(source, args) {
      function preventElementSrcLoading(source, tagName, match) {
        if (typeof Proxy === "undefined" || typeof Reflect === "undefined") {
          return;
        }
        const srcMockData = {
          script: "data:text/javascript;base64,KCk9Pnt9",
          img: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
          iframe: "data:text/html;base64, PGRpdj48L2Rpdj4="
        };
        let instance;
        if (tagName === "script") {
          instance = HTMLScriptElement;
        } else if (tagName === "img") {
          instance = HTMLImageElement;
        } else if (tagName === "iframe") {
          instance = HTMLIFrameElement;
        } else {
          return;
        }
        const hasTrustedTypes = window.trustedTypes && typeof window.trustedTypes.createPolicy === "function";
        let policy;
        if (hasTrustedTypes) {
          policy = window.trustedTypes.createPolicy("AGPolicy", {
            createScriptURL: function createScriptURL(arg) {
              return arg;
            }
          });
        }
        const SOURCE_PROPERTY_NAME = "src";
        const ONERROR_PROPERTY_NAME = "onerror";
        const searchRegexp = toRegExp(match);
        const setMatchedAttribute = function setMatchedAttribute(elem) {
          return elem.setAttribute(source.name, "matched");
        };
        const setAttributeWrapper = function setAttributeWrapper(target, thisArg, args) {
          if (!args[0] || !args[1]) {
            return Reflect.apply(target, thisArg, args);
          }
          const nodeName = thisArg.nodeName.toLowerCase();
          const attrName = args[0].toLowerCase();
          const attrValue = args[1];
          const isMatched = attrName === SOURCE_PROPERTY_NAME && tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(attrValue);
          if (!isMatched) {
            return Reflect.apply(target, thisArg, args);
          }
          hit(source);
          setMatchedAttribute(thisArg);
          return Reflect.apply(target, thisArg, [attrName, srcMockData[nodeName]]);
        };
        const setAttributeHandler = {
          apply: setAttributeWrapper
        };
        instance.prototype.setAttribute = new Proxy(Element.prototype.setAttribute, setAttributeHandler);
        const origSrcDescriptor = safeGetDescriptor(instance.prototype, SOURCE_PROPERTY_NAME);
        if (!origSrcDescriptor) {
          return;
        }
        Object.defineProperty(instance.prototype, SOURCE_PROPERTY_NAME, {
          enumerable: true,
          configurable: true,
          get() {
            return origSrcDescriptor.get.call(this);
          },
          set(urlValue) {
            const nodeName = this.nodeName.toLowerCase();
            const isMatched = tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(urlValue);
            if (!isMatched) {
              origSrcDescriptor.set.call(this, urlValue);
              return true;
            }
            if (policy && urlValue instanceof TrustedScriptURL) {
              const trustedSrc = policy.createScriptURL(urlValue);
              origSrcDescriptor.set.call(this, trustedSrc);
              hit(source);
              return;
            }
            setMatchedAttribute(this);
            origSrcDescriptor.set.call(this, srcMockData[nodeName]);
            hit(source);
          }
        });
        const origOnerrorDescriptor = safeGetDescriptor(HTMLElement.prototype, ONERROR_PROPERTY_NAME);
        if (!origOnerrorDescriptor) {
          return;
        }
        Object.defineProperty(HTMLElement.prototype, ONERROR_PROPERTY_NAME, {
          enumerable: true,
          configurable: true,
          get() {
            return origOnerrorDescriptor.get.call(this);
          },
          set(cb) {
            const isMatched = this.getAttribute(source.name) === "matched";
            if (!isMatched) {
              origOnerrorDescriptor.set.call(this, cb);
              return true;
            }
            origOnerrorDescriptor.set.call(this, noopFunc);
            return true;
          }
        });
        const addEventListenerWrapper = function addEventListenerWrapper(target, thisArg, args) {
          if (!args[0] || !args[1] || !thisArg) {
            return Reflect.apply(target, thisArg, args);
          }
          const eventName = args[0];
          const isMatched = typeof thisArg.getAttribute === "function" && thisArg.getAttribute(source.name) === "matched" && eventName === "error";
          if (isMatched) {
            return Reflect.apply(target, thisArg, [eventName, noopFunc]);
          }
          return Reflect.apply(target, thisArg, args);
        };
        const addEventListenerHandler = {
          apply: addEventListenerWrapper
        };
        EventTarget.prototype.addEventListener = new Proxy(EventTarget.prototype.addEventListener, addEventListenerHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function safeGetDescriptor(obj, prop) {
        const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        if (descriptor && descriptor.configurable) {
          return descriptor;
        }
        return null;
      }
      function noopFunc() {}
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventElementSrcLoading.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventEvalIf(source, args) {
      function preventEvalIf(source, search) {
        const searchRegexp = toRegExp(search);
        const nativeEval = window.eval;
        window.eval = function (payload) {
          if (!searchRegexp.test(payload.toString())) {
            return nativeEval.call(window, payload);
          }
          hit(source);
          return undefined;
        }.bind(window);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventEvalIf.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventFab(source, args) {
      function preventFab(source) {
        hit(source);
        const Fab = function Fab() {};
        Fab.prototype.check = noopFunc;
        Fab.prototype.clearEvent = noopFunc;
        Fab.prototype.emitEvent = noopFunc;
        Fab.prototype.on = function (a, b) {
          if (!a) {
            b();
          }
          return this;
        };
        Fab.prototype.onDetected = noopThis;
        Fab.prototype.onNotDetected = function (a) {
          a();
          return this;
        };
        Fab.prototype.setOption = noopFunc;
        Fab.prototype.options = {
          set: noopFunc,
          get: noopFunc
        };
        const fab = new Fab();
        const getSetFab = {
          get() {
            return Fab;
          },
          set() {}
        };
        const getsetfab = {
          get() {
            return fab;
          },
          set() {}
        };
        if (Object.prototype.hasOwnProperty.call(window, "FuckAdBlock")) {
          window.FuckAdBlock = Fab;
        } else {
          Object.defineProperty(window, "FuckAdBlock", getSetFab);
        }
        if (Object.prototype.hasOwnProperty.call(window, "BlockAdBlock")) {
          window.BlockAdBlock = Fab;
        } else {
          Object.defineProperty(window, "BlockAdBlock", getSetFab);
        }
        if (Object.prototype.hasOwnProperty.call(window, "SniffAdBlock")) {
          window.SniffAdBlock = Fab;
        } else {
          Object.defineProperty(window, "SniffAdBlock", getSetFab);
        }
        if (Object.prototype.hasOwnProperty.call(window, "fuckAdBlock")) {
          window.fuckAdBlock = fab;
        } else {
          Object.defineProperty(window, "fuckAdBlock", getsetfab);
        }
        if (Object.prototype.hasOwnProperty.call(window, "blockAdBlock")) {
          window.blockAdBlock = fab;
        } else {
          Object.defineProperty(window, "blockAdBlock", getsetfab);
        }
        if (Object.prototype.hasOwnProperty.call(window, "sniffAdBlock")) {
          window.sniffAdBlock = fab;
        } else {
          Object.defineProperty(window, "sniffAdBlock", getsetfab);
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function noopFunc() {}
      function noopThis() {
        return this;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventFab.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventFetch(source, args) {
      function preventFetch(source, propsToMatch) {
        let responseBody = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "emptyObj";
        let responseType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "default";
        if (typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
          return;
        }
        let strResponseBody;
        if (responseBody === "" || responseBody === "emptyObj") {
          strResponseBody = "{}";
        } else if (responseBody === "emptyArr") {
          strResponseBody = "[]";
        } else {
          return;
        }
        if (!(responseType === "default" || responseType === "opaque")) {
          logMessage(source, "Invalid parameter: ".concat(responseType));
          return;
        }
        const handlerWrapper = function handlerWrapper(target, thisArg, args) {
          let shouldPrevent = false;
          const fetchData = getFetchData(args);
          if (typeof propsToMatch === "undefined") {
            logMessage(source, "fetch( ".concat(objectToString(fetchData), " )"), true);
            hit(source);
            return Reflect.apply(target, thisArg, args);
          }
          shouldPrevent = matchRequestProps(source, propsToMatch, fetchData);
          if (shouldPrevent) {
            hit(source);
            return noopPromiseResolve(strResponseBody, fetchData.url, responseType);
          }
          return Reflect.apply(target, thisArg, args);
        };
        const fetchHandler = {
          apply: handlerWrapper
        };
        fetch = new Proxy(fetch, fetchHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function getFetchData(args) {
        const fetchPropsObj = {};
        let fetchUrl;
        let fetchInit;
        if (args[0] instanceof Request) {
          const requestData = getRequestData(args[0]);
          fetchUrl = requestData.url;
          fetchInit = requestData;
        } else {
          fetchUrl = args[0];
          fetchInit = args[1];
        }
        fetchPropsObj.url = fetchUrl;
        if (fetchInit instanceof Object) {
          Object.keys(fetchInit).forEach(function (prop) {
            fetchPropsObj[prop] = fetchInit[prop];
          });
        }
        return fetchPropsObj;
      }
      function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
          return String(obj);
        }
        return isEmptyObject(obj) ? "{}" : getObjectEntries(obj).map(function (pair) {
          const key = pair[0];
          const value = pair[1];
          let recordValueStr = value;
          if (value instanceof Object) {
            recordValueStr = "{ ".concat(objectToString(value), " }");
          }
          return "".concat(key, ':"').concat(recordValueStr, '"');
        }).join(" ");
      }
      function noopPromiseResolve() {
        let responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "{}";
        let responseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        let responseType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "default";
        if (typeof Response === "undefined") {
          return;
        }
        const response = new Response(responseBody, {
          status: 200,
          statusText: "OK"
        });
        Object.defineProperties(response, {
          url: {
            value: responseUrl
          },
          type: {
            value: responseType
          }
        });
        return Promise.resolve(response);
      }
      function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
          return true;
        }
        let isMatched;
        const parsedData = parseMatchProps(propsToMatch);
        if (!validateParsedData(parsedData)) {
          logMessage(source, "Invalid parameter: ".concat(propsToMatch));
          isMatched = false;
        } else {
          const matchData = getMatchPropsData(parsedData);
          isMatched = Object.keys(matchData).every(function (matchKey) {
            const matchValue = matchData[matchKey];
            return Object.prototype.hasOwnProperty.call(requestData, matchKey) && matchValue.test(requestData[matchKey]);
          });
        }
        return isMatched;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getRequestData(request) {
        const requestInitOptions = getRequestProps();
        const entries = requestInitOptions.map(function (key) {
          const value = request[key];
          return [key, value];
        });
        return getObjectFromEntries(entries);
      }
      function getRequestProps() {
        return ["url", "method", "headers", "body", "mode", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal"];
      }
      function getObjectEntries(object) {
        const keys = Object.keys(object);
        const entries = [];
        keys.forEach(function (key) {
          return entries.push([key, object[key]]);
        });
        return entries;
      }
      function getObjectFromEntries(entries) {
        const output = entries.reduce(function (acc, el) {
          const key = el[0];
          const value = el[1];
          acc[key] = value;
          return acc;
        }, {});
        return output;
      }
      function parseMatchProps(propsToMatchStr) {
        const PROPS_DIVIDER = " ";
        const PAIRS_MARKER = ":";
        const LEGAL_MATCH_PROPS = getRequestProps();
        const propsObj = {};
        const props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach(function (prop) {
          const dividerInd = prop.indexOf(PAIRS_MARKER);
          const key = prop.slice(0, dividerInd);
          const hasLegalMatchProp = LEGAL_MATCH_PROPS.indexOf(key) !== -1;
          if (hasLegalMatchProp) {
            const value = prop.slice(dividerInd + 1);
            propsObj[key] = value;
          } else {
            propsObj.url = prop;
          }
        });
        return propsObj;
      }
      function validateParsedData(data) {
        return Object.values(data).every(function (value) {
          return isValidStrPattern(value);
        });
      }
      function getMatchPropsData(data) {
        const matchData = {};
        Object.keys(data).forEach(function (key) {
          matchData[key] = toRegExp(data[key]);
        });
        return matchData;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventFetch.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventPopadsNet(source, args) {
      function preventPopadsNet(source) {
        const rid = randomId();
        const throwError = function throwError() {
          throw new ReferenceError(rid);
        };
        delete window.PopAds;
        delete window.popns;
        Object.defineProperties(window, {
          PopAds: {
            set: throwError
          },
          popns: {
            set: throwError
          }
        });
        window.onerror = createOnErrorHandler(rid).bind();
        hit(source);
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventPopadsNet.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventRefresh(source, args) {
      function preventRefresh(source, delaySec) {
        const getMetaElements = function getMetaElements() {
          let metaNodes = [];
          try {
            metaNodes = document.querySelectorAll('meta[http-equiv="refresh" i][content]');
          } catch (e) {
            try {
              metaNodes = document.querySelectorAll('meta[http-equiv="refresh"][content]');
            } catch (e) {
              logMessage(source, e);
            }
          }
          return Array.from(metaNodes);
        };
        const getMetaContentDelay = function getMetaContentDelay(metaElements) {
          const delays = metaElements.map(function (meta) {
            const contentString = meta.getAttribute("content");
            if (contentString.length === 0) {
              return null;
            }
            let contentDelay;
            const limiterIndex = contentString.indexOf(";");
            if (limiterIndex !== -1) {
              const delaySubstring = contentString.substring(0, limiterIndex);
              contentDelay = getNumberFromString(delaySubstring);
            } else {
              contentDelay = getNumberFromString(contentString);
            }
            return contentDelay;
          }).filter(function (delay) {
            return delay !== null;
          });
          if (!delays.length) {
            return null;
          }
          const minDelay = delays.reduce(function (a, b) {
            return Math.min(a, b);
          });
          return minDelay;
        };
        const stop = function stop() {
          const metaElements = getMetaElements();
          if (metaElements.length === 0) {
            return;
          }
          let secondsToRun = getNumberFromString(delaySec);
          if (secondsToRun === null) {
            secondsToRun = getMetaContentDelay(metaElements);
          }
          if (secondsToRun === null) {
            return;
          }
          const delayMs = secondsToRun * 1e3;
          setTimeout(function () {
            window.stop();
            hit(source);
          }, delayMs);
        };
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", stop, {
            once: true
          });
        } else {
          stop();
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function getNumberFromString(rawString) {
        const parsedDelay = parseInt(rawString, 10);
        const validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
        return validDelay;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventRefresh.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventRequestAnimationFrame(source, args) {
      function preventRequestAnimationFrame(source, match) {
        const nativeRequestAnimationFrame = window.requestAnimationFrame;
        const shouldLog = typeof match === "undefined";
        const _parseMatchArg = parseMatchArg(match),
          isInvertedMatch = _parseMatchArg.isInvertedMatch,
          matchRegexp = _parseMatchArg.matchRegexp;
        const rafWrapper = function rafWrapper(callback) {
          let shouldPrevent = false;
          if (shouldLog) {
            hit(source);
            logMessage(source, "requestAnimationFrame(".concat(String(callback), ")"), true);
          } else if (isValidCallback(callback) && isValidStrPattern(match)) {
            shouldPrevent = matchRegexp.test(callback.toString()) !== isInvertedMatch;
          }
          if (shouldPrevent) {
            hit(source);
            return nativeRequestAnimationFrame(noopFunc);
          }
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          return nativeRequestAnimationFrame.apply(window, [callback, ...args]);
        };
        window.requestAnimationFrame = rafWrapper;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function noopFunc() {}
      function parseMatchArg(match) {
        const INVERT_MARKER = "!";
        const isInvertedMatch = match ? match.startsWith(INVERT_MARKER) : false;
        const matchValue = isInvertedMatch ? match.slice(1) : match;
        const matchRegexp = toRegExp(matchValue);
        return {
          isInvertedMatch: isInvertedMatch,
          matchRegexp: matchRegexp,
          matchValue: matchValue
        };
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function isValidCallback(callback) {
        return callback instanceof Function || typeof callback === "string";
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventRequestAnimationFrame.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventSetInterval(source, args) {
      function preventSetInterval(source, matchCallback, matchDelay) {
        const shouldLog = typeof matchCallback === "undefined" && typeof matchDelay === "undefined";
        const handlerWrapper = function handlerWrapper(target, thisArg, args) {
          const callback = args[0];
          const delay = args[1];
          let shouldPrevent = false;
          if (shouldLog) {
            hit(source);
            logMessage(source, "setInterval(".concat(String(callback), ", ").concat(delay, ")"), true);
          } else {
            shouldPrevent = isPreventionNeeded({
              callback: callback,
              delay: delay,
              matchCallback: matchCallback,
              matchDelay: matchDelay
            });
          }
          if (shouldPrevent) {
            hit(source);
            args[0] = noopFunc;
          }
          return target.apply(thisArg, args);
        };
        const setIntervalHandler = {
          apply: handlerWrapper
        };
        window.setInterval = new Proxy(window.setInterval, setIntervalHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function noopFunc() {}
      function isPreventionNeeded(_ref) {
        let callback = _ref.callback,
          delay = _ref.delay,
          matchCallback = _ref.matchCallback,
          matchDelay = _ref.matchDelay;
        if (!isValidCallback(callback)) {
          return false;
        }
        if (!isValidMatchStr(matchCallback) || matchDelay && !isValidMatchNumber(matchDelay)) {
          return false;
        }
        const _parseMatchArg = parseMatchArg(matchCallback),
          isInvertedMatch = _parseMatchArg.isInvertedMatch,
          matchRegexp = _parseMatchArg.matchRegexp;
        const _parseDelayArg = parseDelayArg(matchDelay),
          isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,
          delayMatch = _parseDelayArg.delayMatch;
        const parsedDelay = parseRawDelay(delay);
        let shouldPrevent = false;
        const callbackStr = String(callback);
        if (delayMatch === null) {
          shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch;
        } else if (!matchCallback) {
          shouldPrevent = parsedDelay === delayMatch !== isInvertedDelayMatch;
        } else {
          shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch && parsedDelay === delayMatch !== isInvertedDelayMatch;
        }
        return shouldPrevent;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function startsWith(str, prefix) {
        return !!str && str.indexOf(prefix) === 0;
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function parseMatchArg(match) {
        const INVERT_MARKER = "!";
        const isInvertedMatch = match ? match.startsWith(INVERT_MARKER) : false;
        const matchValue = isInvertedMatch ? match.slice(1) : match;
        const matchRegexp = toRegExp(matchValue);
        return {
          isInvertedMatch: isInvertedMatch,
          matchRegexp: matchRegexp,
          matchValue: matchValue
        };
      }
      function parseDelayArg(delay) {
        const INVERT_MARKER = "!";
        const isInvertedDelayMatch = startsWith(delay, INVERT_MARKER);
        let delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;
        delayValue = parseInt(delayValue, 10);
        const delayMatch = nativeIsNaN(delayValue) ? null : delayValue;
        return {
          isInvertedDelayMatch: isInvertedDelayMatch,
          delayMatch: delayMatch
        };
      }
      function isValidCallback(callback) {
        return callback instanceof Function || typeof callback === "string";
      }
      function isValidMatchStr(match) {
        const INVERT_MARKER = "!";
        let str = match;
        if (startsWith(match, INVERT_MARKER)) {
          str = match.slice(1);
        }
        return isValidStrPattern(str);
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function nativeIsFinite(num) {
        const native = Number.isFinite || window.isFinite;
        return native(num);
      }
      function isValidMatchNumber(match) {
        const INVERT_MARKER = "!";
        let str = match;
        if (startsWith(match, INVERT_MARKER)) {
          str = match.slice(1);
        }
        const num = parseFloat(str);
        return !nativeIsNaN(num) && nativeIsFinite(num);
      }
      function parseRawDelay(delay) {
        const parsedDelay = Math.floor(parseInt(delay, 10));
        return typeof parsedDelay === "number" && !nativeIsNaN(parsedDelay) ? parsedDelay : delay;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventSetInterval.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventSetTimeout(source, args) {
      function preventSetTimeout(source, matchCallback, matchDelay) {
        const shouldLog = typeof matchCallback === "undefined" && typeof matchDelay === "undefined";
        const handlerWrapper = function handlerWrapper(target, thisArg, args) {
          const callback = args[0];
          const delay = args[1];
          let shouldPrevent = false;
          if (shouldLog) {
            hit(source);
            logMessage(source, "setTimeout(".concat(String(callback), ", ").concat(delay, ")"), true);
          } else {
            shouldPrevent = isPreventionNeeded({
              callback: callback,
              delay: delay,
              matchCallback: matchCallback,
              matchDelay: matchDelay
            });
          }
          if (shouldPrevent) {
            hit(source);
            args[0] = noopFunc;
          }
          return target.apply(thisArg, args);
        };
        const setTimeoutHandler = {
          apply: handlerWrapper
        };
        window.setTimeout = new Proxy(window.setTimeout, setTimeoutHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function noopFunc() {}
      function isPreventionNeeded(_ref) {
        let callback = _ref.callback,
          delay = _ref.delay,
          matchCallback = _ref.matchCallback,
          matchDelay = _ref.matchDelay;
        if (!isValidCallback(callback)) {
          return false;
        }
        if (!isValidMatchStr(matchCallback) || matchDelay && !isValidMatchNumber(matchDelay)) {
          return false;
        }
        const _parseMatchArg = parseMatchArg(matchCallback),
          isInvertedMatch = _parseMatchArg.isInvertedMatch,
          matchRegexp = _parseMatchArg.matchRegexp;
        const _parseDelayArg = parseDelayArg(matchDelay),
          isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,
          delayMatch = _parseDelayArg.delayMatch;
        const parsedDelay = parseRawDelay(delay);
        let shouldPrevent = false;
        const callbackStr = String(callback);
        if (delayMatch === null) {
          shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch;
        } else if (!matchCallback) {
          shouldPrevent = parsedDelay === delayMatch !== isInvertedDelayMatch;
        } else {
          shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch && parsedDelay === delayMatch !== isInvertedDelayMatch;
        }
        return shouldPrevent;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function parseMatchArg(match) {
        const INVERT_MARKER = "!";
        const isInvertedMatch = match ? match.startsWith(INVERT_MARKER) : false;
        const matchValue = isInvertedMatch ? match.slice(1) : match;
        const matchRegexp = toRegExp(matchValue);
        return {
          isInvertedMatch: isInvertedMatch,
          matchRegexp: matchRegexp,
          matchValue: matchValue
        };
      }
      function parseDelayArg(delay) {
        const INVERT_MARKER = "!";
        const isInvertedDelayMatch = startsWith(delay, INVERT_MARKER);
        let delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;
        delayValue = parseInt(delayValue, 10);
        const delayMatch = nativeIsNaN(delayValue) ? null : delayValue;
        return {
          isInvertedDelayMatch: isInvertedDelayMatch,
          delayMatch: delayMatch
        };
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function startsWith(str, prefix) {
        return !!str && str.indexOf(prefix) === 0;
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function isValidCallback(callback) {
        return callback instanceof Function || typeof callback === "string";
      }
      function isValidMatchStr(match) {
        const INVERT_MARKER = "!";
        let str = match;
        if (startsWith(match, INVERT_MARKER)) {
          str = match.slice(1);
        }
        return isValidStrPattern(str);
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function nativeIsFinite(num) {
        const native = Number.isFinite || window.isFinite;
        return native(num);
      }
      function isValidMatchNumber(match) {
        const INVERT_MARKER = "!";
        let str = match;
        if (startsWith(match, INVERT_MARKER)) {
          str = match.slice(1);
        }
        const num = parseFloat(str);
        return !nativeIsNaN(num) && nativeIsFinite(num);
      }
      function parseRawDelay(delay) {
        const parsedDelay = Math.floor(parseInt(delay, 10));
        return typeof parsedDelay === "number" && !nativeIsNaN(parsedDelay) ? parsedDelay : delay;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventSetTimeout.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventWindowOpen(source, args) {
      function preventWindowOpen(source) {
        let match = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "*";
        let delay = arguments.length > 2 ? arguments[2] : undefined;
        let replacement = arguments.length > 3 ? arguments[3] : undefined;
        const nativeOpen = window.open;
        const isNewSyntax = match !== "0" && match !== "1";
        const oldOpenWrapper = function oldOpenWrapper(str) {
          match = Number(match) > 0;
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          if (!isValidStrPattern(delay)) {
            logMessage(source, "Invalid parameter: ".concat(delay));
            return nativeOpen.apply(window, [str, ...args]);
          }
          const searchRegexp = toRegExp(delay);
          if (match !== searchRegexp.test(str)) {
            return nativeOpen.apply(window, [str, ...args]);
          }
          hit(source);
          return handleOldReplacement(replacement);
        };
        const newOpenWrapper = function newOpenWrapper(url) {
          const shouldLog = replacement && replacement.indexOf("log") > -1;
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          if (shouldLog) {
            const argsStr = args && args.length > 0 ? ", ".concat(args.join(", ")) : "";
            const message = "".concat(url).concat(argsStr);
            logMessage(source, message, true);
            hit(source);
          }
          let shouldPrevent = false;
          if (match === "*") {
            shouldPrevent = true;
          } else if (isValidMatchStr(match)) {
            const _parseMatchArg = parseMatchArg(match),
              isInvertedMatch = _parseMatchArg.isInvertedMatch,
              matchRegexp = _parseMatchArg.matchRegexp;
            shouldPrevent = matchRegexp.test(url) !== isInvertedMatch;
          } else {
            logMessage(source, "Invalid parameter: ".concat(match));
            shouldPrevent = false;
          }
          if (shouldPrevent) {
            const parsedDelay = parseInt(delay, 10);
            let result;
            if (nativeIsNaN(parsedDelay)) {
              result = noopNull();
            } else {
              const decoyArgs = {
                replacement: replacement,
                url: url,
                delay: parsedDelay
              };
              const decoy = createDecoy(decoyArgs);
              let popup = decoy.contentWindow;
              if (typeof popup === "object" && popup !== null) {
                Object.defineProperty(popup, "closed", {
                  value: false
                });
                Object.defineProperty(popup, "opener", {
                  value: window
                });
                Object.defineProperty(popup, "frameElement", {
                  value: null
                });
              } else {
                const nativeGetter = decoy.contentWindow && decoy.contentWindow.get;
                Object.defineProperty(decoy, "contentWindow", {
                  get: getPreventGetter(nativeGetter)
                });
                popup = decoy.contentWindow;
              }
              result = popup;
            }
            hit(source);
            return result;
          }
          return nativeOpen.apply(window, [url, ...args]);
        };
        window.open = isNewSyntax ? newOpenWrapper : oldOpenWrapper;
        window.open.toString = nativeOpen.toString.bind(nativeOpen);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function isValidMatchStr(match) {
        const INVERT_MARKER = "!";
        let str = match;
        if (startsWith(match, INVERT_MARKER)) {
          str = match.slice(1);
        }
        return isValidStrPattern(str);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function parseMatchArg(match) {
        const INVERT_MARKER = "!";
        const isInvertedMatch = match ? match.startsWith(INVERT_MARKER) : false;
        const matchValue = isInvertedMatch ? match.slice(1) : match;
        const matchRegexp = toRegExp(matchValue);
        return {
          isInvertedMatch: isInvertedMatch,
          matchRegexp: matchRegexp,
          matchValue: matchValue
        };
      }
      function handleOldReplacement(replacement) {
        let result;
        if (!replacement) {
          result = noopFunc;
        } else if (replacement === "trueFunc") {
          result = trueFunc;
        } else if (replacement.indexOf("=") > -1) {
          const isProp = startsWith(replacement, "{") && endsWith(replacement, "}");
          if (isProp) {
            const propertyPart = replacement.slice(1, -1);
            const propertyName = substringBefore(propertyPart, "=");
            const propertyValue = substringAfter(propertyPart, "=");
            if (propertyValue === "noopFunc") {
              result = {};
              result[propertyName] = noopFunc;
            }
          }
        }
        return result;
      }
      function createDecoy(args) {
        const OBJECT_TAG_NAME = "object";
        const OBJECT_URL_PROP_NAME = "data";
        const IFRAME_TAG_NAME = "iframe";
        const IFRAME_URL_PROP_NAME = "src";
        const replacement = args.replacement,
          url = args.url,
          delay = args.delay;
        let tag;
        let urlProp;
        if (replacement === "obj") {
          tag = OBJECT_TAG_NAME;
          urlProp = OBJECT_URL_PROP_NAME;
        } else {
          tag = IFRAME_TAG_NAME;
          urlProp = IFRAME_URL_PROP_NAME;
        }
        const decoy = document.createElement(tag);
        decoy[urlProp] = url;
        decoy.style.setProperty("height", "1px", "important");
        decoy.style.setProperty("position", "fixed", "important");
        decoy.style.setProperty("top", "-1px", "important");
        decoy.style.setProperty("width", "1px", "important");
        document.body.appendChild(decoy);
        setTimeout(function () {
          return decoy.remove();
        }, delay * 1e3);
        return decoy;
      }
      function getPreventGetter(nativeGetter) {
        const preventGetter = function preventGetter(target, prop) {
          if (prop && prop === "closed") {
            return false;
          }
          if (typeof nativeGetter === "function") {
            return noopFunc;
          }
          return prop && target[prop];
        };
        return preventGetter;
      }
      function noopNull() {
        return null;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function noopFunc() {}
      function trueFunc() {
        return true;
      }
      function startsWith(str, prefix) {
        return !!str && str.indexOf(prefix) === 0;
      }
      function endsWith(str, ending) {
        return !!str && str.lastIndexOf(ending) === str.length - ending.length;
      }
      function substringBefore(str, separator) {
        if (!str || !separator) {
          return str;
        }
        const index = str.indexOf(separator);
        return index < 0 ? str : str.substring(0, index);
      }
      function substringAfter(str, separator) {
        if (!str) {
          return str;
        }
        const index = str.indexOf(separator);
        return index < 0 ? "" : str.substring(index + separator.length);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventWindowOpen.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventXHR(source, args) {
      function preventXHR(source, propsToMatch, customResponseText) {
        if (typeof Proxy === "undefined") {
          return;
        }
        let response = "";
        let responseText = "";
        let responseUrl;
        const openWrapper = function openWrapper(target, thisArg, args) {
          const xhrData = {
            method: args[0],
            url: args[1]
          };
          responseUrl = xhrData.url;
          if (typeof propsToMatch === "undefined") {
            logMessage(source, "xhr( ".concat(objectToString(xhrData), " )"), true);
            hit(source);
          } else if (matchRequestProps(source, propsToMatch, xhrData)) {
            thisArg.shouldBePrevented = true;
          }
          return Reflect.apply(target, thisArg, args);
        };
        const sendWrapper = function sendWrapper(target, thisArg, args) {
          if (!thisArg.shouldBePrevented) {
            return Reflect.apply(target, thisArg, args);
          }
          if (thisArg.responseType === "blob") {
            response = new Blob();
          }
          if (thisArg.responseType === "arraybuffer") {
            response = new ArrayBuffer();
          }
          if (customResponseText) {
            const randomText = generateRandomResponse(customResponseText);
            if (randomText) {
              responseText = randomText;
            } else {
              logMessage(source, "Invalid range: ".concat(customResponseText));
            }
          }
          Object.defineProperties(thisArg, {
            readyState: {
              value: 4,
              writable: false
            },
            response: {
              value: response,
              writable: false
            },
            responseText: {
              value: responseText,
              writable: false
            },
            responseURL: {
              value: responseUrl,
              writable: false
            },
            responseXML: {
              value: "",
              writable: false
            },
            status: {
              value: 200,
              writable: false
            },
            statusText: {
              value: "OK",
              writable: false
            }
          });
          setTimeout(function () {
            const stateEvent = new Event("readystatechange");
            thisArg.dispatchEvent(stateEvent);
            const loadEvent = new Event("load");
            thisArg.dispatchEvent(loadEvent);
            const loadEndEvent = new Event("loadend");
            thisArg.dispatchEvent(loadEndEvent);
          }, 1);
          hit(source);
          return undefined;
        };
        const openHandler = {
          apply: openWrapper
        };
        const sendHandler = {
          apply: sendWrapper
        };
        XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
        XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
          return String(obj);
        }
        return isEmptyObject(obj) ? "{}" : getObjectEntries(obj).map(function (pair) {
          const key = pair[0];
          const value = pair[1];
          let recordValueStr = value;
          if (value instanceof Object) {
            recordValueStr = "{ ".concat(objectToString(value), " }");
          }
          return "".concat(key, ':"').concat(recordValueStr, '"');
        }).join(" ");
      }
      function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
          return true;
        }
        let isMatched;
        const parsedData = parseMatchProps(propsToMatch);
        if (!validateParsedData(parsedData)) {
          logMessage(source, "Invalid parameter: ".concat(propsToMatch));
          isMatched = false;
        } else {
          const matchData = getMatchPropsData(parsedData);
          isMatched = Object.keys(matchData).every(function (matchKey) {
            const matchValue = matchData[matchKey];
            return Object.prototype.hasOwnProperty.call(requestData, matchKey) && matchValue.test(requestData[matchKey]);
          });
        }
        return isMatched;
      }
      function generateRandomResponse(customResponseText) {
        let customResponse = customResponseText;
        if (customResponse === "true") {
          customResponse = Math.random().toString(36).slice(-10);
          return customResponse;
        }
        customResponse = customResponse.replace("length:", "");
        const rangeRegex = /^\d+-\d+$/;
        if (!rangeRegex.test(customResponse)) {
          return null;
        }
        let rangeMin = getNumberFromString(customResponse.split("-")[0]);
        let rangeMax = getNumberFromString(customResponse.split("-")[1]);
        if (!nativeIsFinite(rangeMin) || !nativeIsFinite(rangeMax)) {
          return null;
        }
        if (rangeMin > rangeMax) {
          const temp = rangeMin;
          rangeMin = rangeMax;
          rangeMax = temp;
        }
        const LENGTH_RANGE_LIMIT = 500 * 1e3;
        if (rangeMax > LENGTH_RANGE_LIMIT) {
          return null;
        }
        const length = getRandomIntInclusive(rangeMin, rangeMax);
        customResponse = getRandomStrByLength(length);
        return customResponse;
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getObjectEntries(object) {
        const keys = Object.keys(object);
        const entries = [];
        keys.forEach(function (key) {
          return entries.push([key, object[key]]);
        });
        return entries;
      }
      function getNumberFromString(rawString) {
        const parsedDelay = parseInt(rawString, 10);
        const validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
        return validDelay;
      }
      function nativeIsFinite(num) {
        const native = Number.isFinite || window.isFinite;
        return native(num);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function parseMatchProps(propsToMatchStr) {
        const PROPS_DIVIDER = " ";
        const PAIRS_MARKER = ":";
        const LEGAL_MATCH_PROPS = getRequestProps();
        const propsObj = {};
        const props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach(function (prop) {
          const dividerInd = prop.indexOf(PAIRS_MARKER);
          const key = prop.slice(0, dividerInd);
          const hasLegalMatchProp = LEGAL_MATCH_PROPS.indexOf(key) !== -1;
          if (hasLegalMatchProp) {
            const value = prop.slice(dividerInd + 1);
            propsObj[key] = value;
          } else {
            propsObj.url = prop;
          }
        });
        return propsObj;
      }
      function validateParsedData(data) {
        return Object.values(data).every(function (value) {
          return isValidStrPattern(value);
        });
      }
      function getMatchPropsData(data) {
        const matchData = {};
        Object.keys(data).forEach(function (key) {
          matchData[key] = toRegExp(data[key]);
        });
        return matchData;
      }
      function getRequestProps() {
        return ["url", "method", "headers", "body", "mode", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal"];
      }
      function getRandomIntInclusive(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1) + min);
      }
      function getRandomStrByLength(length) {
        let result = "";
        const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+=~";
        const charactersLength = characters.length;
        for (let i = 0; i < length; i += 1) {
          result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return result;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventXHR.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function removeAttr(source, args) {
      function removeAttr(source, attrs, selector) {
        let applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "asap stay";
        if (!attrs) {
          return;
        }
        attrs = attrs.split(/\s*\|\s*/);
        if (!selector) {
          selector = "[".concat(attrs.join("],["), "]");
        }
        const rmattr = function rmattr() {
          let nodes = [];
          try {
            nodes = [].slice.call(document.querySelectorAll(selector));
          } catch (e) {
            logMessage(source, "Invalid selector arg: '".concat(selector, "'"));
          }
          let removed = false;
          nodes.forEach(function (node) {
            attrs.forEach(function (attr) {
              node.removeAttribute(attr);
              removed = true;
            });
          });
          if (removed) {
            hit(source);
          }
        };
        const flags = parseFlags(applying);
        const run = function run() {
          rmattr();
          if (!flags.hasFlag(flags.STAY)) {
            return;
          }
          observeDOMChanges(rmattr, true);
        };
        if (flags.hasFlag(flags.ASAP)) {
          if (document.readyState === "loading") {
            window.addEventListener("DOMContentLoaded", rmattr, {
              once: true
            });
          } else {
            rmattr();
          }
        }
        if (document.readyState !== "complete" && flags.hasFlag(flags.COMPLETE)) {
          window.addEventListener("load", run, {
            once: true
          });
        } else if (flags.hasFlag(flags.STAY)) {
          if (!applying.indexOf(" ") !== -1) {
            rmattr();
          }
          observeDOMChanges(rmattr, true);
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function observeDOMChanges(callback) {
        let observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        const THROTTLE_DELAY_MS = 20;
        const observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        const connect = function connect() {
          if (attrsToObserve.length > 0) {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs,
              attributeFilter: attrsToObserve
            });
          } else {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs
            });
          }
        };
        const disconnect = function disconnect() {
          observer.disconnect();
        };
        function callbackWrapper() {
          disconnect();
          callback();
          connect();
        }
        connect();
      }
      function parseFlags(flags) {
        const FLAGS_DIVIDER = " ";
        const ASAP_FLAG = "asap";
        const COMPLETE_FLAG = "complete";
        const STAY_FLAG = "stay";
        const VALID_FLAGS = [STAY_FLAG, ASAP_FLAG, COMPLETE_FLAG];
        const passedFlags = flags.trim().split(FLAGS_DIVIDER).filter(function (f) {
          return VALID_FLAGS.indexOf(f) !== -1;
        });
        return {
          ASAP: ASAP_FLAG,
          COMPLETE: COMPLETE_FLAG,
          STAY: STAY_FLAG,
          hasFlag(flag) {
            return passedFlags.indexOf(flag) !== -1;
          }
        };
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function throttle(cb, delay) {
        let wait = false;
        let savedArgs;
        const wrapper = function wrapper() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (wait) {
            savedArgs = args;
            return;
          }
          cb(...args);
          wait = true;
          setTimeout(function () {
            wait = false;
            if (savedArgs) {
              wrapper(...savedArgs);
              savedArgs = null;
            }
          }, delay);
        };
        return wrapper;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        removeAttr.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function removeClass(source, args) {
      function removeClass(source, classNames, selector) {
        let applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "asap stay";
        if (!classNames) {
          return;
        }
        classNames = classNames.split(/\s*\|\s*/);
        let selectors = [];
        if (!selector) {
          selectors = classNames.map(function (className) {
            return ".".concat(className);
          });
        }
        const removeClassHandler = function removeClassHandler() {
          const nodes = new Set();
          if (selector) {
            let foundNodes = [];
            try {
              foundNodes = [].slice.call(document.querySelectorAll(selector));
            } catch (e) {
              logMessage(source, "Invalid selector arg: '".concat(selector, "'"));
            }
            foundNodes.forEach(function (n) {
              return nodes.add(n);
            });
          } else if (selectors.length > 0) {
            selectors.forEach(function (s) {
              const elements = document.querySelectorAll(s);
              for (let i = 0; i < elements.length; i += 1) {
                const element = elements[i];
                nodes.add(element);
              }
            });
          }
          let removed = false;
          nodes.forEach(function (node) {
            classNames.forEach(function (className) {
              if (node.classList.contains(className)) {
                node.classList.remove(className);
                removed = true;
              }
            });
          });
          if (removed) {
            hit(source);
          }
        };
        const CLASS_ATTR_NAME = ["class"];
        const flags = parseFlags(applying);
        const run = function run() {
          removeClassHandler();
          if (!flags.hasFlag(flags.STAY)) {
            return;
          }
          observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
        };
        if (flags.hasFlag(flags.ASAP)) {
          if (document.readyState === "loading") {
            window.addEventListener("DOMContentLoaded", removeClassHandler, {
              once: true
            });
          } else {
            removeClassHandler();
          }
        }
        if (document.readyState !== "complete" && flags.hasFlag(flags.COMPLETE)) {
          window.addEventListener("load", run, {
            once: true
          });
        } else if (flags.hasFlag(flags.STAY)) {
          if (!applying.indexOf(" ") !== -1) {
            removeClassHandler();
          }
          observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function observeDOMChanges(callback) {
        let observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        const THROTTLE_DELAY_MS = 20;
        const observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        const connect = function connect() {
          if (attrsToObserve.length > 0) {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs,
              attributeFilter: attrsToObserve
            });
          } else {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs
            });
          }
        };
        const disconnect = function disconnect() {
          observer.disconnect();
        };
        function callbackWrapper() {
          disconnect();
          callback();
          connect();
        }
        connect();
      }
      function parseFlags(flags) {
        const FLAGS_DIVIDER = " ";
        const ASAP_FLAG = "asap";
        const COMPLETE_FLAG = "complete";
        const STAY_FLAG = "stay";
        const VALID_FLAGS = [STAY_FLAG, ASAP_FLAG, COMPLETE_FLAG];
        const passedFlags = flags.trim().split(FLAGS_DIVIDER).filter(function (f) {
          return VALID_FLAGS.indexOf(f) !== -1;
        });
        return {
          ASAP: ASAP_FLAG,
          COMPLETE: COMPLETE_FLAG,
          STAY: STAY_FLAG,
          hasFlag(flag) {
            return passedFlags.indexOf(flag) !== -1;
          }
        };
      }
      function throttle(cb, delay) {
        let wait = false;
        let savedArgs;
        const wrapper = function wrapper() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (wait) {
            savedArgs = args;
            return;
          }
          cb(...args);
          wait = true;
          setTimeout(function () {
            wait = false;
            if (savedArgs) {
              wrapper(...savedArgs);
              savedArgs = null;
            }
          }, delay);
        };
        return wrapper;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        removeClass.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function removeCookie(source, args) {
      function removeCookie(source, match) {
        const matchRegexp = toRegExp(match);
        const removeCookieFromHost = function removeCookieFromHost(cookieName, hostName) {
          const cookieSpec = "".concat(cookieName, "=");
          const domain1 = "; domain=".concat(hostName);
          const domain2 = "; domain=.".concat(hostName);
          const path = "; path=/";
          const expiration = "; expires=Thu, 01 Jan 1970 00:00:00 GMT";
          document.cookie = cookieSpec + expiration;
          document.cookie = cookieSpec + domain1 + expiration;
          document.cookie = cookieSpec + domain2 + expiration;
          document.cookie = cookieSpec + path + expiration;
          document.cookie = cookieSpec + domain1 + path + expiration;
          document.cookie = cookieSpec + domain2 + path + expiration;
          hit(source);
        };
        const rmCookie = function rmCookie() {
          document.cookie.split(";").forEach(function (cookieStr) {
            const pos = cookieStr.indexOf("=");
            if (pos === -1) {
              return;
            }
            const cookieName = cookieStr.slice(0, pos).trim();
            if (!matchRegexp.test(cookieName)) {
              return;
            }
            const hostParts = document.location.hostname.split(".");
            for (let i = 0; i <= hostParts.length - 1; i += 1) {
              const hostName = hostParts.slice(i).join(".");
              if (hostName) {
                removeCookieFromHost(cookieName, hostName);
              }
            }
          });
        };
        rmCookie();
        window.addEventListener("beforeunload", rmCookie);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        removeCookie.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function removeInShadowDom(source, args) {
      function removeInShadowDom(source, selector, baseSelector) {
        if (!Element.prototype.attachShadow) {
          return;
        }
        const removeElement = function removeElement(targetElement) {
          targetElement.remove();
        };
        const removeHandler = function removeHandler() {
          let hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
          while (hostElements.length !== 0) {
            let isRemoved = false;
            const _pierceShadowDom = pierceShadowDom(selector, hostElements),
              targets = _pierceShadowDom.targets,
              innerHosts = _pierceShadowDom.innerHosts;
            targets.forEach(function (targetEl) {
              removeElement(targetEl);
              isRemoved = true;
            });
            if (isRemoved) {
              hit(source);
            }
            hostElements = innerHosts;
          }
        };
        removeHandler();
        observeDOMChanges(removeHandler, true);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function observeDOMChanges(callback) {
        let observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        const THROTTLE_DELAY_MS = 20;
        const observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        const connect = function connect() {
          if (attrsToObserve.length > 0) {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs,
              attributeFilter: attrsToObserve
            });
          } else {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs
            });
          }
        };
        const disconnect = function disconnect() {
          observer.disconnect();
        };
        function callbackWrapper() {
          disconnect();
          callback();
          connect();
        }
        connect();
      }
      function findHostElements(rootElement) {
        const hosts = [];
        const domElems = rootElement.querySelectorAll("*");
        domElems.forEach(function (el) {
          if (el.shadowRoot) {
            hosts.push(el);
          }
        });
        return hosts;
      }
      function pierceShadowDom(selector, hostElements) {
        let targets = [];
        const innerHostsAcc = [];
        hostElements.forEach(function (host) {
          const simpleElems = host.querySelectorAll(selector);
          targets = targets.concat([].slice.call(simpleElems));
          const shadowRootElem = host.shadowRoot;
          const shadowChildren = shadowRootElem.querySelectorAll(selector);
          targets = targets.concat([].slice.call(shadowChildren));
          innerHostsAcc.push(findHostElements(shadowRootElem));
        });
        const innerHosts = flatten(innerHostsAcc);
        return {
          targets: targets,
          innerHosts: innerHosts
        };
      }
      function flatten(input) {
        const stack = [];
        input.forEach(function (el) {
          return stack.push(el);
        });
        const res = [];
        while (stack.length) {
          const next = stack.pop();
          if (Array.isArray(next)) {
            next.forEach(function (el) {
              return stack.push(el);
            });
          } else {
            res.push(next);
          }
        }
        return res.reverse();
      }
      function throttle(cb, delay) {
        let wait = false;
        let savedArgs;
        const wrapper = function wrapper() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (wait) {
            savedArgs = args;
            return;
          }
          cb(...args);
          wait = true;
          setTimeout(function () {
            wait = false;
            if (savedArgs) {
              wrapper(...savedArgs);
              savedArgs = null;
            }
          }, delay);
        };
        return wrapper;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        removeInShadowDom.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function setAttr(source, args) {
      function setAttr(source, selector, attr) {
        let value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        if (!selector || !attr) {
          return;
        }
        const allowedValues = ["true", "false"];
        if (value.length !== 0 && (nativeIsNaN(parseInt(value, 10)) || parseInt(value, 10) < 0 || parseInt(value, 10) > 32767) && !allowedValues.includes(value.toLowerCase())) {
          return;
        }
        const setAttr = function setAttr() {
          const nodes = [].slice.call(document.querySelectorAll(selector));
          let set = false;
          nodes.forEach(function (node) {
            node.setAttribute(attr, value);
            set = true;
          });
          if (set) {
            hit(source);
          }
        };
        setAttr();
        observeDOMChanges(setAttr, true);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function observeDOMChanges(callback) {
        let observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        const THROTTLE_DELAY_MS = 20;
        const observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        const connect = function connect() {
          if (attrsToObserve.length > 0) {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs,
              attributeFilter: attrsToObserve
            });
          } else {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs
            });
          }
        };
        const disconnect = function disconnect() {
          observer.disconnect();
        };
        function callbackWrapper() {
          disconnect();
          callback();
          connect();
        }
        connect();
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function throttle(cb, delay) {
        let wait = false;
        let savedArgs;
        const wrapper = function wrapper() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (wait) {
            savedArgs = args;
            return;
          }
          cb(...args);
          wait = true;
          setTimeout(function () {
            wait = false;
            if (savedArgs) {
              wrapper(...savedArgs);
              savedArgs = null;
            }
          }, delay);
        };
        return wrapper;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        setAttr.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function setConstant(source, args) {
      function setConstant(source, property, value, stack) {
        if (!property || !matchStackTrace(stack, new Error().stack)) {
          return;
        }
        const emptyArr = noopArray();
        const emptyObj = noopObject();
        let constantValue;
        if (value === "undefined") {
          constantValue = undefined;
        } else if (value === "false") {
          constantValue = false;
        } else if (value === "true") {
          constantValue = true;
        } else if (value === "null") {
          constantValue = null;
        } else if (value === "emptyArr") {
          constantValue = emptyArr;
        } else if (value === "emptyObj") {
          constantValue = emptyObj;
        } else if (value === "noopFunc") {
          constantValue = noopFunc;
        } else if (value === "noopCallbackFunc") {
          constantValue = noopCallbackFunc;
        } else if (value === "trueFunc") {
          constantValue = trueFunc;
        } else if (value === "falseFunc") {
          constantValue = falseFunc;
        } else if (value === "throwFunc") {
          constantValue = throwFunc;
        } else if (value === "noopPromiseResolve") {
          constantValue = noopPromiseResolve;
        } else if (value === "noopPromiseReject") {
          constantValue = noopPromiseReject;
        } else if (/^\d+$/.test(value)) {
          constantValue = parseFloat(value);
          if (nativeIsNaN(constantValue)) {
            return;
          }
          if (Math.abs(constantValue) > 32767) {
            return;
          }
        } else if (value === "-1") {
          constantValue = -1;
        } else if (value === "") {
          constantValue = "";
        } else if (value === "yes") {
          constantValue = "yes";
        } else if (value === "no") {
          constantValue = "no";
        } else {
          return;
        }
        let canceled = false;
        const mustCancel = function mustCancel(value) {
          if (canceled) {
            return canceled;
          }
          canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue && value !== null;
          return canceled;
        };
        const trapProp = function trapProp(base, prop, configurable, handler) {
          if (!handler.init(base[prop])) {
            return false;
          }
          const origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
          let prevSetter;
          if (origDescriptor instanceof Object) {
            if (!origDescriptor.configurable) {
              const message = "Property '".concat(prop, "' is not configurable");
              logMessage(source, message);
              return false;
            }
            base[prop] = constantValue;
            if (origDescriptor.set instanceof Function) {
              prevSetter = origDescriptor.set;
            }
          }
          Object.defineProperty(base, prop, {
            configurable: configurable,
            get() {
              return handler.get();
            },
            set(a) {
              if (prevSetter !== undefined) {
                prevSetter(a);
              }
              handler.set(a);
            }
          });
          return true;
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          const base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          const inChainPropHandler = {
            factValue: undefined,
            init(a) {
              this.factValue = a;
              return true;
            },
            get() {
              return this.factValue;
            },
            set(a) {
              if (this.factValue === a) {
                return;
              }
              this.factValue = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            }
          };
          const endPropHandler = {
            init(a) {
              if (mustCancel(a)) {
                return false;
              }
              return true;
            },
            get() {
              return constantValue;
            },
            set(a) {
              if (!mustCancel(a)) {
                return;
              }
              constantValue = a;
            }
          };
          if (!chain) {
            const isTrapped = trapProp(base, prop, false, endPropHandler);
            if (isTrapped) {
              hit(source);
            }
            return;
          }
          if (base !== undefined && base[prop] === null) {
            trapProp(base, prop, true, inChainPropHandler);
            return;
          }
          if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            trapProp(base, prop, true, inChainPropHandler);
          }
          const propValue = owner[prop];
          if (propValue instanceof Object || typeof propValue === "object" && propValue !== null) {
            setChainPropAccess(propValue, chain);
          }
          trapProp(base, prop, true, inChainPropHandler);
        };
        setChainPropAccess(window, property);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function noopArray() {
        return [];
      }
      function noopObject() {
        return {};
      }
      function noopFunc() {}
      function noopCallbackFunc() {
        return noopFunc;
      }
      function trueFunc() {
        return true;
      }
      function falseFunc() {
        return false;
      }
      function throwFunc() {
        throw new Error();
      }
      function noopPromiseReject() {
        return Promise.reject();
      }
      function noopPromiseResolve() {
        let responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "{}";
        let responseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        let responseType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "default";
        if (typeof Response === "undefined") {
          return;
        }
        const response = new Response(responseBody, {
          status: 200,
          statusText: "OK"
        });
        Object.defineProperties(response, {
          url: {
            value: responseUrl
          },
          type: {
            value: responseType
          }
        });
        return Promise.resolve(response);
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
          return true;
        }
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
          return true;
        }
        const stackRegexp = toRegExp(stackMatch);
        const refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        }).join("\n");
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getNativeRegexpTest() {
        return Object.getOwnPropertyDescriptor(RegExp.prototype, "test").value;
      }
      function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        const INLINE_SCRIPT_STRING = "inlineScript";
        const INJECTED_SCRIPT_STRING = "injectedScript";
        const INJECTED_SCRIPT_MARKER = "<anonymous>";
        const isInlineScript = function isInlineScript(stackMatch) {
          return stackMatch.indexOf(INLINE_SCRIPT_STRING) > -1;
        };
        const isInjectedScript = function isInjectedScript(stackMatch) {
          return stackMatch.indexOf(INJECTED_SCRIPT_STRING) > -1;
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
          return false;
        }
        let documentURL = window.location.href;
        const pos = documentURL.indexOf("#");
        if (pos !== -1) {
          documentURL = documentURL.slice(0, pos);
        }
        const stackSteps = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        });
        const stackLines = stackSteps.map(function (line) {
          let stack;
          const getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
          if (getStackTraceURL) {
            let stackURL = getStackTraceURL[2];
            if (startsWith(stackURL, "(")) {
              stackURL = stackURL.slice(1);
            }
            if (startsWith(stackURL, INJECTED_SCRIPT_MARKER)) {
              stackURL = INJECTED_SCRIPT_STRING;
              let stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
              if (startsWith(stackFunction, "at")) {
                stackFunction = stackFunction.slice(2).trim();
              }
              stack = "".concat(stackFunction, " ").concat(stackURL).trim();
            } else {
              stack = stackURL;
            }
          } else {
            stack = line;
          }
          return stack;
        });
        if (stackLines) {
          for (let index = 0; index < stackLines.length; index += 1) {
            if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
              return true;
            }
            if (isInjectedScript(stackMatch) && startsWith(stackLines[index], INJECTED_SCRIPT_STRING)) {
              return true;
            }
          }
        }
        return false;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        setConstant.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function setCookie(source, args) {
      function setCookie(source, name, value) {
        let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "/";
        const validValue = getLimitedCookieValue(value);
        if (validValue === null) {
          logMessage(source, "Invalid cookie value: '".concat(validValue, "'"));
          return;
        }
        if (!isValidCookiePath(path)) {
          logMessage(source, "Invalid cookie path: '".concat(path, "'"));
          return;
        }
        const cookieToSet = concatCookieNameValuePath(name, validValue, path);
        if (!cookieToSet) {
          return;
        }
        hit(source);
        document.cookie = cookieToSet;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function getLimitedCookieValue(value) {
        if (!value) {
          return null;
        }
        let validValue;
        if (value === "true") {
          validValue = "true";
        } else if (value === "True") {
          validValue = "True";
        } else if (value === "false") {
          validValue = "false";
        } else if (value === "False") {
          validValue = "False";
        } else if (value === "yes") {
          validValue = "yes";
        } else if (value === "Yes") {
          validValue = "Yes";
        } else if (value === "Y") {
          validValue = "Y";
        } else if (value === "no") {
          validValue = "no";
        } else if (value === "ok") {
          validValue = "ok";
        } else if (value === "OK") {
          validValue = "OK";
        } else if (/^\d+$/.test(value)) {
          validValue = parseFloat(value);
          if (nativeIsNaN(validValue)) {
            return null;
          }
          if (Math.abs(validValue) < 0 || Math.abs(validValue) > 15) {
            return null;
          }
        } else {
          return null;
        }
        return validValue;
      }
      function concatCookieNameValuePath(rawName, rawValue, rawPath) {
        return "".concat(encodeURIComponent(rawName), "=").concat(encodeURIComponent(rawValue), "; ").concat(getCookiePath(rawPath), ";");
      }
      function isValidCookiePath(rawPath) {
        return rawPath === "/" || rawPath === "none";
      }
      function getCookiePath(rawPath) {
        if (rawPath === "/") {
          return "path=/";
        }
        return "";
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        setCookie.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function setCookieReload(source, args) {
      function setCookieReload(source, name, value) {
        let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "/";
        if (isCookieSetWithValue(document.cookie, name, value)) {
          return;
        }
        const validValue = getLimitedCookieValue(value);
        if (validValue === null) {
          logMessage(source, "Invalid cookie value: '".concat(value, "'"));
          return;
        }
        if (!isValidCookiePath(path)) {
          logMessage(source, "Invalid cookie path: '".concat(path, "'"));
          return;
        }
        const cookieToSet = concatCookieNameValuePath(name, validValue, path);
        if (!cookieToSet) {
          return;
        }
        document.cookie = cookieToSet;
        hit(source);
        if (isCookieSetWithValue(document.cookie, name, value)) {
          window.location.reload();
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function isCookieSetWithValue(cookieString, name, value) {
        return cookieString.split(";").some(function (cookieStr) {
          const pos = cookieStr.indexOf("=");
          if (pos === -1) {
            return false;
          }
          const cookieName = cookieStr.slice(0, pos).trim();
          const cookieValue = cookieStr.slice(pos + 1).trim();
          return name === cookieName && value === cookieValue;
        });
      }
      function getLimitedCookieValue(value) {
        if (!value) {
          return null;
        }
        let validValue;
        if (value === "true") {
          validValue = "true";
        } else if (value === "True") {
          validValue = "True";
        } else if (value === "false") {
          validValue = "false";
        } else if (value === "False") {
          validValue = "False";
        } else if (value === "yes") {
          validValue = "yes";
        } else if (value === "Yes") {
          validValue = "Yes";
        } else if (value === "Y") {
          validValue = "Y";
        } else if (value === "no") {
          validValue = "no";
        } else if (value === "ok") {
          validValue = "ok";
        } else if (value === "OK") {
          validValue = "OK";
        } else if (/^\d+$/.test(value)) {
          validValue = parseFloat(value);
          if (nativeIsNaN(validValue)) {
            return null;
          }
          if (Math.abs(validValue) < 0 || Math.abs(validValue) > 15) {
            return null;
          }
        } else {
          return null;
        }
        return validValue;
      }
      function concatCookieNameValuePath(rawName, rawValue, rawPath) {
        return "".concat(encodeURIComponent(rawName), "=").concat(encodeURIComponent(rawValue), "; ").concat(getCookiePath(rawPath), ";");
      }
      function isValidCookiePath(rawPath) {
        return rawPath === "/" || rawPath === "none";
      }
      function getCookiePath(rawPath) {
        if (rawPath === "/") {
          return "path=/";
        }
        return "";
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        setCookieReload.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function setLocalStorageItem(source, args) {
      function setLocalStorageItem(source, key, value) {
        if (typeof key === "undefined") {
          logMessage(source, "Item key should be specified.");
          return;
        }
        let validValue;
        try {
          validValue = getLimitedStorageItemValue(value);
        } catch (_unused) {
          logMessage(source, "Invalid storage item value: '".concat(value, "'"));
          return;
        }
        const _window = window,
          localStorage = _window.localStorage;
        setStorageItem(source, localStorage, key, validValue);
        hit(source);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function setStorageItem(source, storage, key, value) {
        try {
          storage.setItem(key, value);
        } catch (e) {
          const message = "Unable to set sessionStorage item due to: ".concat(e.message);
          logMessage(source, message);
        }
      }
      function getLimitedStorageItemValue(value) {
        if (typeof value !== "string") {
          throw new Error("Invalid value");
        }
        let validValue;
        if (value === "undefined") {
          validValue = undefined;
        } else if (value === "false") {
          validValue = false;
        } else if (value === "true") {
          validValue = true;
        } else if (value === "null") {
          validValue = null;
        } else if (value === "emptyArr") {
          validValue = "[]";
        } else if (value === "emptyObj") {
          validValue = "{}";
        } else if (value === "") {
          validValue = "";
        } else if (/^\d+$/.test(value)) {
          validValue = parseFloat(value);
          if (nativeIsNaN(validValue)) {
            throw new Error("Invalid value");
          }
          if (Math.abs(validValue) > 32767) {
            throw new Error("Invalid value");
          }
        } else if (value === "yes") {
          validValue = "yes";
        } else if (value === "no") {
          validValue = "no";
        } else {
          throw new Error("Invalid value");
        }
        return validValue;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        setLocalStorageItem.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function setPopadsDummy(source, args) {
      function setPopadsDummy(source) {
        delete window.PopAds;
        delete window.popns;
        Object.defineProperties(window, {
          PopAds: {
            get: function get() {
              hit(source);
              return {};
            }
          },
          popns: {
            get: function get() {
              hit(source);
              return {};
            }
          }
        });
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        setPopadsDummy.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function setSessionStorageItem(source, args) {
      function setSessionStorageItem(source, key, value) {
        if (typeof key === "undefined") {
          logMessage(source, "Item key should be specified.");
          return;
        }
        let validValue;
        try {
          validValue = getLimitedStorageItemValue(value);
        } catch (_unused) {
          logMessage(source, "Invalid storage item value: '".concat(value, "'"));
          return;
        }
        const _window = window,
          sessionStorage = _window.sessionStorage;
        setStorageItem(source, sessionStorage, key, validValue);
        hit(source);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function setStorageItem(source, storage, key, value) {
        try {
          storage.setItem(key, value);
        } catch (e) {
          const message = "Unable to set sessionStorage item due to: ".concat(e.message);
          logMessage(source, message);
        }
      }
      function getLimitedStorageItemValue(value) {
        if (typeof value !== "string") {
          throw new Error("Invalid value");
        }
        let validValue;
        if (value === "undefined") {
          validValue = undefined;
        } else if (value === "false") {
          validValue = false;
        } else if (value === "true") {
          validValue = true;
        } else if (value === "null") {
          validValue = null;
        } else if (value === "emptyArr") {
          validValue = "[]";
        } else if (value === "emptyObj") {
          validValue = "{}";
        } else if (value === "") {
          validValue = "";
        } else if (/^\d+$/.test(value)) {
          validValue = parseFloat(value);
          if (nativeIsNaN(validValue)) {
            throw new Error("Invalid value");
          }
          if (Math.abs(validValue) > 32767) {
            throw new Error("Invalid value");
          }
        } else if (value === "yes") {
          validValue = "yes";
        } else if (value === "no") {
          validValue = "no";
        } else {
          throw new Error("Invalid value");
        }
        return validValue;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        setSessionStorageItem.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function trustedClickElement(source, args) {
      function trustedClickElement(source, selectors) {
        let extraMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        let delay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NaN;
        if (!selectors) {
          return;
        }
        const OBSERVER_TIMEOUT_MS = 1e4;
        const THROTTLE_DELAY_MS = 20;
        const STATIC_CLICK_DELAY_MS = 150;
        const COOKIE_MATCH_MARKER = "cookie:";
        const LOCAL_STORAGE_MATCH_MARKER = "localStorage:";
        const SELECTORS_DELIMITER = ",";
        const COOKIE_STRING_DELIMITER = ";";
        const EXTRA_MATCH_DELIMITER = /(,\s*){1}(?=!?cookie:|!?localStorage:)/;
        const sleep = function sleep(delayMs) {
          return new Promise(function (resolve) {
            return setTimeout(resolve, delayMs);
          });
        };
        let parsedDelay;
        if (delay) {
          parsedDelay = parseInt(delay, 10);
          const isValidDelay = !Number.isNaN(parsedDelay) || parsedDelay < OBSERVER_TIMEOUT_MS;
          if (!isValidDelay) {
            const message = "Passed delay '".concat(delay, "' is invalid or bigger than ").concat(OBSERVER_TIMEOUT_MS, " ms");
            logMessage(source, message);
            return;
          }
        }
        let canClick = !parsedDelay;
        const cookieMatches = [];
        const localStorageMatches = [];
        let isInvertedMatchCookie = false;
        let isInvertedMatchLocalStorage = false;
        if (extraMatch) {
          const parsedExtraMatch = extraMatch.split(EXTRA_MATCH_DELIMITER).map(function (matchStr) {
            return matchStr.trim();
          });
          parsedExtraMatch.forEach(function (matchStr) {
            if (matchStr.indexOf(COOKIE_MATCH_MARKER) > -1) {
              const _parseMatchArg = parseMatchArg(matchStr),
                isInvertedMatch = _parseMatchArg.isInvertedMatch,
                matchValue = _parseMatchArg.matchValue;
              isInvertedMatchCookie = isInvertedMatch;
              const cookieMatch = matchValue.replace(COOKIE_MATCH_MARKER, "");
              cookieMatches.push(cookieMatch);
            }
            if (matchStr.indexOf(LOCAL_STORAGE_MATCH_MARKER) > -1) {
              const _parseMatchArg2 = parseMatchArg(matchStr),
                isInvertedMatch = _parseMatchArg2.isInvertedMatch,
                matchValue = _parseMatchArg2.matchValue;
              isInvertedMatchLocalStorage = isInvertedMatch;
              const localStorageMatch = matchValue.replace(LOCAL_STORAGE_MATCH_MARKER, "");
              localStorageMatches.push(localStorageMatch);
            }
          });
        }
        if (cookieMatches.length > 0) {
          const parsedCookieMatches = parseCookieString(cookieMatches.join(COOKIE_STRING_DELIMITER));
          const parsedCookies = parseCookieString(document.cookie);
          const cookieKeys = Object.keys(parsedCookies);
          if (cookieKeys.length === 0) {
            return;
          }
          const cookiesMatched = Object.keys(parsedCookieMatches).every(function (key) {
            const valueMatch = parsedCookieMatches[key] ? toRegExp(parsedCookieMatches[key]) : null;
            const keyMatch = toRegExp(key);
            return cookieKeys.some(function (key) {
              const keysMatched = keyMatch.test(key);
              if (!keysMatched) {
                return false;
              }
              if (!valueMatch) {
                return true;
              }
              return valueMatch.test(parsedCookies[key]);
            });
          });
          const shouldRun = cookiesMatched !== isInvertedMatchCookie;
          if (!shouldRun) {
            return;
          }
        }
        if (localStorageMatches.length > 0) {
          const localStorageMatched = localStorageMatches.every(function (str) {
            const itemValue = window.localStorage.getItem(str);
            return itemValue || itemValue === "";
          });
          const shouldRun = localStorageMatched !== isInvertedMatchLocalStorage;
          if (!shouldRun) {
            return;
          }
        }
        let selectorsSequence = selectors.split(SELECTORS_DELIMITER).map(function (selector) {
          return selector.trim();
        });
        const createElementObj = function createElementObj(element) {
          return {
            element: element || null,
            clicked: false
          };
        };
        const elementsSequence = Array(selectorsSequence.length).fill(createElementObj());
        const clickElementsBySequence = async function clickElementsBySequence() {
          for (let i = 0; i < elementsSequence.length; i += 1) {
            const elementObj = elementsSequence[i];
            if (i >= 1) {
              await sleep(STATIC_CLICK_DELAY_MS);
            }
            if (!elementObj.element) {
              break;
            }
            if (!elementObj.clicked) {
              elementObj.element.click();
              elementObj.clicked = true;
            }
          }
          const allElementsClicked = elementsSequence.every(function (elementObj) {
            return elementObj.clicked === true;
          });
          if (allElementsClicked) {
            hit(source);
          }
        };
        const handleElement = function handleElement(element, i) {
          const elementObj = createElementObj(element);
          elementsSequence[i] = elementObj;
          if (canClick) {
            clickElementsBySequence();
          }
        };
        const findElements = function findElements(mutations, observer) {
          const fulfilledSelectors = [];
          selectorsSequence.forEach(function (selector, i) {
            if (!selector) {
              return;
            }
            const element = document.querySelector(selector);
            if (!element) {
              return;
            }
            handleElement(element, i);
            fulfilledSelectors.push(selector);
          });
          selectorsSequence = selectorsSequence.map(function (selector) {
            return fulfilledSelectors.indexOf(selector) === -1 ? selector : null;
          });
          const allSelectorsFulfilled = selectorsSequence.every(function (selector) {
            return selector === null;
          });
          if (allSelectorsFulfilled) {
            observer.disconnect();
          }
        };
        const observer = new MutationObserver(throttle(findElements, THROTTLE_DELAY_MS));
        observer.observe(document.documentElement, {
          attributes: true,
          childList: true,
          subtree: true
        });
        if (parsedDelay) {
          setTimeout(function () {
            clickElementsBySequence();
            canClick = true;
          }, parsedDelay);
        }
        setTimeout(function () {
          return observer.disconnect();
        }, OBSERVER_TIMEOUT_MS);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function parseCookieString(cookieString) {
        const COOKIE_DELIMITER = "=";
        const COOKIE_PAIRS_DELIMITER = ";";
        const cookieChunks = cookieString.split(COOKIE_PAIRS_DELIMITER);
        const cookieData = {};
        cookieChunks.forEach(function (singleCookie) {
          let cookieKey;
          let cookieValue;
          const delimiterIndex = singleCookie.indexOf(COOKIE_DELIMITER);
          if (delimiterIndex === -1) {
            cookieKey = singleCookie.trim();
          } else {
            cookieKey = singleCookie.slice(0, delimiterIndex).trim();
            cookieValue = singleCookie.slice(delimiterIndex + 1);
          }
          cookieData[cookieKey] = cookieValue || null;
        });
        return cookieData;
      }
      function throttle(cb, delay) {
        let wait = false;
        let savedArgs;
        const wrapper = function wrapper() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (wait) {
            savedArgs = args;
            return;
          }
          cb(...args);
          wait = true;
          setTimeout(function () {
            wait = false;
            if (savedArgs) {
              wrapper(...savedArgs);
              savedArgs = null;
            }
          }, delay);
        };
        return wrapper;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function parseMatchArg(match) {
        const INVERT_MARKER = "!";
        const isInvertedMatch = match ? match.startsWith(INVERT_MARKER) : false;
        const matchValue = isInvertedMatch ? match.slice(1) : match;
        const matchRegexp = toRegExp(matchValue);
        return {
          isInvertedMatch: isInvertedMatch,
          matchRegexp: matchRegexp,
          matchValue: matchValue
        };
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        trustedClickElement.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function trustedReplaceFetchResponse(source, args) {
      function trustedReplaceFetchResponse(source) {
        let pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        let replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        let propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        if (typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
          return;
        }
        if (pattern === "" && replacement !== "") {
          logMessage(source, "Pattern argument should not be empty string");
          return;
        }
        const shouldLog = pattern === "" && replacement === "";
        const nativeFetch = fetch;
        let shouldReplace = false;
        let fetchData;
        const handlerWrapper = function handlerWrapper(target, thisArg, args) {
          fetchData = getFetchData(args);
          if (shouldLog) {
            logMessage(source, "fetch( ".concat(objectToString(fetchData), " )"), true);
            hit(source);
            return Reflect.apply(target, thisArg, args);
          }
          shouldReplace = matchRequestProps(source, propsToMatch, fetchData);
          if (!shouldReplace) {
            return Reflect.apply(target, thisArg, args);
          }
          const forgeResponse = function forgeResponse(response, textContent) {
            const bodyUsed = response.bodyUsed,
              headers = response.headers,
              ok = response.ok,
              redirected = response.redirected,
              status = response.status,
              statusText = response.statusText,
              type = response.type,
              url = response.url;
            const forgedResponse = new Response(textContent, {
              status: status,
              statusText: statusText,
              headers: headers
            });
            Object.defineProperties(forgedResponse, {
              url: {
                value: url
              },
              type: {
                value: type
              },
              ok: {
                value: ok
              },
              bodyUsed: {
                value: bodyUsed
              },
              redirected: {
                value: redirected
              }
            });
            return forgedResponse;
          };
          return nativeFetch.apply(null, args).then(function (response) {
            return response.text().then(function (bodyText) {
              const patternRegexp = pattern === "*" ? /(\n|.)*/ : toRegExp(pattern);
              const modifiedTextContent = bodyText.replace(patternRegexp, replacement);
              const forgedResponse = forgeResponse(response, modifiedTextContent);
              hit(source);
              return forgedResponse;
            }).catch(function () {
              const fetchDataStr = objectToString(fetchData);
              const message = "Response body can't be converted to text: ".concat(fetchDataStr);
              logMessage(source, message);
              return Reflect.apply(target, thisArg, args);
            });
          }).catch(function () {
            return Reflect.apply(target, thisArg, args);
          });
        };
        const fetchHandler = {
          apply: handlerWrapper
        };
        fetch = new Proxy(fetch, fetchHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function getFetchData(args) {
        const fetchPropsObj = {};
        let fetchUrl;
        let fetchInit;
        if (args[0] instanceof Request) {
          const requestData = getRequestData(args[0]);
          fetchUrl = requestData.url;
          fetchInit = requestData;
        } else {
          fetchUrl = args[0];
          fetchInit = args[1];
        }
        fetchPropsObj.url = fetchUrl;
        if (fetchInit instanceof Object) {
          Object.keys(fetchInit).forEach(function (prop) {
            fetchPropsObj[prop] = fetchInit[prop];
          });
        }
        return fetchPropsObj;
      }
      function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
          return String(obj);
        }
        return isEmptyObject(obj) ? "{}" : getObjectEntries(obj).map(function (pair) {
          const key = pair[0];
          const value = pair[1];
          let recordValueStr = value;
          if (value instanceof Object) {
            recordValueStr = "{ ".concat(objectToString(value), " }");
          }
          return "".concat(key, ':"').concat(recordValueStr, '"');
        }).join(" ");
      }
      function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
          return true;
        }
        let isMatched;
        const parsedData = parseMatchProps(propsToMatch);
        if (!validateParsedData(parsedData)) {
          logMessage(source, "Invalid parameter: ".concat(propsToMatch));
          isMatched = false;
        } else {
          const matchData = getMatchPropsData(parsedData);
          isMatched = Object.keys(matchData).every(function (matchKey) {
            const matchValue = matchData[matchKey];
            return Object.prototype.hasOwnProperty.call(requestData, matchKey) && matchValue.test(requestData[matchKey]);
          });
        }
        return isMatched;
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getRequestData(request) {
        const requestInitOptions = getRequestProps();
        const entries = requestInitOptions.map(function (key) {
          const value = request[key];
          return [key, value];
        });
        return getObjectFromEntries(entries);
      }
      function getRequestProps() {
        return ["url", "method", "headers", "body", "mode", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal"];
      }
      function getObjectEntries(object) {
        const keys = Object.keys(object);
        const entries = [];
        keys.forEach(function (key) {
          return entries.push([key, object[key]]);
        });
        return entries;
      }
      function getObjectFromEntries(entries) {
        const output = entries.reduce(function (acc, el) {
          const key = el[0];
          const value = el[1];
          acc[key] = value;
          return acc;
        }, {});
        return output;
      }
      function parseMatchProps(propsToMatchStr) {
        const PROPS_DIVIDER = " ";
        const PAIRS_MARKER = ":";
        const LEGAL_MATCH_PROPS = getRequestProps();
        const propsObj = {};
        const props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach(function (prop) {
          const dividerInd = prop.indexOf(PAIRS_MARKER);
          const key = prop.slice(0, dividerInd);
          const hasLegalMatchProp = LEGAL_MATCH_PROPS.indexOf(key) !== -1;
          if (hasLegalMatchProp) {
            const value = prop.slice(dividerInd + 1);
            propsObj[key] = value;
          } else {
            propsObj.url = prop;
          }
        });
        return propsObj;
      }
      function validateParsedData(data) {
        return Object.values(data).every(function (value) {
          return isValidStrPattern(value);
        });
      }
      function getMatchPropsData(data) {
        const matchData = {};
        Object.keys(data).forEach(function (key) {
          matchData[key] = toRegExp(data[key]);
        });
        return matchData;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        trustedReplaceFetchResponse.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function trustedReplaceXhrResponse(source, args) {
      function trustedReplaceXhrResponse(source) {
        let pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        let replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        let propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        if (typeof Proxy === "undefined") {
          return;
        }
        if (pattern === "" && replacement !== "") {
          const message = "Pattern argument should not be empty string.";
          logMessage(source, message);
          return;
        }
        const shouldLog = pattern === "" && replacement === "";
        const nativeOpen = window.XMLHttpRequest.prototype.open;
        const nativeSend = window.XMLHttpRequest.prototype.send;
        let xhrData;
        const openWrapper = function openWrapper(target, thisArg, args) {
          xhrData = getXhrData.apply(null, args);
          if (shouldLog) {
            const message = "xhr( ".concat(objectToString(xhrData), " )");
            logMessage(source, message, true);
            hit(source);
            return Reflect.apply(target, thisArg, args);
          }
          if (matchRequestProps(source, propsToMatch, xhrData)) {
            thisArg.shouldBePrevented = true;
          }
          if (thisArg.shouldBePrevented) {
            thisArg.collectedHeaders = [];
            const setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
              thisArg.collectedHeaders.push(args);
              return Reflect.apply(target, thisArg, args);
            };
            const setRequestHeaderHandler = {
              apply: setRequestHeaderWrapper
            };
            thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
          }
          return Reflect.apply(target, thisArg, args);
        };
        const sendWrapper = function sendWrapper(target, thisArg, args) {
          if (!thisArg.shouldBePrevented) {
            return Reflect.apply(target, thisArg, args);
          }
          const forgedRequest = new XMLHttpRequest();
          forgedRequest.addEventListener("readystatechange", function () {
            if (forgedRequest.readyState !== 4) {
              return;
            }
            const readyState = forgedRequest.readyState,
              response = forgedRequest.response,
              responseText = forgedRequest.responseText,
              responseURL = forgedRequest.responseURL,
              responseXML = forgedRequest.responseXML,
              status = forgedRequest.status,
              statusText = forgedRequest.statusText;
            const content = responseText || response;
            if (typeof content !== "string") {
              return;
            }
            const patternRegexp = pattern === "*" ? /(\n|.)*/ : toRegExp(pattern);
            const modifiedContent = content.replace(patternRegexp, replacement);
            Object.defineProperties(thisArg, {
              readyState: {
                value: readyState
              },
              response: {
                value: modifiedContent
              },
              responseText: {
                value: modifiedContent
              },
              responseURL: {
                value: responseURL
              },
              responseXML: {
                value: responseXML
              },
              status: {
                value: status
              },
              statusText: {
                value: statusText
              }
            });
            setTimeout(function () {
              const stateEvent = new Event("readystatechange");
              thisArg.dispatchEvent(stateEvent);
              const loadEvent = new Event("load");
              thisArg.dispatchEvent(loadEvent);
              const loadEndEvent = new Event("loadend");
              thisArg.dispatchEvent(loadEndEvent);
            }, 1);
            hit(source);
          });
          nativeOpen.apply(forgedRequest, [xhrData.method, xhrData.url]);
          thisArg.collectedHeaders.forEach(function (header) {
            const name = header[0];
            const value = header[1];
            forgedRequest.setRequestHeader(name, value);
          });
          thisArg.collectedHeaders = [];
          try {
            nativeSend.call(forgedRequest, args);
          } catch (_unused) {
            return Reflect.apply(target, thisArg, args);
          }
          return undefined;
        };
        const openHandler = {
          apply: openWrapper
        };
        const sendHandler = {
          apply: sendWrapper
        };
        XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
        XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
          return String(obj);
        }
        return isEmptyObject(obj) ? "{}" : getObjectEntries(obj).map(function (pair) {
          const key = pair[0];
          const value = pair[1];
          let recordValueStr = value;
          if (value instanceof Object) {
            recordValueStr = "{ ".concat(objectToString(value), " }");
          }
          return "".concat(key, ':"').concat(recordValueStr, '"');
        }).join(" ");
      }
      function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
          return true;
        }
        let isMatched;
        const parsedData = parseMatchProps(propsToMatch);
        if (!validateParsedData(parsedData)) {
          logMessage(source, "Invalid parameter: ".concat(propsToMatch));
          isMatched = false;
        } else {
          const matchData = getMatchPropsData(parsedData);
          isMatched = Object.keys(matchData).every(function (matchKey) {
            const matchValue = matchData[matchKey];
            return Object.prototype.hasOwnProperty.call(requestData, matchKey) && matchValue.test(requestData[matchKey]);
          });
        }
        return isMatched;
      }
      function getXhrData(method, url, async, user, password) {
        return {
          method: method,
          url: url,
          async: async,
          user: user,
          password: password
        };
      }
      function getMatchPropsData(data) {
        const matchData = {};
        Object.keys(data).forEach(function (key) {
          matchData[key] = toRegExp(data[key]);
        });
        return matchData;
      }
      function getRequestProps() {
        return ["url", "method", "headers", "body", "mode", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal"];
      }
      function validateParsedData(data) {
        return Object.values(data).every(function (value) {
          return isValidStrPattern(value);
        });
      }
      function parseMatchProps(propsToMatchStr) {
        const PROPS_DIVIDER = " ";
        const PAIRS_MARKER = ":";
        const LEGAL_MATCH_PROPS = getRequestProps();
        const propsObj = {};
        const props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach(function (prop) {
          const dividerInd = prop.indexOf(PAIRS_MARKER);
          const key = prop.slice(0, dividerInd);
          const hasLegalMatchProp = LEGAL_MATCH_PROPS.indexOf(key) !== -1;
          if (hasLegalMatchProp) {
            const value = prop.slice(dividerInd + 1);
            propsObj[key] = value;
          } else {
            propsObj.url = prop;
          }
        });
        return propsObj;
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getObjectEntries(object) {
        const keys = Object.keys(object);
        const entries = [];
        keys.forEach(function (key) {
          return entries.push([key, object[key]]);
        });
        return entries;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        trustedReplaceXhrResponse.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function trustedSetConstant(source, args) {
      function trustedSetConstant(source, property, value, stack) {
        if (!property || !matchStackTrace(stack, new Error().stack)) {
          return;
        }
        let constantValue;
        try {
          constantValue = inferValue(value);
        } catch (e) {
          logMessage(source, e);
          return;
        }
        let canceled = false;
        const mustCancel = function mustCancel(value) {
          if (canceled) {
            return canceled;
          }
          canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue && value !== null;
          return canceled;
        };
        const trapProp = function trapProp(base, prop, configurable, handler) {
          if (!handler.init(base[prop])) {
            return false;
          }
          const origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
          let prevSetter;
          if (origDescriptor instanceof Object) {
            if (!origDescriptor.configurable) {
              const message = "Property '".concat(prop, "' is not configurable");
              logMessage(source, message);
              return false;
            }
            base[prop] = constantValue;
            if (origDescriptor.set instanceof Function) {
              prevSetter = origDescriptor.set;
            }
          }
          Object.defineProperty(base, prop, {
            configurable: configurable,
            get() {
              return handler.get();
            },
            set(a) {
              if (prevSetter !== undefined) {
                prevSetter(a);
              }
              handler.set(a);
            }
          });
          return true;
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          const base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          const inChainPropHandler = {
            factValue: undefined,
            init(a) {
              this.factValue = a;
              return true;
            },
            get() {
              return this.factValue;
            },
            set(a) {
              if (this.factValue === a) {
                return;
              }
              this.factValue = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            }
          };
          const endPropHandler = {
            init(a) {
              if (mustCancel(a)) {
                return false;
              }
              return true;
            },
            get() {
              return constantValue;
            },
            set(a) {
              if (!mustCancel(a)) {
                return;
              }
              constantValue = a;
            }
          };
          if (!chain) {
            const isTrapped = trapProp(base, prop, false, endPropHandler);
            if (isTrapped) {
              hit(source);
            }
            return;
          }
          if (base !== undefined && base[prop] === null) {
            trapProp(base, prop, true, inChainPropHandler);
            return;
          }
          if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            trapProp(base, prop, true, inChainPropHandler);
          }
          const propValue = owner[prop];
          if (propValue instanceof Object || typeof propValue === "object" && propValue !== null) {
            setChainPropAccess(propValue, chain);
          }
          trapProp(base, prop, true, inChainPropHandler);
        };
        setChainPropAccess(window, property);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function inferValue(value) {
        if (value === "undefined") {
          return undefined;
        }
        if (value === "false") {
          return false;
        }
        if (value === "true") {
          return true;
        }
        if (value === "null") {
          return null;
        }
        if (value === "NaN") {
          return NaN;
        }
        const MAX_ALLOWED_NUM = 32767;
        const numVal = Number(value);
        if (!nativeIsNaN(numVal)) {
          if (Math.abs(numVal) > MAX_ALLOWED_NUM) {
            throw new Error("number values bigger than 32767 are not allowed");
          }
          return numVal;
        }
        let errorMessage = "'".concat(value, "' value type can't be inferred");
        try {
          const parsableVal = JSON.parse(value);
          if (parsableVal instanceof Object || typeof parsableVal === "string") {
            return parsableVal;
          }
        } catch (e) {
          errorMessage += ": ".concat(e);
        }
        throw new TypeError(errorMessage);
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
          return true;
        }
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
          return true;
        }
        const stackRegexp = toRegExp(stackMatch);
        const refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        }).join("\n");
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getNativeRegexpTest() {
        return Object.getOwnPropertyDescriptor(RegExp.prototype, "test").value;
      }
      function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        const INLINE_SCRIPT_STRING = "inlineScript";
        const INJECTED_SCRIPT_STRING = "injectedScript";
        const INJECTED_SCRIPT_MARKER = "<anonymous>";
        const isInlineScript = function isInlineScript(stackMatch) {
          return stackMatch.indexOf(INLINE_SCRIPT_STRING) > -1;
        };
        const isInjectedScript = function isInjectedScript(stackMatch) {
          return stackMatch.indexOf(INJECTED_SCRIPT_STRING) > -1;
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
          return false;
        }
        let documentURL = window.location.href;
        const pos = documentURL.indexOf("#");
        if (pos !== -1) {
          documentURL = documentURL.slice(0, pos);
        }
        const stackSteps = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        });
        const stackLines = stackSteps.map(function (line) {
          let stack;
          const getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
          if (getStackTraceURL) {
            let stackURL = getStackTraceURL[2];
            if (startsWith(stackURL, "(")) {
              stackURL = stackURL.slice(1);
            }
            if (startsWith(stackURL, INJECTED_SCRIPT_MARKER)) {
              stackURL = INJECTED_SCRIPT_STRING;
              let stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
              if (startsWith(stackFunction, "at")) {
                stackFunction = stackFunction.slice(2).trim();
              }
              stack = "".concat(stackFunction, " ").concat(stackURL).trim();
            } else {
              stack = stackURL;
            }
          } else {
            stack = line;
          }
          return stack;
        });
        if (stackLines) {
          for (let index = 0; index < stackLines.length; index += 1) {
            if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
              return true;
            }
            if (isInjectedScript(stackMatch) && startsWith(stackLines[index], INJECTED_SCRIPT_STRING)) {
              return true;
            }
          }
        }
        return false;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        trustedSetConstant.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function trustedSetCookie(source, args) {
      function trustedSetCookie(source, name, value) {
        let offsetExpiresSec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        let path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "/";
        if (typeof name === "undefined") {
          logMessage(source, "Cookie name should be specified");
          return;
        }
        if (typeof value === "undefined") {
          logMessage(source, "Cookie value should be specified");
          return;
        }
        const parsedValue = parseKeywordValue(value);
        if (!isValidCookiePath(path)) {
          logMessage(source, "Invalid cookie path: '".concat(path, "'"));
          return;
        }
        let cookieToSet = concatCookieNameValuePath(name, parsedValue, path);
        if (!cookieToSet) {
          return;
        }
        if (offsetExpiresSec) {
          const parsedOffsetMs = getTrustedCookieOffsetMs(offsetExpiresSec);
          if (!parsedOffsetMs) {
            logMessage(source, "Invalid offsetExpiresSec value: ".concat(offsetExpiresSec));
            return;
          }
          const expires = Date.now() + parsedOffsetMs;
          cookieToSet += " expires=".concat(new Date(expires).toUTCString(), ";");
        }
        document.cookie = cookieToSet;
        hit(source);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function concatCookieNameValuePath(rawName, rawValue, rawPath) {
        return "".concat(encodeURIComponent(rawName), "=").concat(encodeURIComponent(rawValue), "; ").concat(getCookiePath(rawPath), ";");
      }
      function isValidCookiePath(rawPath) {
        return rawPath === "/" || rawPath === "none";
      }
      function getTrustedCookieOffsetMs(offsetExpiresSec) {
        const ONE_YEAR_EXPIRATION_KEYWORD = "1year";
        const ONE_DAY_EXPIRATION_KEYWORD = "1day";
        const MS_IN_SEC = 1e3;
        const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
        const SECONDS_IN_DAY = 24 * 60 * 60;
        let parsedSec;
        if (offsetExpiresSec === ONE_YEAR_EXPIRATION_KEYWORD) {
          parsedSec = SECONDS_IN_YEAR;
        } else if (offsetExpiresSec === ONE_DAY_EXPIRATION_KEYWORD) {
          parsedSec = SECONDS_IN_DAY;
        } else {
          parsedSec = Number.parseInt(offsetExpiresSec, 10);
          if (Number.isNaN(parsedSec)) {
            return null;
          }
        }
        return parsedSec * MS_IN_SEC;
      }
      function parseKeywordValue(rawValue) {
        const NOW_VALUE_KEYWORD = "$now$";
        const CURRENT_DATE_KEYWORD = "$currentDate$";
        let parsedValue = rawValue;
        if (rawValue === NOW_VALUE_KEYWORD) {
          parsedValue = Date.now().toString();
        } else if (rawValue === CURRENT_DATE_KEYWORD) {
          parsedValue = Date();
        }
        return parsedValue;
      }
      function getCookiePath(rawPath) {
        if (rawPath === "/") {
          return "path=/";
        }
        return "";
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        trustedSetCookie.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function trustedSetCookieReload(source, args) {
      function trustedSetCookieReload(source, name, value) {
        let offsetExpiresSec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        let path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "/";
        if (typeof name === "undefined") {
          logMessage(source, "Cookie name should be specified");
          return;
        }
        if (typeof value === "undefined") {
          logMessage(source, "Cookie value should be specified");
          return;
        }
        if (isCookieSetWithValue(document.cookie, name, value)) {
          return;
        }
        const parsedValue = parseKeywordValue(value);
        if (!isValidCookiePath(path)) {
          logMessage(source, "Invalid cookie path: '".concat(path, "'"));
          return;
        }
        let cookieToSet = concatCookieNameValuePath(name, parsedValue, path);
        if (!cookieToSet) {
          return;
        }
        if (offsetExpiresSec) {
          const parsedOffsetMs = getTrustedCookieOffsetMs(offsetExpiresSec);
          if (!parsedOffsetMs) {
            logMessage(source, "Invalid offsetExpiresSec value: ".concat(offsetExpiresSec));
            return;
          }
          const expires = Date.now() + parsedOffsetMs;
          cookieToSet += " expires=".concat(new Date(expires).toUTCString(), ";");
        }
        document.cookie = cookieToSet;
        hit(source);
        if (isCookieSetWithValue(document.cookie, name, value)) {
          window.location.reload();
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function isCookieSetWithValue(cookieString, name, value) {
        return cookieString.split(";").some(function (cookieStr) {
          const pos = cookieStr.indexOf("=");
          if (pos === -1) {
            return false;
          }
          const cookieName = cookieStr.slice(0, pos).trim();
          const cookieValue = cookieStr.slice(pos + 1).trim();
          return name === cookieName && value === cookieValue;
        });
      }
      function concatCookieNameValuePath(rawName, rawValue, rawPath) {
        return "".concat(encodeURIComponent(rawName), "=").concat(encodeURIComponent(rawValue), "; ").concat(getCookiePath(rawPath), ";");
      }
      function isValidCookiePath(rawPath) {
        return rawPath === "/" || rawPath === "none";
      }
      function getTrustedCookieOffsetMs(offsetExpiresSec) {
        const ONE_YEAR_EXPIRATION_KEYWORD = "1year";
        const ONE_DAY_EXPIRATION_KEYWORD = "1day";
        const MS_IN_SEC = 1e3;
        const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
        const SECONDS_IN_DAY = 24 * 60 * 60;
        let parsedSec;
        if (offsetExpiresSec === ONE_YEAR_EXPIRATION_KEYWORD) {
          parsedSec = SECONDS_IN_YEAR;
        } else if (offsetExpiresSec === ONE_DAY_EXPIRATION_KEYWORD) {
          parsedSec = SECONDS_IN_DAY;
        } else {
          parsedSec = Number.parseInt(offsetExpiresSec, 10);
          if (Number.isNaN(parsedSec)) {
            return null;
          }
        }
        return parsedSec * MS_IN_SEC;
      }
      function parseKeywordValue(rawValue) {
        const NOW_VALUE_KEYWORD = "$now$";
        const CURRENT_DATE_KEYWORD = "$currentDate$";
        let parsedValue = rawValue;
        if (rawValue === NOW_VALUE_KEYWORD) {
          parsedValue = Date.now().toString();
        } else if (rawValue === CURRENT_DATE_KEYWORD) {
          parsedValue = Date();
        }
        return parsedValue;
      }
      function getCookiePath(rawPath) {
        if (rawPath === "/") {
          return "path=/";
        }
        return "";
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        trustedSetCookieReload.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function trustedSetLocalStorageItem(source, args) {
      function trustedSetLocalStorageItem(source, key, value) {
        if (typeof key === "undefined") {
          logMessage(source, "Item key should be specified");
          return;
        }
        if (typeof value === "undefined") {
          logMessage(source, "Item value should be specified");
          return;
        }
        const parsedValue = parseKeywordValue(value);
        const _window = window,
          localStorage = _window.localStorage;
        setStorageItem(source, localStorage, key, parsedValue);
        hit(source);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function setStorageItem(source, storage, key, value) {
        try {
          storage.setItem(key, value);
        } catch (e) {
          const message = "Unable to set sessionStorage item due to: ".concat(e.message);
          logMessage(source, message);
        }
      }
      function parseKeywordValue(rawValue) {
        const NOW_VALUE_KEYWORD = "$now$";
        const CURRENT_DATE_KEYWORD = "$currentDate$";
        let parsedValue = rawValue;
        if (rawValue === NOW_VALUE_KEYWORD) {
          parsedValue = Date.now().toString();
        } else if (rawValue === CURRENT_DATE_KEYWORD) {
          parsedValue = Date();
        }
        return parsedValue;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        trustedSetLocalStorageItem.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function xmlPrune(source, args) {
      function xmlPrune(source, propsToRemove) {
        var _this = this;
        let optionalProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        let urlToMatch = arguments.length > 3 ? arguments[3] : undefined;
        if (typeof Reflect === "undefined" || typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
          return;
        }
        let shouldPruneResponse = true;
        if (!propsToRemove) {
          shouldPruneResponse = false;
        }
        const urlMatchRegexp = toRegExp(urlToMatch);
        const isXML = function isXML(text) {
          if (typeof text === "string") {
            const trimedText = text.trim();
            if (trimedText.startsWith("<") && trimedText.endsWith(">")) {
              return true;
            }
          }
          return false;
        };
        const createXMLDocument = function createXMLDocument(text) {
          const xmlParser = new DOMParser();
          const xmlDocument = xmlParser.parseFromString(text, "text/xml");
          return xmlDocument;
        };
        const pruneXML = function pruneXML(text) {
          if (!isXML(text)) {
            shouldPruneResponse = false;
            return text;
          }
          const xmlDoc = createXMLDocument(text);
          const errorNode = xmlDoc.querySelector("parsererror");
          if (errorNode) {
            return text;
          }
          if (optionalProp !== "" && xmlDoc.querySelector(optionalProp) === null) {
            shouldPruneResponse = false;
            return text;
          }
          const elems = xmlDoc.querySelectorAll(propsToRemove);
          if (!elems.length) {
            shouldPruneResponse = false;
            return text;
          }
          elems.forEach(function (elem) {
            elem.remove();
          });
          const serializer = new XMLSerializer();
          text = serializer.serializeToString(xmlDoc);
          return text;
        };
        const xhrWrapper = function xhrWrapper(target, thisArg, args) {
          const xhrURL = args[1];
          if (typeof xhrURL !== "string" || xhrURL.length === 0) {
            return Reflect.apply(target, thisArg, args);
          }
          if (urlMatchRegexp.test(xhrURL)) {
            thisArg.addEventListener("readystatechange", function pruneResponse() {
              if (thisArg.readyState === 4) {
                const response = thisArg.response;
                thisArg.removeEventListener("readystatechange", pruneResponse);
                if (!shouldPruneResponse) {
                  if (isXML(response)) {
                    const message = "XMLHttpRequest.open() URL: ".concat(xhrURL, "\nresponse: ").concat(response);
                    logMessage(source, message);
                    logMessage(source, createXMLDocument(response), true, false);
                  }
                } else {
                  const prunedResponseContent = pruneXML(response);
                  if (shouldPruneResponse) {
                    Object.defineProperty(thisArg, "response", {
                      value: prunedResponseContent
                    });
                    Object.defineProperty(thisArg, "responseText", {
                      value: prunedResponseContent
                    });
                    hit(source);
                  }
                  shouldPruneResponse = true;
                }
              }
            });
          }
          return Reflect.apply(target, thisArg, args);
        };
        const xhrHandler = {
          apply: xhrWrapper
        };
        window.XMLHttpRequest.prototype.open = new Proxy(window.XMLHttpRequest.prototype.open, xhrHandler);
        const nativeFetch = window.fetch;
        const fetchWrapper = function fetchWrapper(target, thisArg, args) {
          const fetchURL = args[0] instanceof Request ? args[0].url : args[0];
          if (typeof fetchURL !== "string" || fetchURL.length === 0) {
            return Reflect.apply(target, thisArg, args);
          }
          if (urlMatchRegexp.test(fetchURL)) {
            return nativeFetch.apply(_this, args).then(function (response) {
              return response.text().then(function (text) {
                if (!shouldPruneResponse) {
                  if (isXML(text)) {
                    const message = "fetch URL: ".concat(fetchURL, "\nresponse text: ").concat(text);
                    logMessage(source, message);
                    logMessage(source, createXMLDocument(text), true, false);
                  }
                  return Reflect.apply(target, thisArg, args);
                }
                const prunedText = pruneXML(text);
                if (shouldPruneResponse) {
                  hit(source);
                  return new Response(prunedText, {
                    status: response.status,
                    statusText: response.statusText,
                    headers: response.headers
                  });
                }
                shouldPruneResponse = true;
                return Reflect.apply(target, thisArg, args);
              });
            });
          }
          return Reflect.apply(target, thisArg, args);
        };
        const fetchHandler = {
          apply: fetchWrapper
        };
        window.fetch = new Proxy(window.fetch, fetchHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        xmlPrune.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    const scriptletsMap = {
      "abort-current-inline-script": abortCurrentInlineScript,
      "abort-current-script.js": abortCurrentInlineScript,
      "ubo-abort-current-script.js": abortCurrentInlineScript,
      "acs.js": abortCurrentInlineScript,
      "ubo-acs.js": abortCurrentInlineScript,
      "ubo-abort-current-script": abortCurrentInlineScript,
      "ubo-acs": abortCurrentInlineScript,
      "abort-current-inline-script.js": abortCurrentInlineScript,
      "ubo-abort-current-inline-script.js": abortCurrentInlineScript,
      "acis.js": abortCurrentInlineScript,
      "ubo-acis.js": abortCurrentInlineScript,
      "ubo-abort-current-inline-script": abortCurrentInlineScript,
      "ubo-acis": abortCurrentInlineScript,
      "abp-abort-current-inline-script": abortCurrentInlineScript,
      "abort-on-property-read": abortOnPropertyRead,
      "abort-on-property-read.js": abortOnPropertyRead,
      "ubo-abort-on-property-read.js": abortOnPropertyRead,
      "aopr.js": abortOnPropertyRead,
      "ubo-aopr.js": abortOnPropertyRead,
      "ubo-abort-on-property-read": abortOnPropertyRead,
      "ubo-aopr": abortOnPropertyRead,
      "abp-abort-on-property-read": abortOnPropertyRead,
      "abort-on-property-write": abortOnPropertyWrite,
      "abort-on-property-write.js": abortOnPropertyWrite,
      "ubo-abort-on-property-write.js": abortOnPropertyWrite,
      "aopw.js": abortOnPropertyWrite,
      "ubo-aopw.js": abortOnPropertyWrite,
      "ubo-abort-on-property-write": abortOnPropertyWrite,
      "ubo-aopw": abortOnPropertyWrite,
      "abp-abort-on-property-write": abortOnPropertyWrite,
      "abort-on-stack-trace": abortOnStackTrace,
      "abort-on-stack-trace.js": abortOnStackTrace,
      "ubo-abort-on-stack-trace.js": abortOnStackTrace,
      "aost.js": abortOnStackTrace,
      "ubo-aost.js": abortOnStackTrace,
      "ubo-abort-on-stack-trace": abortOnStackTrace,
      "ubo-aost": abortOnStackTrace,
      "abp-abort-on-stack-trace": abortOnStackTrace,
      "adjust-setInterval": adjustSetInterval,
      "nano-setInterval-booster.js": adjustSetInterval,
      "ubo-nano-setInterval-booster.js": adjustSetInterval,
      "nano-sib.js": adjustSetInterval,
      "ubo-nano-sib.js": adjustSetInterval,
      "ubo-nano-setInterval-booster": adjustSetInterval,
      "ubo-nano-sib": adjustSetInterval,
      "adjust-setTimeout": adjustSetTimeout,
      "nano-setTimeout-booster.js": adjustSetTimeout,
      "ubo-nano-setTimeout-booster.js": adjustSetTimeout,
      "nano-stb.js": adjustSetTimeout,
      "ubo-nano-stb.js": adjustSetTimeout,
      "ubo-nano-setTimeout-booster": adjustSetTimeout,
      "ubo-nano-stb": adjustSetTimeout,
      "debug-current-inline-script": debugCurrentInlineScript,
      "debug-on-property-read": debugOnPropertyRead,
      "debug-on-property-write": debugOnPropertyWrite,
      "dir-string": dirString,
      "abp-dir-string": dirString,
      "disable-newtab-links": disableNewtabLinks,
      "disable-newtab-links.js": disableNewtabLinks,
      "ubo-disable-newtab-links.js": disableNewtabLinks,
      "ubo-disable-newtab-links": disableNewtabLinks,
      "close-window": forceWindowClose,
      "window-close-if.js": forceWindowClose,
      "ubo-window-close-if.js": forceWindowClose,
      "ubo-window-close-if": forceWindowClose,
      "hide-in-shadow-dom": hideInShadowDom,
      "inject-css-in-shadow-dom": injectCssInShadowDom,
      "json-prune": jsonPrune,
      "json-prune.js": jsonPrune,
      "ubo-json-prune.js": jsonPrune,
      "ubo-json-prune": jsonPrune,
      "abp-json-prune": jsonPrune,
      log: log,
      "log-addEventListener": logAddEventListener,
      "addEventListener-logger.js": logAddEventListener,
      "ubo-addEventListener-logger.js": logAddEventListener,
      "aell.js": logAddEventListener,
      "ubo-aell.js": logAddEventListener,
      "ubo-addEventListener-logger": logAddEventListener,
      "ubo-aell": logAddEventListener,
      "log-eval": logEval,
      "log-on-stack-trace": logOnStacktrace,
      "m3u-prune": m3uPrune,
      "m3u-prune.js": m3uPrune,
      "ubo-m3u-prune.js": m3uPrune,
      "ubo-m3u-prune": m3uPrune,
      "no-topics": noTopics,
      noeval: noeval,
      "noeval.js": noeval,
      "silent-noeval.js": noeval,
      "ubo-noeval.js": noeval,
      "ubo-silent-noeval.js": noeval,
      "ubo-noeval": noeval,
      "ubo-silent-noeval": noeval,
      nowebrtc: nowebrtc,
      "nowebrtc.js": nowebrtc,
      "ubo-nowebrtc.js": nowebrtc,
      "ubo-nowebrtc": nowebrtc,
      "prevent-addEventListener": preventAddEventListener,
      "addEventListener-defuser.js": preventAddEventListener,
      "ubo-addEventListener-defuser.js": preventAddEventListener,
      "aeld.js": preventAddEventListener,
      "ubo-aeld.js": preventAddEventListener,
      "ubo-addEventListener-defuser": preventAddEventListener,
      "ubo-aeld": preventAddEventListener,
      "prevent-adfly": preventAdfly,
      "adfly-defuser.js": preventAdfly,
      "ubo-adfly-defuser.js": preventAdfly,
      "ubo-adfly-defuser": preventAdfly,
      "prevent-bab": preventBab,
      "prevent-element-src-loading": preventElementSrcLoading,
      "prevent-eval-if": preventEvalIf,
      "noeval-if.js": preventEvalIf,
      "ubo-noeval-if.js": preventEvalIf,
      "ubo-noeval-if": preventEvalIf,
      "prevent-fab-3.2.0": preventFab,
      "nofab.js": preventFab,
      "ubo-nofab.js": preventFab,
      "fuckadblock.js-3.2.0": preventFab,
      "ubo-fuckadblock.js-3.2.0": preventFab,
      "ubo-nofab": preventFab,
      "prevent-fetch": preventFetch,
      "no-fetch-if.js": preventFetch,
      "ubo-no-fetch-if.js": preventFetch,
      "ubo-no-fetch-if": preventFetch,
      "prevent-popads-net": preventPopadsNet,
      "popads.net.js": preventPopadsNet,
      "ubo-popads.net.js": preventPopadsNet,
      "ubo-popads.net": preventPopadsNet,
      "prevent-refresh": preventRefresh,
      "refresh-defuser.js": preventRefresh,
      "refresh-defuser": preventRefresh,
      "ubo-refresh-defuser.js": preventRefresh,
      "ubo-refresh-defuser": preventRefresh,
      "prevent-requestAnimationFrame": preventRequestAnimationFrame,
      "no-requestAnimationFrame-if.js": preventRequestAnimationFrame,
      "ubo-no-requestAnimationFrame-if.js": preventRequestAnimationFrame,
      "norafif.js": preventRequestAnimationFrame,
      "ubo-norafif.js": preventRequestAnimationFrame,
      "ubo-no-requestAnimationFrame-if": preventRequestAnimationFrame,
      "ubo-norafif": preventRequestAnimationFrame,
      "prevent-setInterval": preventSetInterval,
      "no-setInterval-if.js": preventSetInterval,
      "ubo-no-setInterval-if.js": preventSetInterval,
      "setInterval-defuser.js": preventSetInterval,
      "ubo-setInterval-defuser.js": preventSetInterval,
      "nosiif.js": preventSetInterval,
      "ubo-nosiif.js": preventSetInterval,
      "sid.js": preventSetInterval,
      "ubo-sid.js": preventSetInterval,
      "ubo-no-setInterval-if": preventSetInterval,
      "ubo-setInterval-defuser": preventSetInterval,
      "ubo-nosiif": preventSetInterval,
      "ubo-sid": preventSetInterval,
      "prevent-setTimeout": preventSetTimeout,
      "no-setTimeout-if.js": preventSetTimeout,
      "ubo-no-setTimeout-if.js": preventSetTimeout,
      "nostif.js": preventSetTimeout,
      "ubo-nostif.js": preventSetTimeout,
      "ubo-no-setTimeout-if": preventSetTimeout,
      "ubo-nostif": preventSetTimeout,
      "setTimeout-defuser.js": preventSetTimeout,
      "ubo-setTimeout-defuser.js": preventSetTimeout,
      "ubo-setTimeout-defuser": preventSetTimeout,
      "std.js": preventSetTimeout,
      "ubo-std.js": preventSetTimeout,
      "ubo-std": preventSetTimeout,
      "prevent-window-open": preventWindowOpen,
      "window.open-defuser.js": preventWindowOpen,
      "ubo-window.open-defuser.js": preventWindowOpen,
      "ubo-window.open-defuser": preventWindowOpen,
      "nowoif.js": preventWindowOpen,
      "ubo-nowoif.js": preventWindowOpen,
      "ubo-nowoif": preventWindowOpen,
      "prevent-xhr": preventXHR,
      "no-xhr-if.js": preventXHR,
      "ubo-no-xhr-if.js": preventXHR,
      "ubo-no-xhr-if": preventXHR,
      "remove-attr": removeAttr,
      "remove-attr.js": removeAttr,
      "ubo-remove-attr.js": removeAttr,
      "ra.js": removeAttr,
      "ubo-ra.js": removeAttr,
      "ubo-remove-attr": removeAttr,
      "ubo-ra": removeAttr,
      "remove-class": removeClass,
      "remove-class.js": removeClass,
      "ubo-remove-class.js": removeClass,
      "rc.js": removeClass,
      "ubo-rc.js": removeClass,
      "ubo-remove-class": removeClass,
      "ubo-rc": removeClass,
      "remove-cookie": removeCookie,
      "cookie-remover.js": removeCookie,
      "ubo-cookie-remover.js": removeCookie,
      "ubo-cookie-remover": removeCookie,
      "remove-in-shadow-dom": removeInShadowDom,
      "set-attr": setAttr,
      "set-constant": setConstant,
      "set-constant.js": setConstant,
      "ubo-set-constant.js": setConstant,
      "set.js": setConstant,
      "ubo-set.js": setConstant,
      "ubo-set-constant": setConstant,
      "ubo-set": setConstant,
      "abp-override-property-read": setConstant,
      "set-cookie": setCookie,
      "set-cookie-reload": setCookieReload,
      "set-local-storage-item": setLocalStorageItem,
      "set-popads-dummy": setPopadsDummy,
      "popads-dummy.js": setPopadsDummy,
      "ubo-popads-dummy.js": setPopadsDummy,
      "ubo-popads-dummy": setPopadsDummy,
      "set-session-storage-item": setSessionStorageItem,
      "trusted-click-element": trustedClickElement,
      "trusted-replace-fetch-response": trustedReplaceFetchResponse,
      "trusted-replace-xhr-response": trustedReplaceXhrResponse,
      "trusted-set-constant": trustedSetConstant,
      "trusted-set-cookie": trustedSetCookie,
      "trusted-set-cookie-reload": trustedSetCookieReload,
      "trusted-set-local-storage-item": trustedSetLocalStorageItem,
      "xml-prune": xmlPrune,
      "xml-prune.js": xmlPrune,
      "ubo-xml-prune.js": xmlPrune,
      "ubo-xml-prune": xmlPrune
    };
    var getScriptletFunction = function getScriptletFunction(name) {
      return scriptletsMap[name];
    };

    /**
     * @typedef {Object} Source Scriptlet properties.
     * @property {string} name Scriptlet name.
     * @property {Array<string>} args Arguments for scriptlet function.
     * @property {'extension'|'corelibs'|'test'} engine Defines the final form of scriptlet string presentation.
     * @property {string} [version] Extension version.
     * @property {boolean} [verbose] Flag to enable debug information printing to console.
     * @property {string} [ruleText] Source rule text, needed for debug purposes.
     * @property {string} [domainName] Domain name where scriptlet is applied, needed for debug purposes.
     */

    /**
     * Returns scriptlet code by `source`.
     *
     * @param {Source} source Scriptlet properties.
     *
     * @returns {string|null} Scriptlet code.
     * @throws An error on unknown scriptlet name.
     */
    function getScriptletCode(source) {
      if (!validator.isValidScriptletName(source.name)) {
        return null;
      }
      const scriptletFunction = getScriptletFunction(source.name);
      // In case isValidScriptletName check will pass invalid scriptlet name,
      // for example when there is a bad alias
      if (typeof scriptletFunction !== 'function') {
        throw new Error("Error: cannot invoke scriptlet with name: '".concat(source.name, "'"));
      }
      const scriptletFunctionString = scriptletFunction.toString();
      const result = source.engine === 'corelibs' || source.engine === 'test' ? wrapInNonameFunc(scriptletFunctionString) : passSourceAndProps(source, scriptletFunctionString);
      return result;
    }

    /**
     * Scriptlets variable
     *
     * @returns {Object} object with methods:
     * `invoke` method receives one argument with `Source` type
     * `validate` method receives one argument with `String` type
     */
    const scriptletsObject = function () {
      return {
        invoke: getScriptletCode,
        getScriptletFunction,
        isValidScriptletName: validator.isValidScriptletName,
        isValidScriptletRule,
        isAdgScriptletRule: validator.isAdgScriptletRule,
        isUboScriptletRule: validator.isUboScriptletRule,
        isAbpSnippetRule: validator.isAbpSnippetRule,
        convertUboToAdg: convertUboScriptletToAdg,
        convertAbpToAdg: convertAbpSnippetToAdg,
        convertScriptletToAdg,
        convertAdgToUbo: convertAdgScriptletToUbo,
        redirects
      };
    }();

    /**
     * Add module exports to be used as node package
     */
    module.exports = scriptletsObject;

}));

/**
 * -------------------------------------------
 * |                                         |
 * |  If you want to add your own scriptlet  |
 * |  please put your code below             |
 * |                                         |
 * -------------------------------------------
 */


/***/ }),

/***/ 58396:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Iu": () => (/* binding */ translate)
/* harmony export */ });
/* unused harmony exports Translator, validator */
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

var NODE_TYPES;

(function (NODE_TYPES) {
  NODE_TYPES["PLACEHOLDER"] = "placeholder";
  NODE_TYPES["TEXT"] = "text";
  NODE_TYPES["TAG"] = "tag";
  NODE_TYPES["VOID_TAG"] = "void_tag";
})(NODE_TYPES || (NODE_TYPES = {}));

var isTextNode = function isTextNode(node) {
  return node.type === NODE_TYPES.TEXT;
};
var isTagNode = function isTagNode(node) {
  return node.type === NODE_TYPES.TAG;
};
var isPlaceholderNode = function isPlaceholderNode(node) {
  return node.type === NODE_TYPES.PLACEHOLDER;
};
var isVoidTagNode = function isVoidTagNode(node) {
  return node.type === NODE_TYPES.VOID_TAG;
};
var placeholderNode = function placeholderNode(value) {
  return {
    type: NODE_TYPES.PLACEHOLDER,
    value: value
  };
};
var textNode = function textNode(str) {
  return {
    type: NODE_TYPES.TEXT,
    value: str
  };
};
var tagNode = function tagNode(tagName, children) {
  var value = tagName.trim();
  return {
    type: NODE_TYPES.TAG,
    value: value,
    children: children
  };
};
var voidTagNode = function voidTagNode(tagName) {
  var value = tagName.trim();
  return {
    type: NODE_TYPES.VOID_TAG,
    value: value
  };
};
/**
 * Checks if target is node
 * @param target
 */

var isNode = function isNode(target) {
  if (typeof target === 'string') {
    return false;
  }

  return !!target.type;
};

var STATE;

(function (STATE) {
  /**
   * Parser function switches to the text state when parses simple text,
   * or content between open and close tags
   */
  STATE["TEXT"] = "text";
  /**
   * Parser function switches to the tag state when meets open tag brace ("<"), and switches back,
   * when meets closing tag brace (">")
   */

  STATE["TAG"] = "tag";
  /**
   * Parser function switches to the placeholder state when meets in the text
   * open placeholders brace ("{") and switches back to the text state,
   * when meets close placeholder brace ("}")
   */

  STATE["PLACEHOLDER"] = "placeholder";
})(STATE || (STATE = {}));

var CONTROL_CHARS = {
  TAG_OPEN_BRACE: '<',
  TAG_CLOSE_BRACE: '>',
  CLOSING_TAG_MARK: '/',
  PLACEHOLDER_MARK: '%'
};
/**
 * Checks if text length is enough to create text node
 * If text node created, then if stack is not empty it is pushed into stack,
 * otherwise into result
 * @param context
 */

var createTextNodeIfPossible = function createTextNodeIfPossible(context) {
  var text = context.text;

  if (text.length > 0) {
    var node = textNode(text);

    if (context.stack.length > 0) {
      context.stack.push(node);
    } else {
      context.result.push(node);
    }
  }

  context.text = '';
};
/**
 * Checks if lastFromStack tag has any attributes
 * @param lastFromStack
 */


var hasAttributes = function hasAttributes(lastFromStack) {
  // e.g. "a class" or "a href='#'"
  var tagStrParts = lastFromStack.split(' ');
  return tagStrParts.length > 1;
};
/**
 * Handles text state
 */


var textStateHandler = function textStateHandler(context) {
  var currChar = context.currChar,
      currIdx = context.currIdx; // switches to the tag state

  if (currChar === CONTROL_CHARS.TAG_OPEN_BRACE) {
    context.lastTextStateChangeIdx = currIdx;
    return STATE.TAG;
  } // switches to the placeholder state


  if (currChar === CONTROL_CHARS.PLACEHOLDER_MARK) {
    context.lastTextStateChangeIdx = currIdx;
    return STATE.PLACEHOLDER;
  } // remains in the text state


  context.text += currChar;
  return STATE.TEXT;
};
/**
 * Handles placeholder state
 * @param context
 */


var placeholderStateHandler = function placeholderStateHandler(context) {
  var currChar = context.currChar,
      currIdx = context.currIdx,
      lastTextStateChangeIdx = context.lastTextStateChangeIdx,
      placeholder = context.placeholder,
      stack = context.stack,
      result = context.result,
      str = context.str;

  if (currChar === CONTROL_CHARS.PLACEHOLDER_MARK) {
    // if distance between current index and last state change equal to 1,
    // it means that placeholder mark was escaped by itself e.g. "%%",
    // so we return to the text state
    if (currIdx - lastTextStateChangeIdx === 1) {
      context.text += str.substring(lastTextStateChangeIdx, currIdx);
      return STATE.TEXT;
    }

    createTextNodeIfPossible(context);
    var node = placeholderNode(placeholder); // push node to the appropriate stack

    if (stack.length > 0) {
      stack.push(node);
    } else {
      result.push(node);
    }

    context.placeholder = '';
    return STATE.TEXT;
  }

  context.placeholder += currChar;
  return STATE.PLACEHOLDER;
};
/**
 * Switches current state to the tag state and returns tag state handler
 */


var tagStateHandler = function tagStateHandler(context) {
  var currChar = context.currChar,
      text = context.text,
      stack = context.stack,
      result = context.result,
      lastTextStateChangeIdx = context.lastTextStateChangeIdx,
      currIdx = context.currIdx,
      str = context.str;
  var tag = context.tag; // if found tag end ">"

  if (currChar === CONTROL_CHARS.TAG_CLOSE_BRACE) {
    // if the tag is close tag e.g. </a>
    if (tag.indexOf(CONTROL_CHARS.CLOSING_TAG_MARK) === 0) {
      // remove slash from tag
      tag = tag.substring(1);
      var children = [];

      if (text.length > 0) {
        children.push(textNode(text));
        context.text = '';
      }

      var pairTagFound = false; // looking for the pair to the close tag

      while (!pairTagFound && stack.length > 0) {
        var lastFromStack = stack.pop(); // if tag from stack equal to close tag

        if (lastFromStack === tag) {
          // create tag node
          var node = tagNode(tag, children); // and add it to the appropriate stack

          if (stack.length > 0) {
            stack.push(node);
          } else {
            result.push(node);
          }

          children = [];
          pairTagFound = true;
        } else if (isNode(lastFromStack)) {
          // add nodes between close tag and open tag to the children
          children.unshift(lastFromStack);
        } else {
          if (typeof lastFromStack === 'string' && hasAttributes(lastFromStack)) {
            throw new Error("Tags in string should not have attributes: ".concat(str));
          } else {
            throw new Error("String has unbalanced tags: ".concat(str));
          }
        }

        if (stack.length === 0 && children.length > 0) {
          throw new Error("String has unbalanced tags: ".concat(str));
        }
      }

      context.tag = '';
      return STATE.TEXT;
    } // if the tag is void tag e.g. <img/>


    if (tag.lastIndexOf(CONTROL_CHARS.CLOSING_TAG_MARK) === tag.length - 1) {
      tag = tag.substring(0, tag.length - 1);
      createTextNodeIfPossible(context);

      var _node = voidTagNode(tag); // add node to the appropriate stack


      if (stack.length > 0) {
        stack.push(_node);
      } else {
        result.push(_node);
      }

      context.tag = '';
      return STATE.TEXT;
    }

    createTextNodeIfPossible(context);
    stack.push(tag);
    context.tag = '';
    return STATE.TEXT;
  } // If we meet open tag "<" it means that we wrongly moved into tag state


  if (currChar === CONTROL_CHARS.TAG_OPEN_BRACE) {
    context.text += str.substring(lastTextStateChangeIdx, currIdx);
    context.lastTextStateChangeIdx = currIdx;
    context.tag = '';
    return STATE.TAG;
  }

  context.tag += currChar;
  return STATE.TAG;
};
/**
 * Parses string into AST (abstract syntax tree) and returns it
 * e.g.
 * parse("String to <a>translate</a>") ->
 * ```
 *      [
 *           { type: 'text', value: 'String to ' },
 *           { type: 'tag', value: 'a', children: [{ type: 'text', value: 'translate' }] }
 *      ];
 * ```
 * Empty string is parsed into empty AST (abstract syntax tree): "[]"
 * If founds unbalanced tags, it throws error about it
 *
 * @param {string} str - message in simplified ICU like syntax without plural support
 */


var parser = function parser() {
  var _STATE_HANDLERS;

  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var context = {
    /**
     * Stack is used to keep and search nested tag nodes
     */
    stack: [],

    /**
     * Result is stack where function allocates nodes
     */
    result: [],

    /**
     * Current char index
     */
    currIdx: 0,

    /**
     * Saves index of the last state change from the text state,
     * used to restore parsed text if we moved into other state wrongly
     */
    lastTextStateChangeIdx: 0,

    /**
     * Accumulated tag value
     */
    tag: '',

    /**
     * Accumulated text value
     */
    text: '',

    /**
     * Accumulated placeholder value
     */
    placeholder: '',

    /**
     * Parsed string
     */
    str: str
  };
  var STATE_HANDLERS = (_STATE_HANDLERS = {}, _defineProperty(_STATE_HANDLERS, STATE.TEXT, textStateHandler), _defineProperty(_STATE_HANDLERS, STATE.PLACEHOLDER, placeholderStateHandler), _defineProperty(_STATE_HANDLERS, STATE.TAG, tagStateHandler), _STATE_HANDLERS); // Start from text state

  var currentState = STATE.TEXT;

  while (context.currIdx < str.length) {
    context.currChar = str[context.currIdx];
    var currentStateHandler = STATE_HANDLERS[currentState];
    currentState = currentStateHandler(context);
    context.currIdx += 1;
  }

  var result = context.result,
      text = context.text,
      stack = context.stack,
      lastTextStateChangeIdx = context.lastTextStateChangeIdx; // Means that tag or placeholder nodes were not closed, so we consider them as text

  if (currentState !== STATE.TEXT) {
    var restText = str.substring(lastTextStateChangeIdx);

    if ((restText + text).length > 0) {
      result.push(textNode(text + restText));
    }
  } else {
    // eslint-disable-next-line no-lonely-if
    if (text.length > 0) {
      result.push(textNode(text));
    }
  }

  if (stack.length > 0) {
    throw new Error("String has unbalanced tags: ".concat(context.str));
  }

  return result;
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Helper functions used by default to assemble strings from tag nodes
 * @param tagName
 * @param children
 */

var createStringElement = function createStringElement(tagName, children) {
  if (children) {
    return "<".concat(tagName, ">").concat(children, "</").concat(tagName, ">");
  }

  return "<".concat(tagName, "/>");
};
/**
 * Creates map with default values for tag converters
 */


var createDefaultValues = function createDefaultValues() {
  return {
    p: function p(children) {
      return createStringElement('p', children);
    },
    b: function b(children) {
      return createStringElement('b', children);
    },
    strong: function strong(children) {
      return createStringElement('strong', children);
    },
    tt: function tt(children) {
      return createStringElement('tt', children);
    },
    s: function s(children) {
      return createStringElement('s', children);
    },
    i: function i(children) {
      return createStringElement('i', children);
    }
  };
};
/**
 * This function accepts an AST (abstract syntax tree) which is a result
 * of the parser function call, and converts tree nodes into array of strings replacing node
 * values with provided values.
 * Values is a map with functions or strings, where each key is related to placeholder value
 * or tag value
 * e.g.
 * string "text <tag>tag text</tag> %placeholder%" is parsed into next AST
 *
 *      [
 *          { type: 'text', value: 'text ' },
 *          {
 *              type: 'tag',
 *              value: 'tag',
 *              children: [{ type: 'text', value: 'tag text' }],
 *          },
 *          { type: 'text', value: ' ' },
 *          { type: 'placeholder', value: 'placeholder' }
 *      ];
 *
 * this AST after format and next values
 *
 *      {
 *          // here used template strings, but it can be react components as well
 *          tag: (chunks) => `<b>${chunks}</b>`,
 *          placeholder: 'placeholder text'
 *      }
 *
 * will return next array
 *
 * [ 'text ', '<b>tag text</b>', ' ', 'placeholder text' ]
 *
 * as you can see, <tag> was replaced by <b>, and placeholder was replaced by placeholder text
 *
 * @param ast - AST (abstract syntax tree)
 * @param values
 */


var format = function format() {
  var ast = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var result = [];

  var tmplValues = _objectSpread(_objectSpread({}, createDefaultValues()), values);

  var i = 0;

  while (i < ast.length) {
    var currentNode = ast[i]; // if current node is text node, there is nothing to change, append value to the result

    if (isTextNode(currentNode)) {
      result.push(currentNode.value);
    } else if (isTagNode(currentNode)) {
      var children = _toConsumableArray(format(currentNode.children, tmplValues));

      var value = tmplValues[currentNode.value];

      if (value) {
        // TODO consider using strong typing
        if (typeof value === 'function') {
          result.push(value(children.join('')));
        } else {
          result.push(value);
        }
      } else {
        throw new Error("Value ".concat(currentNode.value, " wasn't provided"));
      }
    } else if (isVoidTagNode(currentNode)) {
      var _value = tmplValues[currentNode.value]; // TODO consider using strong typing

      if (_value && typeof _value === 'string') {
        result.push(_value);
      } else {
        throw new Error("Value ".concat(currentNode.value, " wasn't provided"));
      }
    } else if (isPlaceholderNode(currentNode)) {
      var _value2 = tmplValues[currentNode.value]; // TODO consider using strong typing

      if (_value2 && typeof _value2 === 'string') {
        result.push(_value2);
      } else {
        throw new Error("Value ".concat(currentNode.value, " wasn't provided"));
      }
    }

    i += 1;
  }

  return result;
};
/**
 * Function gets AST (abstract syntax tree) or string and formats messages,
 * replacing values accordingly
 * e.g.
 *      const message = formatter('<a>some text</a>', {
 *          a: (chunks) => `<a href="#">${chunks}</a>`,
 *      });
 *      console.log(message); // ['<a href="#">some text</a>']
 * @param message
 * @param [values]
 */


var formatter = function formatter(message, values) {
  var ast = parser(message);
  var preparedValues = {}; // convert values to strings if not a function

  if (values) {
    Object.keys(values).forEach(function (key) {
      var value = values[key]; // TODO consider using strong typing

      if (typeof value === 'function') {
        preparedValues[key] = value;
      } else {
        preparedValues[key] = String(value);
      }
    });
  }

  return format(ast, preparedValues);
};

var _pluralFormsCount;

var AvailableLocales;

(function (AvailableLocales) {
  AvailableLocales["az"] = "az";
  AvailableLocales["bo"] = "bo";
  AvailableLocales["dz"] = "dz";
  AvailableLocales["id"] = "id";
  AvailableLocales["ja"] = "ja";
  AvailableLocales["jv"] = "jv";
  AvailableLocales["ka"] = "ka";
  AvailableLocales["km"] = "km";
  AvailableLocales["kn"] = "kn";
  AvailableLocales["ko"] = "ko";
  AvailableLocales["ms"] = "ms";
  AvailableLocales["th"] = "th";
  AvailableLocales["tr"] = "tr";
  AvailableLocales["vi"] = "vi";
  AvailableLocales["zh"] = "zh";
  AvailableLocales["zh_cn"] = "zh_cn";
  AvailableLocales["zh_tw"] = "zh_tw";
  AvailableLocales["af"] = "af";
  AvailableLocales["bn"] = "bn";
  AvailableLocales["bg"] = "bg";
  AvailableLocales["ca"] = "ca";
  AvailableLocales["da"] = "da";
  AvailableLocales["de"] = "de";
  AvailableLocales["el"] = "el";
  AvailableLocales["en"] = "en";
  AvailableLocales["eo"] = "eo";
  AvailableLocales["es"] = "es";
  AvailableLocales["et"] = "et";
  AvailableLocales["eu"] = "eu";
  AvailableLocales["fa"] = "fa";
  AvailableLocales["fi"] = "fi";
  AvailableLocales["fo"] = "fo";
  AvailableLocales["fur"] = "fur";
  AvailableLocales["fy"] = "fy";
  AvailableLocales["gl"] = "gl";
  AvailableLocales["gu"] = "gu";
  AvailableLocales["ha"] = "ha";
  AvailableLocales["he"] = "he";
  AvailableLocales["hu"] = "hu";
  AvailableLocales["is"] = "is";
  AvailableLocales["it"] = "it";
  AvailableLocales["ku"] = "ku";
  AvailableLocales["lb"] = "lb";
  AvailableLocales["ml"] = "ml";
  AvailableLocales["mn"] = "mn";
  AvailableLocales["mr"] = "mr";
  AvailableLocales["nah"] = "nah";
  AvailableLocales["nb"] = "nb";
  AvailableLocales["ne"] = "ne";
  AvailableLocales["nl"] = "nl";
  AvailableLocales["nn"] = "nn";
  AvailableLocales["no"] = "no";
  AvailableLocales["oc"] = "oc";
  AvailableLocales["om"] = "om";
  AvailableLocales["or"] = "or";
  AvailableLocales["pa"] = "pa";
  AvailableLocales["pap"] = "pap";
  AvailableLocales["ps"] = "ps";
  AvailableLocales["pt"] = "pt";
  AvailableLocales["pt_pt"] = "pt_pt";
  AvailableLocales["pt_br"] = "pt_br";
  AvailableLocales["so"] = "so";
  AvailableLocales["sq"] = "sq";
  AvailableLocales["sv"] = "sv";
  AvailableLocales["sw"] = "sw";
  AvailableLocales["ta"] = "ta";
  AvailableLocales["te"] = "te";
  AvailableLocales["tk"] = "tk";
  AvailableLocales["ur"] = "ur";
  AvailableLocales["zu"] = "zu";
  AvailableLocales["am"] = "am";
  AvailableLocales["bh"] = "bh";
  AvailableLocales["fil"] = "fil";
  AvailableLocales["fr"] = "fr";
  AvailableLocales["gun"] = "gun";
  AvailableLocales["hi"] = "hi";
  AvailableLocales["hy"] = "hy";
  AvailableLocales["ln"] = "ln";
  AvailableLocales["mg"] = "mg";
  AvailableLocales["nso"] = "nso";
  AvailableLocales["xbr"] = "xbr";
  AvailableLocales["ti"] = "ti";
  AvailableLocales["wa"] = "wa";
  AvailableLocales["be"] = "be";
  AvailableLocales["bs"] = "bs";
  AvailableLocales["hr"] = "hr";
  AvailableLocales["ru"] = "ru";
  AvailableLocales["sr"] = "sr";
  AvailableLocales["uk"] = "uk";
  AvailableLocales["cs"] = "cs";
  AvailableLocales["sk"] = "sk";
  AvailableLocales["ga"] = "ga";
  AvailableLocales["lt"] = "lt";
  AvailableLocales["sl"] = "sl";
  AvailableLocales["mk"] = "mk";
  AvailableLocales["mt"] = "mt";
  AvailableLocales["lv"] = "lv";
  AvailableLocales["pl"] = "pl";
  AvailableLocales["cy"] = "cy";
  AvailableLocales["ro"] = "ro";
  AvailableLocales["ar"] = "ar";
})(AvailableLocales || (AvailableLocales = {}));

var getPluralFormId = function getPluralFormId(locale, number) {
  var _supportedForms;

  if (number === 0) {
    return 0;
  }

  var slavNum = number % 10 === 1 && number % 100 !== 11 ? 1 : number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20) ? 2 : 3;
  var supportedForms = (_supportedForms = {}, _defineProperty(_supportedForms, AvailableLocales.az, 1), _defineProperty(_supportedForms, AvailableLocales.bo, 1), _defineProperty(_supportedForms, AvailableLocales.dz, 1), _defineProperty(_supportedForms, AvailableLocales.id, 1), _defineProperty(_supportedForms, AvailableLocales.ja, 1), _defineProperty(_supportedForms, AvailableLocales.jv, 1), _defineProperty(_supportedForms, AvailableLocales.ka, 1), _defineProperty(_supportedForms, AvailableLocales.km, 1), _defineProperty(_supportedForms, AvailableLocales.kn, 1), _defineProperty(_supportedForms, AvailableLocales.ko, 1), _defineProperty(_supportedForms, AvailableLocales.ms, 1), _defineProperty(_supportedForms, AvailableLocales.th, 1), _defineProperty(_supportedForms, AvailableLocales.tr, 1), _defineProperty(_supportedForms, AvailableLocales.vi, 1), _defineProperty(_supportedForms, AvailableLocales.zh, 1), _defineProperty(_supportedForms, AvailableLocales.zh_tw, 1), _defineProperty(_supportedForms, AvailableLocales.zh_cn, 1), _defineProperty(_supportedForms, AvailableLocales.af, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.bn, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.bg, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.ca, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.da, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.de, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.el, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.en, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.eo, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.es, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.et, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.eu, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.fa, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.fi, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.fo, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.fur, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.fy, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.gl, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.gu, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.ha, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.he, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.hu, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.is, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.it, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.ku, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.lb, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.ml, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.mn, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.mr, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.nah, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.nb, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.ne, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.nl, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.nn, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.no, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.oc, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.om, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.or, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.pa, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.pap, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.ps, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.pt, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.pt_pt, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.pt_br, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.so, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.sq, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.sv, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.sw, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.ta, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.te, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.tk, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.ur, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.zu, number === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.am, number === 0 || number === 1 ? 0 : 1), _defineProperty(_supportedForms, AvailableLocales.bh, number === 0 || number === 1 ? 0 : 1), _defineProperty(_supportedForms, AvailableLocales.fil, number === 0 || number === 1 ? 0 : 1), _defineProperty(_supportedForms, AvailableLocales.fr, number === 0 || number >= 2 ? 2 : 1), _defineProperty(_supportedForms, AvailableLocales.gun, number === 0 || number === 1 ? 0 : 1), _defineProperty(_supportedForms, AvailableLocales.hi, number === 0 || number === 1 ? 0 : 1), _defineProperty(_supportedForms, AvailableLocales.hy, number === 0 || number === 1 ? 0 : 1), _defineProperty(_supportedForms, AvailableLocales.ln, number === 0 || number === 1 ? 0 : 1), _defineProperty(_supportedForms, AvailableLocales.mg, number === 0 || number === 1 ? 0 : 1), _defineProperty(_supportedForms, AvailableLocales.nso, number === 0 || number === 1 ? 0 : 1), _defineProperty(_supportedForms, AvailableLocales.xbr, number === 0 || number === 1 ? 0 : 1), _defineProperty(_supportedForms, AvailableLocales.ti, number === 0 || number === 1 ? 0 : 1), _defineProperty(_supportedForms, AvailableLocales.wa, number === 0 || number === 1 ? 0 : 1), _defineProperty(_supportedForms, AvailableLocales.be, slavNum), _defineProperty(_supportedForms, AvailableLocales.bs, slavNum), _defineProperty(_supportedForms, AvailableLocales.hr, slavNum), _defineProperty(_supportedForms, AvailableLocales.ru, slavNum), _defineProperty(_supportedForms, AvailableLocales.sr, slavNum), _defineProperty(_supportedForms, AvailableLocales.uk, slavNum), _defineProperty(_supportedForms, AvailableLocales.cs, number === 1 ? 1 : number >= 2 && number <= 4 ? 2 : 3), _defineProperty(_supportedForms, AvailableLocales.sk, number === 1 ? 1 : number >= 2 && number <= 4 ? 2 : 3), _defineProperty(_supportedForms, AvailableLocales.ga, number === 1 ? 1 : number === 2 ? 2 : 3), _defineProperty(_supportedForms, AvailableLocales.lt, number % 10 === 1 && number % 100 !== 11 ? 1 : number % 10 >= 2 && (number % 100 < 10 || number % 100 >= 20) ? 2 : 3), _defineProperty(_supportedForms, AvailableLocales.sl, number % 100 === 1 ? 1 : number % 100 === 2 ? 2 : number % 100 === 3 || number % 100 === 4 ? 3 : 4), _defineProperty(_supportedForms, AvailableLocales.mk, number % 10 === 1 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.mt, number === 1 ? 1 : number === 0 || number % 100 > 1 && number % 100 < 11 ? 2 : number % 100 > 10 && number % 100 < 20 ? 3 : 4), _defineProperty(_supportedForms, AvailableLocales.lv, number === 0 ? 0 : number % 10 === 1 && number % 100 !== 11 ? 1 : 2), _defineProperty(_supportedForms, AvailableLocales.pl, number === 1 ? 1 : number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 12 || number % 100 > 14) ? 2 : 3), _defineProperty(_supportedForms, AvailableLocales.cy, number === 1 ? 0 : number === 2 ? 1 : number === 8 || number === 11 ? 2 : 3), _defineProperty(_supportedForms, AvailableLocales.ro, number === 1 ? 1 : number === 1 || number % 100 > 0 && number % 100 < 20 ? 2 : 3), _defineProperty(_supportedForms, AvailableLocales.ar, number === 0 ? 0 : number === 1 ? 1 : number === 2 ? 2 : number % 100 >= 3 && number % 100 <= 10 ? 3 : number % 100 >= 11 && number % 100 <= 99 ? 4 : 5), _supportedForms);
  return supportedForms[locale];
};

var pluralFormsCount = (_pluralFormsCount = {}, _defineProperty(_pluralFormsCount, AvailableLocales.az, 2), _defineProperty(_pluralFormsCount, AvailableLocales.bo, 2), _defineProperty(_pluralFormsCount, AvailableLocales.dz, 2), _defineProperty(_pluralFormsCount, AvailableLocales.id, 2), _defineProperty(_pluralFormsCount, AvailableLocales.ja, 2), _defineProperty(_pluralFormsCount, AvailableLocales.jv, 2), _defineProperty(_pluralFormsCount, AvailableLocales.ka, 2), _defineProperty(_pluralFormsCount, AvailableLocales.km, 2), _defineProperty(_pluralFormsCount, AvailableLocales.kn, 2), _defineProperty(_pluralFormsCount, AvailableLocales.ko, 2), _defineProperty(_pluralFormsCount, AvailableLocales.ms, 2), _defineProperty(_pluralFormsCount, AvailableLocales.th, 2), _defineProperty(_pluralFormsCount, AvailableLocales.tr, 2), _defineProperty(_pluralFormsCount, AvailableLocales.vi, 2), _defineProperty(_pluralFormsCount, AvailableLocales.zh, 2), _defineProperty(_pluralFormsCount, AvailableLocales.zh_cn, 2), _defineProperty(_pluralFormsCount, AvailableLocales.zh_tw, 2), _defineProperty(_pluralFormsCount, AvailableLocales.af, 3), _defineProperty(_pluralFormsCount, AvailableLocales.bn, 3), _defineProperty(_pluralFormsCount, AvailableLocales.bg, 3), _defineProperty(_pluralFormsCount, AvailableLocales.ca, 3), _defineProperty(_pluralFormsCount, AvailableLocales.da, 3), _defineProperty(_pluralFormsCount, AvailableLocales.de, 3), _defineProperty(_pluralFormsCount, AvailableLocales.el, 3), _defineProperty(_pluralFormsCount, AvailableLocales.en, 3), _defineProperty(_pluralFormsCount, AvailableLocales.eo, 3), _defineProperty(_pluralFormsCount, AvailableLocales.es, 3), _defineProperty(_pluralFormsCount, AvailableLocales.et, 3), _defineProperty(_pluralFormsCount, AvailableLocales.eu, 3), _defineProperty(_pluralFormsCount, AvailableLocales.fa, 3), _defineProperty(_pluralFormsCount, AvailableLocales.fi, 3), _defineProperty(_pluralFormsCount, AvailableLocales.fo, 3), _defineProperty(_pluralFormsCount, AvailableLocales.fur, 3), _defineProperty(_pluralFormsCount, AvailableLocales.fy, 3), _defineProperty(_pluralFormsCount, AvailableLocales.gl, 3), _defineProperty(_pluralFormsCount, AvailableLocales.gu, 3), _defineProperty(_pluralFormsCount, AvailableLocales.ha, 3), _defineProperty(_pluralFormsCount, AvailableLocales.he, 3), _defineProperty(_pluralFormsCount, AvailableLocales.hu, 3), _defineProperty(_pluralFormsCount, AvailableLocales.is, 3), _defineProperty(_pluralFormsCount, AvailableLocales.it, 3), _defineProperty(_pluralFormsCount, AvailableLocales.ku, 3), _defineProperty(_pluralFormsCount, AvailableLocales.lb, 3), _defineProperty(_pluralFormsCount, AvailableLocales.ml, 3), _defineProperty(_pluralFormsCount, AvailableLocales.mn, 3), _defineProperty(_pluralFormsCount, AvailableLocales.mr, 3), _defineProperty(_pluralFormsCount, AvailableLocales.nah, 3), _defineProperty(_pluralFormsCount, AvailableLocales.nb, 3), _defineProperty(_pluralFormsCount, AvailableLocales.ne, 3), _defineProperty(_pluralFormsCount, AvailableLocales.nl, 3), _defineProperty(_pluralFormsCount, AvailableLocales.nn, 3), _defineProperty(_pluralFormsCount, AvailableLocales.no, 3), _defineProperty(_pluralFormsCount, AvailableLocales.oc, 3), _defineProperty(_pluralFormsCount, AvailableLocales.om, 3), _defineProperty(_pluralFormsCount, AvailableLocales.or, 3), _defineProperty(_pluralFormsCount, AvailableLocales.pa, 3), _defineProperty(_pluralFormsCount, AvailableLocales.pap, 3), _defineProperty(_pluralFormsCount, AvailableLocales.ps, 3), _defineProperty(_pluralFormsCount, AvailableLocales.pt, 3), _defineProperty(_pluralFormsCount, AvailableLocales.pt_pt, 3), _defineProperty(_pluralFormsCount, AvailableLocales.pt_br, 3), _defineProperty(_pluralFormsCount, AvailableLocales.so, 3), _defineProperty(_pluralFormsCount, AvailableLocales.sq, 3), _defineProperty(_pluralFormsCount, AvailableLocales.sv, 3), _defineProperty(_pluralFormsCount, AvailableLocales.sw, 3), _defineProperty(_pluralFormsCount, AvailableLocales.ta, 3), _defineProperty(_pluralFormsCount, AvailableLocales.te, 3), _defineProperty(_pluralFormsCount, AvailableLocales.tk, 3), _defineProperty(_pluralFormsCount, AvailableLocales.ur, 3), _defineProperty(_pluralFormsCount, AvailableLocales.zu, 3), _defineProperty(_pluralFormsCount, AvailableLocales.am, 2), _defineProperty(_pluralFormsCount, AvailableLocales.bh, 2), _defineProperty(_pluralFormsCount, AvailableLocales.fil, 2), _defineProperty(_pluralFormsCount, AvailableLocales.fr, 3), _defineProperty(_pluralFormsCount, AvailableLocales.gun, 2), _defineProperty(_pluralFormsCount, AvailableLocales.hi, 2), _defineProperty(_pluralFormsCount, AvailableLocales.hy, 2), _defineProperty(_pluralFormsCount, AvailableLocales.ln, 2), _defineProperty(_pluralFormsCount, AvailableLocales.mg, 2), _defineProperty(_pluralFormsCount, AvailableLocales.nso, 2), _defineProperty(_pluralFormsCount, AvailableLocales.xbr, 2), _defineProperty(_pluralFormsCount, AvailableLocales.ti, 2), _defineProperty(_pluralFormsCount, AvailableLocales.wa, 2), _defineProperty(_pluralFormsCount, AvailableLocales.be, 4), _defineProperty(_pluralFormsCount, AvailableLocales.bs, 4), _defineProperty(_pluralFormsCount, AvailableLocales.hr, 4), _defineProperty(_pluralFormsCount, AvailableLocales.ru, 4), _defineProperty(_pluralFormsCount, AvailableLocales.sr, 4), _defineProperty(_pluralFormsCount, AvailableLocales.uk, 4), _defineProperty(_pluralFormsCount, AvailableLocales.cs, 4), _defineProperty(_pluralFormsCount, AvailableLocales.sk, 4), _defineProperty(_pluralFormsCount, AvailableLocales.ga, 4), _defineProperty(_pluralFormsCount, AvailableLocales.lt, 4), _defineProperty(_pluralFormsCount, AvailableLocales.sl, 5), _defineProperty(_pluralFormsCount, AvailableLocales.mk, 3), _defineProperty(_pluralFormsCount, AvailableLocales.mt, 5), _defineProperty(_pluralFormsCount, AvailableLocales.lv, 3), _defineProperty(_pluralFormsCount, AvailableLocales.pl, 4), _defineProperty(_pluralFormsCount, AvailableLocales.cy, 4), _defineProperty(_pluralFormsCount, AvailableLocales.ro, 4), _defineProperty(_pluralFormsCount, AvailableLocales.ar, 6), _pluralFormsCount);
var PLURAL_STRING_DELIMITER = '|';

var checkForms = function checkForms(str, locale, key) {
  var forms = str.split(PLURAL_STRING_DELIMITER);

  if (forms.length !== pluralFormsCount[locale]) {
    throw new Error("Invalid plural string \"".concat(key, "\" for locale ").concat(locale, ": ").concat(forms.length, " given; need: ").concat(pluralFormsCount[locale]));
  }
};
/**
 * Checks if plural forms are valid
 * @param str - message string
 * @param locale - message locale
 * @param key - message key, used for clearer log message
 */


var isPluralFormValid = function isPluralFormValid(str, locale, key) {
  try {
    checkForms(str, locale, key);
    return true;
  } catch (error) {
    return false;
  }
};
/**
 * Returns plural form corresponding to number
 * @param str
 * @param number
 * @param locale - current locale
 * @param key - message key
 */

var getForm = function getForm(str, number, locale, key) {
  checkForms(str, locale, key);
  var forms = str.split(PLURAL_STRING_DELIMITER);
  var currentForm = getPluralFormId(locale, number);
  return forms[currentForm].trim();
};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var defaultMessageConstructor = function defaultMessageConstructor(formatted) {
  return formatted.join('');
};

var Translator = /*#__PURE__*/function () {
  function Translator(i18n, messageConstructor, values) {
    _classCallCheck(this, Translator);

    this.i18n = i18n;
    this.messageConstructor = messageConstructor || defaultMessageConstructor;
    this.values = values || {};
  }
  /**
   * Retrieves message and translates it, substituting parameters where necessary
   * @param key - translation message key
   * @param params - values used to substitute placeholders and tags
   */


  _createClass(Translator, [{
    key: "getMessage",
    value: function getMessage(key) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var message = this.i18n.getMessage(key);

      if (!message) {
        message = this.i18n.getBaseMessage(key);

        if (!message) {
          throw new Error("Was unable to find message for key: \"".concat(key, "\""));
        }
      }

      var formatted = formatter(message, _objectSpread$1(_objectSpread$1({}, this.values), params));
      return this.messageConstructor(formatted);
    }
    /**
     * Retrieves correct plural form and translates it
     * @param key - translation message key
     * @param number - plural form number
     * @param params - values used to substitute placeholders or tags if necessary,
     * if params has "count" property it will be overridden by number (plural form number)
     */

  }, {
    key: "getPlural",
    value: function getPlural(key, number) {
      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var message = this.i18n.getMessage(key);
      var language = this.i18n.getUILanguage();

      if (!message) {
        message = this.i18n.getBaseMessage(key);

        if (!message) {
          throw new Error("Was unable to find message for key: \"".concat(key, "\""));
        }

        language = this.i18n.getBaseUILanguage();
      }

      var form = getForm(message, number, language, key);
      var formatted = formatter(form, _objectSpread$1(_objectSpread$1(_objectSpread$1({}, this.values), params), {}, {
        count: number
      }));
      return this.messageConstructor(formatted);
    }
  }]);

  return Translator;
}();

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Creates translation function for strings used in the React components
 * We do not import React directly, because translator module can be used
 * in the modules without React too
 *
 * e.g.
 * const translateReact = createReactTranslator(getMessage, React);
 * in locales folder you should have messages.json file
 * ```
 * message:
 *     "popup_auth_agreement_consent": {
 *          "message": "You agree to our <eula>EULA</eula>",
 *      },
 * ```
 *
 * this message can be retrieved and translated into react components next way:
 *
 * const component = translateReact('popup_auth_agreement_consent', {
 *          eula: (chunks) => (
 *              <button
 *                  className="auth__privacy-link"
 *                  onClick={handleEulaClick}
 *              >
 *                  {chunks}
 *              </button>
 *          ),
 *       });
 *
 * Note how functions in the values argument can be used with handlers
 *
 * @param i18n - object with methods which get translated message by key and return current locale
 * @param React - instance of react library
 */

var createReactTranslator = function createReactTranslator(i18n, react, defaults) {
  /**
   * Helps to build nodes without values
   *
   * @param tagName
   * @param children
   */
  var createReactElement = function createReactElement(tagName, children) {
    if (children) {
      return react.createElement(tagName, null, react.Children.toArray(children));
    }

    return react.createElement(tagName, null);
  };
  /**
   * Function creates default values to be used if user didn't provide function values for tags
   */


  var createDefaultValues = function createDefaultValues() {
    var externalDefaults = {};

    if (defaults) {
      defaults.tags.forEach(function (t) {
        externalDefaults[t.key] = function (children) {
          return createReactElement(t.createdTag, children);
        };
      });
    }

    if (defaults !== null && defaults !== void 0 && defaults.override) {
      return externalDefaults;
    }

    return _objectSpread$2({
      p: function p(children) {
        return createReactElement('p', children);
      },
      b: function b(children) {
        return createReactElement('b', children);
      },
      strong: function strong(children) {
        return createReactElement('strong', children);
      },
      tt: function tt(children) {
        return createReactElement('tt', children);
      },
      s: function s(children) {
        return createReactElement('s', children);
      },
      i: function i(children) {
        return createReactElement('i', children);
      }
    }, externalDefaults);
  };

  var reactMessageConstructor = function reactMessageConstructor(formatted) {
    var reactChildren = react.Children.toArray(formatted); // if there is only strings in the array we join them

    if (reactChildren.every(function (child) {
      return typeof child === 'string';
    })) {
      return reactChildren.join('');
    }

    return reactChildren;
  };

  var defaultValues = createDefaultValues();
  return new Translator(i18n, reactMessageConstructor, defaultValues);
};

var r,
    f;

function A(n, l) {
  return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
    A(n, l);
  }) : l.push(n)), l;
}

r = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f = 0;

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Creates translation function for strings used in the Preact components
 * We do not import Preact directly, because translator module can be used
 * in the modules without Preact too
 *
 * e.g.
 * const translatePreact = createPreactTranslator(getMessage, Preact);
 * in locales folder you should have messages.json file
 * ```
 * message:
 *     "popup_auth_agreement_consent": {
 *          "message": "You agree to our <eula>EULA</eula>",
 *      },
 * ```
 *
 * this message can be retrieved and translated into preact components next way:
 *
 * const component = translatePreact('popup_auth_agreement_consent', {
 *          eula: (chunks) => (
 *              <button
 *                  className="auth__privacy-link"
 *                  onClick={handleEulaClick}
 *              >
 *                  {chunks}
 *              </button>
 *          ),
 *       });
 *
 * Note how functions in the values argument can be used with handlers
 *
 * @param i18n - object with methods which get translated message by key and return current locale
 * @param Preact - instance of preact library
 */

var createPreactTranslator = function createPreactTranslator(i18n, preact, defaults) {
  /**
   * Helps to build nodes without values
   *
   * @param tagName
   * @param children
   */
  var createPreactElement = function createPreactElement(tagName, children) {
    if (children) {
      return preact.createElement(tagName, null, A(children));
    }

    return preact.createElement(tagName, null);
  };
  /**
   * Function creates default values to be used if user didn't provide function values for tags
   */


  var createDefaultValues = function createDefaultValues() {
    var externalDefaults = {};

    if (defaults) {
      defaults.tags.forEach(function (t) {
        externalDefaults[t.key] = function (children) {
          return createPreactElement(t.createdTag, children);
        };
      });
    }

    if (defaults !== null && defaults !== void 0 && defaults.override) {
      return externalDefaults;
    }

    return _objectSpread$3({
      p: function p(children) {
        return createPreactElement('p', children);
      },
      b: function b(children) {
        return createPreactElement('b', children);
      },
      strong: function strong(children) {
        return createPreactElement('strong', children);
      },
      tt: function tt(children) {
        return createPreactElement('tt', children);
      },
      s: function s(children) {
        return createPreactElement('s', children);
      },
      i: function i(children) {
        return createPreactElement('i', children);
      }
    }, externalDefaults);
  };

  var preactMessageConstructor = function preactMessageConstructor(formatted) {
    var preactChildren = A(formatted); // if there is only strings in the array we join them

    if (preactChildren.every(function (child) {
      return typeof child === 'string';
    })) {
      return preactChildren.join('');
    }

    return preactChildren;
  };

  var defaultValues = createDefaultValues();
  return new Translator(i18n, preactMessageConstructor, defaultValues);
};

/**
 * Creates translator instance strings, by default for simple strings
 * @param i18n - function which returns translated message by key
 * @param messageConstructor - function that will collect messages
 * @param values - map with default values for tag converters
 */

var createTranslator = function createTranslator(i18n, messageConstructor, values) {
  return new Translator(i18n, messageConstructor, values);
};

var translate = {
  createTranslator: createTranslator,
  createReactTranslator: createReactTranslator,
  createPreactTranslator: createPreactTranslator
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

/**
 * Compares two AST (abstract syntax tree) structures,
 * view tests for examples
 * @param baseAst
 * @param targetAst
 */

var areAstStructuresSame = function areAstStructuresSame(baseAst, targetAst) {
  var textNodeFilter = function textNodeFilter(node) {
    return !isTextNode(node);
  };

  var filteredBaseAst = baseAst.filter(textNodeFilter);
  var filteredTargetAst = targetAst.filter(textNodeFilter); // if AST structures have different lengths, they are not equal

  if (filteredBaseAst.length !== filteredTargetAst.length) {
    return false;
  }

  var _loop = function _loop(i) {
    var baseNode = filteredBaseAst[i];
    var targetNode = filteredTargetAst.find(function (node) {
      return node.type === baseNode.type && node.value === baseNode.value;
    });

    if (!targetNode) {
      return {
        v: false
      };
    }

    if (targetNode.children && baseNode.children) {
      var areChildrenSame = areAstStructuresSame(baseNode.children, targetNode.children);

      if (!areChildrenSame) {
        return {
          v: false
        };
      }
    }
  };

  for (var i = 0; i < filteredBaseAst.length; i += 1) {
    var _ret = _loop(i);

    if (_typeof(_ret) === "object") return _ret.v;
  }

  return true;
};
/**
 * Validates translation against base string by AST (abstract syntax tree) structure
 * @param baseMessage - base message
 * @param translatedMessage - translated message
 */


var isTranslationValid = function isTranslationValid(baseMessage, translatedMessage) {
  var baseMessageAst = parser(baseMessage);
  var translatedMessageAst = parser(translatedMessage);
  return areAstStructuresSame(baseMessageAst, translatedMessageAst);
};
var validator = {
  isTranslationValid: isTranslationValid,
  isPluralFormValid: isPluralFormValid
};




/***/ }),

/***/ 38146:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(92163);
var tryToString = __webpack_require__(40368);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 17321:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isConstructor = __webpack_require__(57558);
var tryToString = __webpack_require__(40368);

var $TypeError = TypeError;

// `Assert: IsConstructor(argument) is true`
module.exports = function (argument) {
  if (isConstructor(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a constructor');
};


/***/ }),

/***/ 81402:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(92163);

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ 78875:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(4259);
var create = __webpack_require__(28603);
var defineProperty = (__webpack_require__(16572).f);

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  defineProperty(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ 98514:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(23041);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 24489:
/***/ ((module) => {

// eslint-disable-next-line es-x/no-typed-arrays -- safe
module.exports = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';


/***/ }),

/***/ 19547:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_ARRAY_BUFFER = __webpack_require__(24489);
var DESCRIPTORS = __webpack_require__(46372);
var global = __webpack_require__(63406);
var isCallable = __webpack_require__(92163);
var isObject = __webpack_require__(23041);
var hasOwn = __webpack_require__(21325);
var classof = __webpack_require__(47298);
var tryToString = __webpack_require__(40368);
var createNonEnumerableProperty = __webpack_require__(27767);
var defineBuiltIn = __webpack_require__(14039);
var defineProperty = (__webpack_require__(16572).f);
var isPrototypeOf = __webpack_require__(3071);
var getPrototypeOf = __webpack_require__(96350);
var setPrototypeOf = __webpack_require__(50744);
var wellKnownSymbol = __webpack_require__(4259);
var uid = __webpack_require__(76004);
var InternalStateModule = __webpack_require__(3987);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var TypeError = global.TypeError;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
var TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQUIRED = false;
var NAME, Constructor, Prototype;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};

var isView = function isView(it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return klass === 'DataView'
    || hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var getTypedArrayConstructor = function (it) {
  var proto = getPrototypeOf(it);
  if (!isObject(proto)) return;
  var state = getInternalState(proto);
  return (state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
};

var isTypedArray = function (it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
  throw TypeError(tryToString(C) + ' is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced, options) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
      delete TypedArrayConstructor.prototype[KEY];
    } catch (error) {
      // old WebKit bug - some methods are non-configurable
      try {
        TypedArrayConstructor.prototype[KEY] = property;
      } catch (error2) { /* empty */ }
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    defineBuiltIn(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
        delete TypedArrayConstructor[KEY];
      } catch (error) { /* empty */ }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      defineBuiltIn(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  Constructor = global[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
  else NATIVE_ARRAY_BUFFER_VIEWS = false;
}

for (NAME in BigIntArrayConstructorsList) {
  Constructor = global[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow -- safe
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQUIRED = true;
  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {
    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
  } });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

module.exports = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  getTypedArrayConstructor: getTypedArrayConstructor,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),

/***/ 64465:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIndexedObject = __webpack_require__(19130);
var toAbsoluteIndex = __webpack_require__(63828);
var lengthOfArrayLike = __webpack_require__(25474);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 74021:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(73074);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 47298:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var TO_STRING_TAG_SUPPORT = __webpack_require__(98216);
var isCallable = __webpack_require__(92163);
var classofRaw = __webpack_require__(74021);
var wellKnownSymbol = __webpack_require__(4259);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 85425:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(48624);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);

// https://github.com/tc39/collection-methods
module.exports = function addAll(/* ...elements */) {
  var set = anObject(this);
  var adder = aCallable(set.add);
  for (var k = 0, len = arguments.length; k < len; k++) {
    call(adder, set, arguments[k]);
  }
  return set;
};


/***/ }),

/***/ 50011:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(48624);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);

// https://github.com/tc39/collection-methods
module.exports = function deleteAll(/* ...elements */) {
  var collection = anObject(this);
  var remover = aCallable(collection['delete']);
  var allDeleted = true;
  var wasDeleted;
  for (var k = 0, len = arguments.length; k < len; k++) {
    wasDeleted = call(remover, collection, arguments[k]);
    allDeleted = allDeleted && wasDeleted;
  }
  return !!allDeleted;
};


/***/ }),

/***/ 61401:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasOwn = __webpack_require__(21325);
var ownKeys = __webpack_require__(20810);
var getOwnPropertyDescriptorModule = __webpack_require__(99206);
var definePropertyModule = __webpack_require__(16572);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 28165:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(7931);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 27767:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(46372);
var definePropertyModule = __webpack_require__(16572);
var createPropertyDescriptor = __webpack_require__(48602);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 48602:
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 14039:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(92163);
var definePropertyModule = __webpack_require__(16572);
var makeBuiltIn = __webpack_require__(85954);
var defineGlobalProperty = __webpack_require__(95861);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ 95861:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(63406);

// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 46372:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(7931);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 94193:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(63406);
var isObject = __webpack_require__(23041);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 20283:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(39997);

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ 55111:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(63406);
var userAgent = __webpack_require__(20283);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 46606:
/***/ ((module) => {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 65942:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(63406);
var getOwnPropertyDescriptor = (__webpack_require__(99206).f);
var createNonEnumerableProperty = __webpack_require__(27767);
var defineBuiltIn = __webpack_require__(14039);
var defineGlobalProperty = __webpack_require__(95861);
var copyConstructorProperties = __webpack_require__(61401);
var isForced = __webpack_require__(21637);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 7931:
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 98626:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(73074);
var aCallable = __webpack_require__(38146);
var NATIVE_BIND = __webpack_require__(62637);

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 62637:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(7931);

module.exports = !fails(function () {
  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 48624:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(62637);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 30233:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(46372);
var hasOwn = __webpack_require__(21325);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 73074:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(62637);

var FunctionPrototype = Function.prototype;
var bind = FunctionPrototype.bind;
var call = FunctionPrototype.call;
var uncurryThis = NATIVE_BIND && bind.bind(call, call);

module.exports = NATIVE_BIND ? function (fn) {
  return fn && uncurryThis(fn);
} : function (fn) {
  return fn && function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 39997:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(63406);
var isCallable = __webpack_require__(92163);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 50610:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(47298);
var getMethod = __webpack_require__(54462);
var isNullOrUndefined = __webpack_require__(57900);
var Iterators = __webpack_require__(16133);
var wellKnownSymbol = __webpack_require__(4259);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};


/***/ }),

/***/ 11570:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(48624);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);
var tryToString = __webpack_require__(40368);
var getIteratorMethod = __webpack_require__(50610);

var $TypeError = TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw $TypeError(tryToString(argument) + ' is not iterable');
};


/***/ }),

/***/ 51285:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(48624);

module.exports = function (it) {
  // eslint-disable-next-line es-x/no-map -- safe
  return call(Map.prototype.entries, it);
};


/***/ }),

/***/ 54462:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aCallable = __webpack_require__(38146);
var isNullOrUndefined = __webpack_require__(57900);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ 7762:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(48624);

module.exports = function (it) {
  // eslint-disable-next-line es-x/no-set -- safe
  return call(Set.prototype.values, it);
};


/***/ }),

/***/ 24053:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(73074);
var toObject = __webpack_require__(77410);

var floor = Math.floor;
var charAt = uncurryThis(''.charAt);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

// `GetSubstitution` abstract operation
// https://tc39.es/ecma262/#sec-getsubstitution
module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== undefined) {
    namedCaptures = toObject(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace(replacement, symbols, function (match, ch) {
    var capture;
    switch (charAt(ch, 0)) {
      case '$': return '$';
      case '&': return matched;
      case '`': return stringSlice(str, 0, position);
      case "'": return stringSlice(str, tailPos);
      case '<':
        capture = namedCaptures[stringSlice(ch, 1, -1)];
        break;
      default: // \d\d?
        var n = +ch;
        if (n === 0) return match;
        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
          return match;
        }
        capture = captures[n - 1];
    }
    return capture === undefined ? '' : capture;
  });
};


/***/ }),

/***/ 63406:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es-x/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 21325:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(73074);
var toObject = __webpack_require__(77410);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es-x/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 43730:
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ 79150:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(39997);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ 53202:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(46372);
var fails = __webpack_require__(7931);
var createElement = __webpack_require__(94193);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 52170:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(73074);
var fails = __webpack_require__(7931);
var classof = __webpack_require__(74021);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 22089:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(73074);
var isCallable = __webpack_require__(92163);
var store = __webpack_require__(12846);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 3987:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_WEAK_MAP = __webpack_require__(24617);
var global = __webpack_require__(63406);
var uncurryThis = __webpack_require__(73074);
var isObject = __webpack_require__(23041);
var createNonEnumerableProperty = __webpack_require__(27767);
var hasOwn = __webpack_require__(21325);
var shared = __webpack_require__(12846);
var sharedKey = __webpack_require__(1320);
var hiddenKeys = __webpack_require__(43730);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = uncurryThis(store.get);
  var wmhas = uncurryThis(store.has);
  var wmset = uncurryThis(store.set);
  set = function (it, metadata) {
    if (wmhas(store, it)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget(store, it) || {};
  };
  has = function (it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 18335:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(4259);
var Iterators = __webpack_require__(16133);

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ 92163:
/***/ ((module) => {

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 57558:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(73074);
var fails = __webpack_require__(7931);
var isCallable = __webpack_require__(92163);
var classof = __webpack_require__(47298);
var getBuiltIn = __webpack_require__(39997);
var inspectSource = __webpack_require__(22089);

var noop = function () { /* empty */ };
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ 21637:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(7931);
var isCallable = __webpack_require__(92163);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 57900:
/***/ ((module) => {

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ 23041:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(92163);

var documentAll = typeof document == 'object' && document.all;

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var SPECIAL_DOCUMENT_ALL = typeof documentAll == 'undefined' && documentAll !== undefined;

module.exports = SPECIAL_DOCUMENT_ALL ? function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;
} : function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 2884:
/***/ ((module) => {

module.exports = false;


/***/ }),

/***/ 33948:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(23041);
var classof = __webpack_require__(74021);
var wellKnownSymbol = __webpack_require__(4259);

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ 85666:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(39997);
var isCallable = __webpack_require__(92163);
var isPrototypeOf = __webpack_require__(3071);
var USE_SYMBOL_AS_UID = __webpack_require__(99525);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 67523:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var bind = __webpack_require__(98626);
var call = __webpack_require__(48624);
var anObject = __webpack_require__(98514);
var tryToString = __webpack_require__(40368);
var isArrayIteratorMethod = __webpack_require__(18335);
var lengthOfArrayLike = __webpack_require__(25474);
var isPrototypeOf = __webpack_require__(3071);
var getIterator = __webpack_require__(11570);
var getIteratorMethod = __webpack_require__(50610);
var iteratorClose = __webpack_require__(31652);

var $TypeError = TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw $TypeError(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};


/***/ }),

/***/ 31652:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(48624);
var anObject = __webpack_require__(98514);
var getMethod = __webpack_require__(54462);

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ 16133:
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ 25474:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toLength = __webpack_require__(1403);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 85954:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(7931);
var isCallable = __webpack_require__(92163);
var hasOwn = __webpack_require__(21325);
var DESCRIPTORS = __webpack_require__(46372);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(30233).CONFIGURABLE);
var inspectSource = __webpack_require__(22089);
var InternalStateModule = __webpack_require__(3987);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (String(name).slice(0, 7) === 'Symbol(') {
    name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 855:
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es-x/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 28603:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(98514);
var definePropertiesModule = __webpack_require__(98857);
var enumBugKeys = __webpack_require__(46606);
var hiddenKeys = __webpack_require__(43730);
var html = __webpack_require__(79150);
var documentCreateElement = __webpack_require__(94193);
var sharedKey = __webpack_require__(1320);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es-x/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ 98857:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(46372);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(58814);
var definePropertyModule = __webpack_require__(16572);
var anObject = __webpack_require__(98514);
var toIndexedObject = __webpack_require__(19130);
var objectKeys = __webpack_require__(5390);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es-x/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ 16572:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(46372);
var IE8_DOM_DEFINE = __webpack_require__(53202);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(58814);
var anObject = __webpack_require__(98514);
var toPropertyKey = __webpack_require__(41973);

var $TypeError = TypeError;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 99206:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(46372);
var call = __webpack_require__(48624);
var propertyIsEnumerableModule = __webpack_require__(42251);
var createPropertyDescriptor = __webpack_require__(48602);
var toIndexedObject = __webpack_require__(19130);
var toPropertyKey = __webpack_require__(41973);
var hasOwn = __webpack_require__(21325);
var IE8_DOM_DEFINE = __webpack_require__(53202);

// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 83311:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(51429);
var enumBugKeys = __webpack_require__(46606);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 50395:
/***/ ((__unused_webpack_module, exports) => {

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 96350:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasOwn = __webpack_require__(21325);
var isCallable = __webpack_require__(92163);
var toObject = __webpack_require__(77410);
var sharedKey = __webpack_require__(1320);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(28165);

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es-x/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 3071:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(73074);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 51429:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(73074);
var hasOwn = __webpack_require__(21325);
var toIndexedObject = __webpack_require__(19130);
var indexOf = (__webpack_require__(64465).indexOf);
var hiddenKeys = __webpack_require__(43730);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 5390:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(51429);
var enumBugKeys = __webpack_require__(46606);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es-x/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 42251:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 50744:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-proto -- safe */
var uncurryThis = __webpack_require__(73074);
var anObject = __webpack_require__(98514);
var aPossiblePrototype = __webpack_require__(81402);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es-x/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
    setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ 29207:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(48624);
var isCallable = __webpack_require__(92163);
var isObject = __webpack_require__(23041);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 20810:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(39997);
var uncurryThis = __webpack_require__(73074);
var getOwnPropertyNamesModule = __webpack_require__(83311);
var getOwnPropertySymbolsModule = __webpack_require__(50395);
var anObject = __webpack_require__(98514);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 36061:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(98514);

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.hasIndices) result += 'd';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.unicodeSets) result += 'v';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ 21029:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(48624);
var hasOwn = __webpack_require__(21325);
var isPrototypeOf = __webpack_require__(3071);
var regExpFlags = __webpack_require__(36061);

var RegExpPrototype = RegExp.prototype;

module.exports = function (R) {
  var flags = R.flags;
  return flags === undefined && !('flags' in RegExpPrototype) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype, R)
    ? call(regExpFlags, R) : flags;
};


/***/ }),

/***/ 65727:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isNullOrUndefined = __webpack_require__(57900);

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 32209:
/***/ ((module) => {

// `SameValueZero` abstract operation
// https://tc39.es/ecma262/#sec-samevaluezero
module.exports = function (x, y) {
  // eslint-disable-next-line no-self-compare -- NaN check
  return x === y || x != x && y != y;
};


/***/ }),

/***/ 1320:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(78519);
var uid = __webpack_require__(76004);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 12846:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(63406);
var defineGlobalProperty = __webpack_require__(95861);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;


/***/ }),

/***/ 78519:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IS_PURE = __webpack_require__(2884);
var store = __webpack_require__(12846);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.25.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2014-2022 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.25.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 64499:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(98514);
var aConstructor = __webpack_require__(17321);
var isNullOrUndefined = __webpack_require__(57900);
var wellKnownSymbol = __webpack_require__(4259);

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
};


/***/ }),

/***/ 73874:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es-x/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(55111);
var fails = __webpack_require__(7931);

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 63828:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(70400);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 19130:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(52170);
var requireObjectCoercible = __webpack_require__(65727);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 70400:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trunc = __webpack_require__(855);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 1403:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(70400);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 77410:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var requireObjectCoercible = __webpack_require__(65727);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 63170:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPositiveInteger = __webpack_require__(64064);

var $RangeError = RangeError;

module.exports = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw $RangeError('Wrong offset');
  return offset;
};


/***/ }),

/***/ 64064:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(70400);

var $RangeError = RangeError;

module.exports = function (it) {
  var result = toIntegerOrInfinity(it);
  if (result < 0) throw $RangeError("The argument can't be less than 0");
  return result;
};


/***/ }),

/***/ 18732:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(48624);
var isObject = __webpack_require__(23041);
var isSymbol = __webpack_require__(85666);
var getMethod = __webpack_require__(54462);
var ordinaryToPrimitive = __webpack_require__(29207);
var wellKnownSymbol = __webpack_require__(4259);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 41973:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPrimitive = __webpack_require__(18732);
var isSymbol = __webpack_require__(85666);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 98216:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(4259);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 24473:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(47298);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 40368:
/***/ ((module) => {

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 76004:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(73074);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 99525:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es-x/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(73874);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 58814:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(46372);
var fails = __webpack_require__(7931);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});


/***/ }),

/***/ 24617:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(63406);
var isCallable = __webpack_require__(92163);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ 4259:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(63406);
var shared = __webpack_require__(78519);
var hasOwn = __webpack_require__(21325);
var uid = __webpack_require__(76004);
var NATIVE_SYMBOL = __webpack_require__(73874);
var USE_SYMBOL_AS_UID = __webpack_require__(99525);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var symbolFor = Symbol && Symbol['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    var description = 'Symbol.' + name;
    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 90943:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var $includes = (__webpack_require__(64465).includes);
var fails = __webpack_require__(7931);
var addToUnscopables = __webpack_require__(78875);

// FF99+ bug
var BROKEN_ON_SPARSE = fails(function () {
  return !Array(1).includes();
});

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ 88932:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var call = __webpack_require__(48624);
var uncurryThis = __webpack_require__(73074);
var requireObjectCoercible = __webpack_require__(65727);
var isCallable = __webpack_require__(92163);
var isNullOrUndefined = __webpack_require__(57900);
var isRegExp = __webpack_require__(33948);
var toString = __webpack_require__(24473);
var getMethod = __webpack_require__(54462);
var getRegExpFlags = __webpack_require__(21029);
var getSubstitution = __webpack_require__(24053);
var wellKnownSymbol = __webpack_require__(4259);
var IS_PURE = __webpack_require__(2884);

var REPLACE = wellKnownSymbol('replace');
var $TypeError = TypeError;
var indexOf = uncurryThis(''.indexOf);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);
var max = Math.max;

var stringIndexOf = function (string, searchValue, fromIndex) {
  if (fromIndex > string.length) return -1;
  if (searchValue === '') return fromIndex;
  return indexOf(string, searchValue, fromIndex);
};

// `String.prototype.replaceAll` method
// https://tc39.es/ecma262/#sec-string.prototype.replaceall
$({ target: 'String', proto: true }, {
  replaceAll: function replaceAll(searchValue, replaceValue) {
    var O = requireObjectCoercible(this);
    var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, replacement;
    var position = 0;
    var endOfLastMatch = 0;
    var result = '';
    if (!isNullOrUndefined(searchValue)) {
      IS_REG_EXP = isRegExp(searchValue);
      if (IS_REG_EXP) {
        flags = toString(requireObjectCoercible(getRegExpFlags(searchValue)));
        if (!~indexOf(flags, 'g')) throw $TypeError('`.replaceAll` does not allow non-global regexes');
      }
      replacer = getMethod(searchValue, REPLACE);
      if (replacer) {
        return call(replacer, searchValue, O, replaceValue);
      } else if (IS_PURE && IS_REG_EXP) {
        return replace(toString(O), searchValue, replaceValue);
      }
    }
    string = toString(O);
    searchString = toString(searchValue);
    functionalReplace = isCallable(replaceValue);
    if (!functionalReplace) replaceValue = toString(replaceValue);
    searchLength = searchString.length;
    advanceBy = max(1, searchLength);
    position = stringIndexOf(string, searchString, 0);
    while (position !== -1) {
      replacement = functionalReplace
        ? toString(replaceValue(searchString, position, string))
        : getSubstitution(searchString, string, position, [], undefined, replaceValue);
      result += stringSlice(string, endOfLastMatch, position) + replacement;
      endOfLastMatch = position + searchLength;
      position = stringIndexOf(string, searchString, position + advanceBy);
    }
    if (endOfLastMatch < string.length) {
      result += stringSlice(string, endOfLastMatch);
    }
    return result;
  }
});


/***/ }),

/***/ 57168:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(63406);
var call = __webpack_require__(48624);
var ArrayBufferViewCore = __webpack_require__(19547);
var lengthOfArrayLike = __webpack_require__(25474);
var toOffset = __webpack_require__(63170);
var toIndexedObject = __webpack_require__(77410);
var fails = __webpack_require__(7931);

var RangeError = global.RangeError;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

var WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS = !fails(function () {
  // eslint-disable-next-line es-x/no-typed-arrays -- required for testing
  var array = new Uint8ClampedArray(2);
  call($set, array, { length: 1, 0: 3 }, 1);
  return array[1] !== 3;
});

// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other
var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function () {
  var array = new Int8Array(2);
  array.set(1);
  array.set('2', 1);
  return array[0] !== 0 || array[1] !== 2;
});

// `%TypedArray%.prototype.set` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod('set', function set(arrayLike /* , offset */) {
  aTypedArray(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var src = toIndexedObject(arrayLike);
  if (WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS) return call($set, this, src, offset);
  var length = this.length;
  var len = lengthOfArrayLike(src);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, !WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);


/***/ }),

/***/ 13929:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var deleteAll = __webpack_require__(50011);

// `Map.prototype.deleteAll` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  deleteAll: deleteAll
});


/***/ }),

/***/ 57851:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var anObject = __webpack_require__(98514);
var bind = __webpack_require__(98626);
var getMapIterator = __webpack_require__(51285);
var iterate = __webpack_require__(67523);

// `Map.prototype.every` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  every: function every(callbackfn /* , thisArg */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return !iterate(iterator, function (key, value, stop) {
      if (!boundFunction(value, key, map)) return stop();
    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).stopped;
  }
});


/***/ }),

/***/ 63633:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var getBuiltIn = __webpack_require__(39997);
var bind = __webpack_require__(98626);
var call = __webpack_require__(48624);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);
var speciesConstructor = __webpack_require__(64499);
var getMapIterator = __webpack_require__(51285);
var iterate = __webpack_require__(67523);

// `Map.prototype.filter` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  filter: function filter(callbackfn /* , thisArg */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
    var setter = aCallable(newMap.set);
    iterate(iterator, function (key, value) {
      if (boundFunction(value, key, map)) call(setter, newMap, key, value);
    }, { AS_ENTRIES: true, IS_ITERATOR: true });
    return newMap;
  }
});


/***/ }),

/***/ 67515:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var anObject = __webpack_require__(98514);
var bind = __webpack_require__(98626);
var getMapIterator = __webpack_require__(51285);
var iterate = __webpack_require__(67523);

// `Map.prototype.findKey` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  findKey: function findKey(callbackfn /* , thisArg */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return iterate(iterator, function (key, value, stop) {
      if (boundFunction(value, key, map)) return stop(key);
    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).result;
  }
});


/***/ }),

/***/ 81652:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var anObject = __webpack_require__(98514);
var bind = __webpack_require__(98626);
var getMapIterator = __webpack_require__(51285);
var iterate = __webpack_require__(67523);

// `Map.prototype.find` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  find: function find(callbackfn /* , thisArg */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return iterate(iterator, function (key, value, stop) {
      if (boundFunction(value, key, map)) return stop(value);
    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).result;
  }
});


/***/ }),

/***/ 68034:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var anObject = __webpack_require__(98514);
var getMapIterator = __webpack_require__(51285);
var sameValueZero = __webpack_require__(32209);
var iterate = __webpack_require__(67523);

// `Map.prototype.includes` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  includes: function includes(searchElement) {
    return iterate(getMapIterator(anObject(this)), function (key, value, stop) {
      if (sameValueZero(value, searchElement)) return stop();
    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).stopped;
  }
});


/***/ }),

/***/ 61480:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var anObject = __webpack_require__(98514);
var getMapIterator = __webpack_require__(51285);
var iterate = __webpack_require__(67523);

// `Map.prototype.keyOf` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  keyOf: function keyOf(searchElement) {
    return iterate(getMapIterator(anObject(this)), function (key, value, stop) {
      if (value === searchElement) return stop(key);
    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).result;
  }
});


/***/ }),

/***/ 59027:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var getBuiltIn = __webpack_require__(39997);
var bind = __webpack_require__(98626);
var call = __webpack_require__(48624);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);
var speciesConstructor = __webpack_require__(64499);
var getMapIterator = __webpack_require__(51285);
var iterate = __webpack_require__(67523);

// `Map.prototype.mapKeys` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  mapKeys: function mapKeys(callbackfn /* , thisArg */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
    var setter = aCallable(newMap.set);
    iterate(iterator, function (key, value) {
      call(setter, newMap, boundFunction(value, key, map), value);
    }, { AS_ENTRIES: true, IS_ITERATOR: true });
    return newMap;
  }
});


/***/ }),

/***/ 35739:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var getBuiltIn = __webpack_require__(39997);
var bind = __webpack_require__(98626);
var call = __webpack_require__(48624);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);
var speciesConstructor = __webpack_require__(64499);
var getMapIterator = __webpack_require__(51285);
var iterate = __webpack_require__(67523);

// `Map.prototype.mapValues` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  mapValues: function mapValues(callbackfn /* , thisArg */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
    var setter = aCallable(newMap.set);
    iterate(iterator, function (key, value) {
      call(setter, newMap, key, boundFunction(value, key, map));
    }, { AS_ENTRIES: true, IS_ITERATOR: true });
    return newMap;
  }
});


/***/ }),

/***/ 99283:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);
var iterate = __webpack_require__(67523);

// `Map.prototype.merge` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, arity: 1, forced: true }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  merge: function merge(iterable /* ...iterables */) {
    var map = anObject(this);
    var setter = aCallable(map.set);
    var argumentsLength = arguments.length;
    var i = 0;
    while (i < argumentsLength) {
      iterate(arguments[i++], setter, { that: map, AS_ENTRIES: true });
    }
    return map;
  }
});


/***/ }),

/***/ 4473:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var anObject = __webpack_require__(98514);
var aCallable = __webpack_require__(38146);
var getMapIterator = __webpack_require__(51285);
var iterate = __webpack_require__(67523);

var $TypeError = TypeError;

// `Map.prototype.reduce` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? undefined : arguments[1];
    aCallable(callbackfn);
    iterate(iterator, function (key, value) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = callbackfn(accumulator, value, key, map);
      }
    }, { AS_ENTRIES: true, IS_ITERATOR: true });
    if (noInitial) throw $TypeError('Reduce of empty map with no initial value');
    return accumulator;
  }
});


/***/ }),

/***/ 90989:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var anObject = __webpack_require__(98514);
var bind = __webpack_require__(98626);
var getMapIterator = __webpack_require__(51285);
var iterate = __webpack_require__(67523);

// `Set.prototype.some` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  some: function some(callbackfn /* , thisArg */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return iterate(iterator, function (key, value, stop) {
      if (boundFunction(value, key, map)) return stop();
    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).stopped;
  }
});


/***/ }),

/***/ 17194:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var call = __webpack_require__(48624);
var anObject = __webpack_require__(98514);
var aCallable = __webpack_require__(38146);

var $TypeError = TypeError;

// `Set.prototype.update` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  update: function update(key, callback /* , thunk */) {
    var map = anObject(this);
    var get = aCallable(map.get);
    var has = aCallable(map.has);
    var set = aCallable(map.set);
    var length = arguments.length;
    aCallable(callback);
    var isPresentInMap = call(has, map, key);
    if (!isPresentInMap && length < 3) {
      throw $TypeError('Updating absent value');
    }
    var value = isPresentInMap ? call(get, map, key) : aCallable(length > 2 ? arguments[2] : undefined)(key, map);
    call(set, map, key, callback(value, key, map));
    return map;
  }
});


/***/ }),

/***/ 76063:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var addAll = __webpack_require__(85425);

// `Set.prototype.addAll` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  addAll: addAll
});


/***/ }),

/***/ 22336:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var deleteAll = __webpack_require__(50011);

// `Set.prototype.deleteAll` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  deleteAll: deleteAll
});


/***/ }),

/***/ 47226:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var getBuiltIn = __webpack_require__(39997);
var call = __webpack_require__(48624);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);
var speciesConstructor = __webpack_require__(64499);
var iterate = __webpack_require__(67523);

// `Set.prototype.difference` method
// https://github.com/tc39/proposal-set-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  difference: function difference(iterable) {
    var set = anObject(this);
    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
    var remover = aCallable(newSet['delete']);
    iterate(iterable, function (value) {
      call(remover, newSet, value);
    });
    return newSet;
  }
});


/***/ }),

/***/ 80641:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var anObject = __webpack_require__(98514);
var bind = __webpack_require__(98626);
var getSetIterator = __webpack_require__(7762);
var iterate = __webpack_require__(67523);

// `Set.prototype.every` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  every: function every(callbackfn /* , thisArg */) {
    var set = anObject(this);
    var iterator = getSetIterator(set);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return !iterate(iterator, function (value, stop) {
      if (!boundFunction(value, value, set)) return stop();
    }, { IS_ITERATOR: true, INTERRUPTED: true }).stopped;
  }
});


/***/ }),

/***/ 35299:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var getBuiltIn = __webpack_require__(39997);
var call = __webpack_require__(48624);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);
var bind = __webpack_require__(98626);
var speciesConstructor = __webpack_require__(64499);
var getSetIterator = __webpack_require__(7762);
var iterate = __webpack_require__(67523);

// `Set.prototype.filter` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  filter: function filter(callbackfn /* , thisArg */) {
    var set = anObject(this);
    var iterator = getSetIterator(set);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();
    var adder = aCallable(newSet.add);
    iterate(iterator, function (value) {
      if (boundFunction(value, value, set)) call(adder, newSet, value);
    }, { IS_ITERATOR: true });
    return newSet;
  }
});


/***/ }),

/***/ 12980:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var anObject = __webpack_require__(98514);
var bind = __webpack_require__(98626);
var getSetIterator = __webpack_require__(7762);
var iterate = __webpack_require__(67523);

// `Set.prototype.find` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  find: function find(callbackfn /* , thisArg */) {
    var set = anObject(this);
    var iterator = getSetIterator(set);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return iterate(iterator, function (value, stop) {
      if (boundFunction(value, value, set)) return stop(value);
    }, { IS_ITERATOR: true, INTERRUPTED: true }).result;
  }
});


/***/ }),

/***/ 72801:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var getBuiltIn = __webpack_require__(39997);
var call = __webpack_require__(48624);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);
var speciesConstructor = __webpack_require__(64499);
var iterate = __webpack_require__(67523);

// `Set.prototype.intersection` method
// https://github.com/tc39/proposal-set-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  intersection: function intersection(iterable) {
    var set = anObject(this);
    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();
    var hasCheck = aCallable(set.has);
    var adder = aCallable(newSet.add);
    iterate(iterable, function (value) {
      if (call(hasCheck, set, value)) call(adder, newSet, value);
    });
    return newSet;
  }
});


/***/ }),

/***/ 67396:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var call = __webpack_require__(48624);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);
var iterate = __webpack_require__(67523);

// `Set.prototype.isDisjointFrom` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isDisjointFrom
$({ target: 'Set', proto: true, real: true, forced: true }, {
  isDisjointFrom: function isDisjointFrom(iterable) {
    var set = anObject(this);
    var hasCheck = aCallable(set.has);
    return !iterate(iterable, function (value, stop) {
      if (call(hasCheck, set, value) === true) return stop();
    }, { INTERRUPTED: true }).stopped;
  }
});


/***/ }),

/***/ 26600:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var getBuiltIn = __webpack_require__(39997);
var call = __webpack_require__(48624);
var aCallable = __webpack_require__(38146);
var isCallable = __webpack_require__(92163);
var anObject = __webpack_require__(98514);
var getIterator = __webpack_require__(11570);
var iterate = __webpack_require__(67523);

// `Set.prototype.isSubsetOf` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSubsetOf
$({ target: 'Set', proto: true, real: true, forced: true }, {
  isSubsetOf: function isSubsetOf(iterable) {
    var iterator = getIterator(this);
    var otherSet = anObject(iterable);
    var hasCheck = otherSet.has;
    if (!isCallable(hasCheck)) {
      otherSet = new (getBuiltIn('Set'))(iterable);
      hasCheck = aCallable(otherSet.has);
    }
    return !iterate(iterator, function (value, stop) {
      if (call(hasCheck, otherSet, value) === false) return stop();
    }, { IS_ITERATOR: true, INTERRUPTED: true }).stopped;
  }
});


/***/ }),

/***/ 59503:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var call = __webpack_require__(48624);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);
var iterate = __webpack_require__(67523);

// `Set.prototype.isSupersetOf` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSupersetOf
$({ target: 'Set', proto: true, real: true, forced: true }, {
  isSupersetOf: function isSupersetOf(iterable) {
    var set = anObject(this);
    var hasCheck = aCallable(set.has);
    return !iterate(iterable, function (value, stop) {
      if (call(hasCheck, set, value) === false) return stop();
    }, { INTERRUPTED: true }).stopped;
  }
});


/***/ }),

/***/ 76119:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var uncurryThis = __webpack_require__(73074);
var anObject = __webpack_require__(98514);
var toString = __webpack_require__(24473);
var getSetIterator = __webpack_require__(7762);
var iterate = __webpack_require__(67523);

var arrayJoin = uncurryThis([].join);
var push = [].push;

// `Set.prototype.join` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  join: function join(separator) {
    var set = anObject(this);
    var iterator = getSetIterator(set);
    var sep = separator === undefined ? ',' : toString(separator);
    var result = [];
    iterate(iterator, push, { that: result, IS_ITERATOR: true });
    return arrayJoin(result, sep);
  }
});


/***/ }),

/***/ 10608:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var getBuiltIn = __webpack_require__(39997);
var bind = __webpack_require__(98626);
var call = __webpack_require__(48624);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);
var speciesConstructor = __webpack_require__(64499);
var getSetIterator = __webpack_require__(7762);
var iterate = __webpack_require__(67523);

// `Set.prototype.map` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  map: function map(callbackfn /* , thisArg */) {
    var set = anObject(this);
    var iterator = getSetIterator(set);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();
    var adder = aCallable(newSet.add);
    iterate(iterator, function (value) {
      call(adder, newSet, boundFunction(value, value, set));
    }, { IS_ITERATOR: true });
    return newSet;
  }
});


/***/ }),

/***/ 44061:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);
var getSetIterator = __webpack_require__(7762);
var iterate = __webpack_require__(67523);

var $TypeError = TypeError;

// `Set.prototype.reduce` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    var set = anObject(this);
    var iterator = getSetIterator(set);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? undefined : arguments[1];
    aCallable(callbackfn);
    iterate(iterator, function (value) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = callbackfn(accumulator, value, value, set);
      }
    }, { IS_ITERATOR: true });
    if (noInitial) throw $TypeError('Reduce of empty set with no initial value');
    return accumulator;
  }
});


/***/ }),

/***/ 42229:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var anObject = __webpack_require__(98514);
var bind = __webpack_require__(98626);
var getSetIterator = __webpack_require__(7762);
var iterate = __webpack_require__(67523);

// `Set.prototype.some` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  some: function some(callbackfn /* , thisArg */) {
    var set = anObject(this);
    var iterator = getSetIterator(set);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return iterate(iterator, function (value, stop) {
      if (boundFunction(value, value, set)) return stop();
    }, { IS_ITERATOR: true, INTERRUPTED: true }).stopped;
  }
});


/***/ }),

/***/ 39055:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var getBuiltIn = __webpack_require__(39997);
var call = __webpack_require__(48624);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);
var speciesConstructor = __webpack_require__(64499);
var iterate = __webpack_require__(67523);

// `Set.prototype.symmetricDifference` method
// https://github.com/tc39/proposal-set-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  symmetricDifference: function symmetricDifference(iterable) {
    var set = anObject(this);
    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
    var remover = aCallable(newSet['delete']);
    var adder = aCallable(newSet.add);
    iterate(iterable, function (value) {
      call(remover, newSet, value) || call(adder, newSet, value);
    });
    return newSet;
  }
});


/***/ }),

/***/ 3286:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(65942);
var getBuiltIn = __webpack_require__(39997);
var aCallable = __webpack_require__(38146);
var anObject = __webpack_require__(98514);
var speciesConstructor = __webpack_require__(64499);
var iterate = __webpack_require__(67523);

// `Set.prototype.union` method
// https://github.com/tc39/proposal-set-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  union: function union(iterable) {
    var set = anObject(this);
    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
    iterate(iterable, aCallable(newSet.add), { that: newSet });
    return newSet;
  }
});


/***/ }),

/***/ 81625:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove from `core-js@4`
__webpack_require__(88932);


/***/ }),

/***/ 8118:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native crypto in web worker (Browser)
	    if (typeof self !== 'undefined' && self.crypto) {
	        crypto = self.crypto;
	    }

	    // Native crypto from worker
	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
	        crypto = globalThis.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.crypto) {
	        crypto = __webpack_require__.g.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __webpack_require__(42480);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }());

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var j = 0; j < thatSigBytes; j += 4) {
	                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),

/***/ 66172:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(8118));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),

/***/ 28975:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(8118));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),

/***/ 87553:
/***/ (function(__unused_webpack_module, exports) {

!function(g,c){ true?c(exports):0}(this,function(g){const c=Symbol("newer"),e=Symbol("older");class n{constructor(a,b){typeof a!=="number"&&(b=a,a=0),this.size=0,this.limit=a,this.oldest=this.newest=void 0,this._keymap=new Map(),b&&(this.assign(b),a<1&&(this.limit=this.size))}_markEntryAsUsed(a){if(a===this.newest)return;a[c]&&(a===this.oldest&&(this.oldest=a[c]),a[c][e]=a[e]),a[e]&&(a[e][c]=a[c]),a[c]=void 0,a[e]=this.newest,this.newest&&(this.newest[c]=a),this.newest=a}assign(a){let b,d=this.limit||Number.MAX_VALUE;this._keymap.clear();let m=a[Symbol.iterator]();for(let h=m.next();!h.done;h=m.next()){let f=new l(h.value[0],h.value[1]);this._keymap.set(f.key,f),b?(b[c]=f,f[e]=b):this.oldest=f,b=f;if(d--==0)throw new Error("overflow")}this.newest=b,this.size=this._keymap.size}get(a){var b=this._keymap.get(a);return b?(this._markEntryAsUsed(b),b.value):void 0}set(a,b){var d=this._keymap.get(a);return d?(d.value=b,this._markEntryAsUsed(d),this):(this._keymap.set(a,d=new l(a,b)),this.newest?(this.newest[c]=d,d[e]=this.newest):this.oldest=d,this.newest=d,++this.size,this.size>this.limit&&this.shift(),this)}shift(){var a=this.oldest;if(a)return this.oldest[c]?(this.oldest=this.oldest[c],this.oldest[e]=void 0):(this.oldest=void 0,this.newest=void 0),a[c]=a[e]=void 0,this._keymap.delete(a.key),--this.size,[a.key,a.value]}find(a){let b=this._keymap.get(a);return b?b.value:void 0}has(a){return this._keymap.has(a)}delete(a){var b=this._keymap.get(a);return b?(this._keymap.delete(b.key),b[c]&&b[e]?(b[e][c]=b[c],b[c][e]=b[e]):b[c]?(b[c][e]=void 0,this.oldest=b[c]):b[e]?(b[e][c]=void 0,this.newest=b[e]):this.oldest=this.newest=void 0,this.size--,b.value):void 0}clear(){this.oldest=this.newest=void 0,this.size=0,this._keymap.clear()}keys(){return new j(this.oldest)}values(){return new k(this.oldest)}entries(){return this}[Symbol.iterator](){return new i(this.oldest)}forEach(a,b){typeof b!=="object"&&(b=this);let d=this.oldest;for(;d;)a.call(b,d.value,d.key,this),d=d[c]}toJSON(){for(var a=new Array(this.size),b=0,d=this.oldest;d;)a[b++]={key:d.key,value:d.value},d=d[c];return a}toString(){for(var a="",b=this.oldest;b;)a+=String(b.key)+":"+b.value,b=b[c],b&&(a+=" < ");return a}}g.LRUMap=n;function l(a,b){this.key=a,this.value=b,this[c]=void 0,this[e]=void 0}function i(a){this.entry=a}i.prototype[Symbol.iterator]=function(){return this},i.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:[a.key,a.value]}):{done:!0,value:void 0}};function j(a){this.entry=a}j.prototype[Symbol.iterator]=function(){return this},j.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.key}):{done:!0,value:void 0}};function k(a){this.entry=a}k.prototype[Symbol.iterator]=function(){return this},k.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.value}):{done:!0,value:void 0}}});


/***/ }),

/***/ 2860:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ZP": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports ucs2decode, ucs2encode, decode, encode, toASCII, toUnicode */


/** Highest positive signed 32-bit float value */
const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128; // 0x80
const delimiter = '-'; // '\x2D'

/** Regular expressions */
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
const errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	const result = [];
	let length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	const parts = string.split('@');
	let result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	const labels = string.split('.');
	const encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	const output = [];
	let counter = 0;
	const length = string.length;
	while (counter < length) {
		const value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			const extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
const ucs2encode = array => String.fromCodePoint(...array);

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
const basicToDigit = function(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
const digitToBasic = function(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
const adapt = function(delta, numPoints, firstTime) {
	let k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
const decode = function(input) {
	// Don't use UCS-2.
	const output = [];
	const inputLength = input.length;
	let i = 0;
	let n = initialN;
	let bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	let basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (let j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		let oldi = i;
		for (let w = 1, k = base; /* no condition */; k += base) {

			if (index >= inputLength) {
				error('invalid-input');
			}

			const digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error('overflow');
			}

			i += digit * w;
			const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

			if (digit < t) {
				break;
			}

			const baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error('overflow');
			}

			w *= baseMinusT;

		}

		const out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);

	}

	return String.fromCodePoint(...output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
const encode = function(input) {
	const output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	let inputLength = input.length;

	// Initialize the state.
	let n = initialN;
	let delta = 0;
	let bias = initialBias;

	// Handle the basic code points.
	for (const currentValue of input) {
		if (currentValue < 0x80) {
			output.push(stringFromCharCode(currentValue));
		}
	}

	let basicLength = output.length;
	let handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		let m = maxInt;
		for (const currentValue of input) {
			if (currentValue >= n && currentValue < m) {
				m = currentValue;
			}
		}

		// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
		// but guard against overflow.
		const handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		for (const currentValue of input) {
			if (currentValue < n && ++delta > maxInt) {
				error('overflow');
			}
			if (currentValue == n) {
				// Represent delta as a generalized variable-length integer.
				let q = delta;
				for (let k = base; /* no condition */; k += base) {
					const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
					if (q < t) {
						break;
					}
					const qMinusT = q - t;
					const baseMinusT = base - t;
					output.push(
						stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
					);
					q = floor(qMinusT / baseMinusT);
				}

				output.push(stringFromCharCode(digitToBasic(q, 0)));
				bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
				delta = 0;
				++handledCPCount;
			}
		}

		++delta;
		++n;

	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
const toUnicode = function(input) {
	return mapDomain(input, function(string) {
		return regexPunycode.test(string)
			? decode(string.slice(4).toLowerCase())
			: string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
const toASCII = function(input) {
	return mapDomain(input, function(string) {
		return regexNonASCII.test(string)
			? 'xn--' + encode(string)
			: string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
const punycode = {
	/**
	 * A string representing the current Punycode.js version number.
	 * @memberOf punycode
	 * @type String
	 */
	'version': '2.1.0',
	/**
	 * An object of methods to convert from JavaScript's internal character
	 * representation (UCS-2) to Unicode code points, and back.
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode
	 * @type Object
	 */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (punycode);


/***/ }),

/***/ 9182:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),

/***/ 99265:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ }),

/***/ 58528:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.decode = exports.parse = __webpack_require__(9182);
exports.encode = exports.stringify = __webpack_require__(99265);


/***/ }),

/***/ 29473:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));


/***/ }),

/***/ 83548:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(29473);
var util = __webpack_require__(46729);

__webpack_unused_export__ = urlParse;
__webpack_unused_export__ = urlResolve;
__webpack_unused_export__ = urlResolveObject;
__webpack_unused_export__ = urlFormat;

__webpack_unused_export__ = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(58528);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),

/***/ 46729:
/***/ ((module) => {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),

/***/ 53679:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (module) {
  /* webextension-polyfill - v0.10.0 - Fri Aug 12 2022 19:42:44 */

  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */

  /* vim: set sts=2 sw=2 et tw=80: */

  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  "use strict";

  if (!globalThis.chrome?.runtime?.id) {
    throw new Error("This script should only be loaded in a browser extension.");
  }

  if (typeof globalThis.browser === "undefined" || Object.getPrototypeOf(globalThis.browser) !== Object.prototype) {
    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received."; // Wrapping the bulk of this polyfill in a one-time-use function is a minor
    // optimization for Firefox. Since Spidermonkey does not fully parse the
    // contents of a function until the first time it's called, and since it will
    // never actually need to be called, this allows the polyfill to be included
    // in Firefox nearly for free.

    const wrapAPIs = extensionAPIs => {
      // NOTE: apiMetadata is associated to the content of the api-metadata.json file
      // at build time by replacing the following "include" with the content of the
      // JSON file.
      const apiMetadata = {
        "alarms": {
          "clear": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "clearAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "get": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "bookmarks": {
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getChildren": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getRecent": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getSubTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTree": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "browserAction": {
          "disable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "enable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "getBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getBadgeText": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "openPopup": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setBadgeText": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "browsingData": {
          "remove": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "removeCache": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCookies": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeDownloads": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFormData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeHistory": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeLocalStorage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePasswords": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePluginData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "settings": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "commands": {
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "contextMenus": {
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "cookies": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAllCookieStores": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "set": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "devtools": {
          "inspectedWindow": {
            "eval": {
              "minArgs": 1,
              "maxArgs": 2,
              "singleCallbackArg": false
            }
          },
          "panels": {
            "create": {
              "minArgs": 3,
              "maxArgs": 3,
              "singleCallbackArg": true
            },
            "elements": {
              "createSidebarPane": {
                "minArgs": 1,
                "maxArgs": 1
              }
            }
          }
        },
        "downloads": {
          "cancel": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "download": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "erase": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFileIcon": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "open": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "pause": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFile": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "resume": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "extension": {
          "isAllowedFileSchemeAccess": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "isAllowedIncognitoAccess": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "history": {
          "addUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "deleteRange": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getVisits": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "i18n": {
          "detectLanguage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAcceptLanguages": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "identity": {
          "launchWebAuthFlow": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "idle": {
          "queryState": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "management": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getSelf": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setEnabled": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "uninstallSelf": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "notifications": {
          "clear": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPermissionLevel": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "pageAction": {
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "hide": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "permissions": {
          "contains": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "request": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "runtime": {
          "getBackgroundPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPlatformInfo": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "openOptionsPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "requestUpdateCheck": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "sendMessage": {
            "minArgs": 1,
            "maxArgs": 3
          },
          "sendNativeMessage": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "setUninstallURL": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "sessions": {
          "getDevices": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getRecentlyClosed": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "restore": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "storage": {
          "local": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          },
          "managed": {
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            }
          },
          "sync": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          }
        },
        "tabs": {
          "captureVisibleTab": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "detectLanguage": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "discard": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "duplicate": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "executeScript": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getZoom": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getZoomSettings": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goBack": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goForward": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "highlight": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "insertCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "query": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "reload": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "sendMessage": {
            "minArgs": 2,
            "maxArgs": 3
          },
          "setZoom": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "setZoomSettings": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "update": {
            "minArgs": 1,
            "maxArgs": 2
          }
        },
        "topSites": {
          "get": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "webNavigation": {
          "getAllFrames": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFrame": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "webRequest": {
          "handlerBehaviorChanged": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "windows": {
          "create": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getLastFocused": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        }
      };

      if (Object.keys(apiMetadata).length === 0) {
        throw new Error("api-metadata.json has not been included in browser-polyfill");
      }
      /**
       * A WeakMap subclass which creates and stores a value for any key which does
       * not exist when accessed, but behaves exactly as an ordinary WeakMap
       * otherwise.
       *
       * @param {function} createItem
       *        A function which will be called in order to create the value for any
       *        key which does not exist, the first time it is accessed. The
       *        function receives, as its only argument, the key being created.
       */


      class DefaultWeakMap extends WeakMap {
        constructor(createItem, items = undefined) {
          super(items);
          this.createItem = createItem;
        }

        get(key) {
          if (!this.has(key)) {
            this.set(key, this.createItem(key));
          }

          return super.get(key);
        }

      }
      /**
       * Returns true if the given object is an object with a `then` method, and can
       * therefore be assumed to behave as a Promise.
       *
       * @param {*} value The value to test.
       * @returns {boolean} True if the value is thenable.
       */


      const isThenable = value => {
        return value && typeof value === "object" && typeof value.then === "function";
      };
      /**
       * Creates and returns a function which, when called, will resolve or reject
       * the given promise based on how it is called:
       *
       * - If, when called, `chrome.runtime.lastError` contains a non-null object,
       *   the promise is rejected with that value.
       * - If the function is called with exactly one argument, the promise is
       *   resolved to that value.
       * - Otherwise, the promise is resolved to an array containing all of the
       *   function's arguments.
       *
       * @param {object} promise
       *        An object containing the resolution and rejection functions of a
       *        promise.
       * @param {function} promise.resolve
       *        The promise's resolution function.
       * @param {function} promise.reject
       *        The promise's rejection function.
       * @param {object} metadata
       *        Metadata about the wrapped method which has created the callback.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function}
       *        The generated callback function.
       */


      const makeCallback = (promise, metadata) => {
        return (...callbackArgs) => {
          if (extensionAPIs.runtime.lastError) {
            promise.reject(new Error(extensionAPIs.runtime.lastError.message));
          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
            promise.resolve(callbackArgs[0]);
          } else {
            promise.resolve(callbackArgs);
          }
        };
      };

      const pluralizeArguments = numArgs => numArgs == 1 ? "argument" : "arguments";
      /**
       * Creates a wrapper function for a method with the given name and metadata.
       *
       * @param {string} name
       *        The name of the method which is being wrapped.
       * @param {object} metadata
       *        Metadata about the method being wrapped.
       * @param {integer} metadata.minArgs
       *        The minimum number of arguments which must be passed to the
       *        function. If called with fewer than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {integer} metadata.maxArgs
       *        The maximum number of arguments which may be passed to the
       *        function. If called with more than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function(object, ...*)}
       *       The generated wrapper function.
       */


      const wrapAsyncFunction = (name, metadata) => {
        return function asyncFunctionWrapper(target, ...args) {
          if (args.length < metadata.minArgs) {
            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
          }

          if (args.length > metadata.maxArgs) {
            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
          }

          return new Promise((resolve, reject) => {
            if (metadata.fallbackToNoCallback) {
              // This API method has currently no callback on Chrome, but it return a promise on Firefox,
              // and so the polyfill will try to call it with a callback first, and it will fallback
              // to not passing the callback if the first call fails.
              try {
                target[name](...args, makeCallback({
                  resolve,
                  reject
                }, metadata));
              } catch (cbError) {
                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + "falling back to call it without a callback: ", cbError);
                target[name](...args); // Update the API method metadata, so that the next API calls will not try to
                // use the unsupported callback anymore.

                metadata.fallbackToNoCallback = false;
                metadata.noCallback = true;
                resolve();
              }
            } else if (metadata.noCallback) {
              target[name](...args);
              resolve();
            } else {
              target[name](...args, makeCallback({
                resolve,
                reject
              }, metadata));
            }
          });
        };
      };
      /**
       * Wraps an existing method of the target object, so that calls to it are
       * intercepted by the given wrapper function. The wrapper function receives,
       * as its first argument, the original `target` object, followed by each of
       * the arguments passed to the original method.
       *
       * @param {object} target
       *        The original target object that the wrapped method belongs to.
       * @param {function} method
       *        The method being wrapped. This is used as the target of the Proxy
       *        object which is created to wrap the method.
       * @param {function} wrapper
       *        The wrapper function which is called in place of a direct invocation
       *        of the wrapped method.
       *
       * @returns {Proxy<function>}
       *        A Proxy object for the given method, which invokes the given wrapper
       *        method in its place.
       */


      const wrapMethod = (target, method, wrapper) => {
        return new Proxy(method, {
          apply(targetMethod, thisObj, args) {
            return wrapper.call(thisObj, target, ...args);
          }

        });
      };

      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
      /**
       * Wraps an object in a Proxy which intercepts and wraps certain methods
       * based on the given `wrappers` and `metadata` objects.
       *
       * @param {object} target
       *        The target object to wrap.
       *
       * @param {object} [wrappers = {}]
       *        An object tree containing wrapper functions for special cases. Any
       *        function present in this object tree is called in place of the
       *        method in the same location in the `target` object tree. These
       *        wrapper methods are invoked as described in {@see wrapMethod}.
       *
       * @param {object} [metadata = {}]
       *        An object tree containing metadata used to automatically generate
       *        Promise-based wrapper functions for asynchronous. Any function in
       *        the `target` object tree which has a corresponding metadata object
       *        in the same location in the `metadata` tree is replaced with an
       *        automatically-generated wrapper function, as described in
       *        {@see wrapAsyncFunction}
       *
       * @returns {Proxy<object>}
       */

      const wrapObject = (target, wrappers = {}, metadata = {}) => {
        let cache = Object.create(null);
        let handlers = {
          has(proxyTarget, prop) {
            return prop in target || prop in cache;
          },

          get(proxyTarget, prop, receiver) {
            if (prop in cache) {
              return cache[prop];
            }

            if (!(prop in target)) {
              return undefined;
            }

            let value = target[prop];

            if (typeof value === "function") {
              // This is a method on the underlying object. Check if we need to do
              // any wrapping.
              if (typeof wrappers[prop] === "function") {
                // We have a special-case wrapper for this method.
                value = wrapMethod(target, target[prop], wrappers[prop]);
              } else if (hasOwnProperty(metadata, prop)) {
                // This is an async method that we have metadata for. Create a
                // Promise wrapper for it.
                let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                value = wrapMethod(target, target[prop], wrapper);
              } else {
                // This is a method that we don't know or care about. Return the
                // original method, bound to the underlying object.
                value = value.bind(target);
              }
            } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
              // This is an object that we need to do some wrapping for the children
              // of. Create a sub-object wrapper for it with the appropriate child
              // metadata.
              value = wrapObject(value, wrappers[prop], metadata[prop]);
            } else if (hasOwnProperty(metadata, "*")) {
              // Wrap all properties in * namespace.
              value = wrapObject(value, wrappers[prop], metadata["*"]);
            } else {
              // We don't need to do any wrapping for this property,
              // so just forward all access to the underlying object.
              Object.defineProperty(cache, prop, {
                configurable: true,
                enumerable: true,

                get() {
                  return target[prop];
                },

                set(value) {
                  target[prop] = value;
                }

              });
              return value;
            }

            cache[prop] = value;
            return value;
          },

          set(proxyTarget, prop, value, receiver) {
            if (prop in cache) {
              cache[prop] = value;
            } else {
              target[prop] = value;
            }

            return true;
          },

          defineProperty(proxyTarget, prop, desc) {
            return Reflect.defineProperty(cache, prop, desc);
          },

          deleteProperty(proxyTarget, prop) {
            return Reflect.deleteProperty(cache, prop);
          }

        }; // Per contract of the Proxy API, the "get" proxy handler must return the
        // original value of the target if that value is declared read-only and
        // non-configurable. For this reason, we create an object with the
        // prototype set to `target` instead of using `target` directly.
        // Otherwise we cannot return a custom object for APIs that
        // are declared read-only and non-configurable, such as `chrome.devtools`.
        //
        // The proxy handlers themselves will still use the original `target`
        // instead of the `proxyTarget`, so that the methods and properties are
        // dereferenced via the original targets.

        let proxyTarget = Object.create(target);
        return new Proxy(proxyTarget, handlers);
      };
      /**
       * Creates a set of wrapper functions for an event object, which handles
       * wrapping of listener functions that those messages are passed.
       *
       * A single wrapper is created for each listener function, and stored in a
       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`
       * retrieve the original wrapper, so that  attempts to remove a
       * previously-added listener work as expected.
       *
       * @param {DefaultWeakMap<function, function>} wrapperMap
       *        A DefaultWeakMap object which will create the appropriate wrapper
       *        for a given listener function when one does not exist, and retrieve
       *        an existing one when it does.
       *
       * @returns {object}
       */


      const wrapEvent = wrapperMap => ({
        addListener(target, listener, ...args) {
          target.addListener(wrapperMap.get(listener), ...args);
        },

        hasListener(target, listener) {
          return target.hasListener(wrapperMap.get(listener));
        },

        removeListener(target, listener) {
          target.removeListener(wrapperMap.get(listener));
        }

      });

      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps an onRequestFinished listener function so that it will return a
         * `getContent()` property which returns a `Promise` rather than using a
         * callback API.
         *
         * @param {object} req
         *        The HAR entry object representing the network request.
         */


        return function onRequestFinished(req) {
          const wrappedReq = wrapObject(req, {}
          /* wrappers */
          , {
            getContent: {
              minArgs: 0,
              maxArgs: 0
            }
          });
          listener(wrappedReq);
        };
      });
      const onMessageWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps a message listener function so that it may send responses based on
         * its return value, rather than by returning a sentinel value and calling a
         * callback. If the listener function returns a Promise, the response is
         * sent when the promise either resolves or rejects.
         *
         * @param {*} message
         *        The message sent by the other end of the channel.
         * @param {object} sender
         *        Details about the sender of the message.
         * @param {function(*)} sendResponse
         *        A callback which, when called with an arbitrary argument, sends
         *        that value as a response.
         * @returns {boolean}
         *        True if the wrapped listener returned a Promise, which will later
         *        yield a response. False otherwise.
         */


        return function onMessage(message, sender, sendResponse) {
          let didCallSendResponse = false;
          let wrappedSendResponse;
          let sendResponsePromise = new Promise(resolve => {
            wrappedSendResponse = function (response) {
              didCallSendResponse = true;
              resolve(response);
            };
          });
          let result;

          try {
            result = listener(message, sender, wrappedSendResponse);
          } catch (err) {
            result = Promise.reject(err);
          }

          const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called
          // wrappedSendResponse synchronously, we can exit earlier
          // because there will be no response sent from this listener.

          if (result !== true && !isResultThenable && !didCallSendResponse) {
            return false;
          } // A small helper to send the message if the promise resolves
          // and an error if the promise rejects (a wrapped sendMessage has
          // to translate the message into a resolved promise or a rejected
          // promise).


          const sendPromisedResult = promise => {
            promise.then(msg => {
              // send the message value.
              sendResponse(msg);
            }, error => {
              // Send a JSON representation of the error if the rejected value
              // is an instance of error, or the object itself otherwise.
              let message;

              if (error && (error instanceof Error || typeof error.message === "string")) {
                message = error.message;
              } else {
                message = "An unexpected error occurred";
              }

              sendResponse({
                __mozWebExtensionPolyfillReject__: true,
                message
              });
            }).catch(err => {
              // Print an error on the console if unable to send the response.
              console.error("Failed to send onMessage rejected reply", err);
            });
          }; // If the listener returned a Promise, send the resolved value as a
          // result, otherwise wait the promise related to the wrappedSendResponse
          // callback to resolve and send it as a response.


          if (isResultThenable) {
            sendPromisedResult(result);
          } else {
            sendPromisedResult(sendResponsePromise);
          } // Let Chrome know that the listener is replying.


          return true;
        };
      });

      const wrappedSendMessageCallback = ({
        reject,
        resolve
      }, reply) => {
        if (extensionAPIs.runtime.lastError) {
          // Detect when none of the listeners replied to the sendMessage call and resolve
          // the promise to undefined as in Firefox.
          // See https://github.com/mozilla/webextension-polyfill/issues/130
          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
            resolve();
          } else {
            reject(new Error(extensionAPIs.runtime.lastError.message));
          }
        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
          // Convert back the JSON representation of the error into
          // an Error instance.
          reject(new Error(reply.message));
        } else {
          resolve(reply);
        }
      };

      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
        if (args.length < metadata.minArgs) {
          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
        }

        if (args.length > metadata.maxArgs) {
          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
        }

        return new Promise((resolve, reject) => {
          const wrappedCb = wrappedSendMessageCallback.bind(null, {
            resolve,
            reject
          });
          args.push(wrappedCb);
          apiNamespaceObj.sendMessage(...args);
        });
      };

      const staticWrappers = {
        devtools: {
          network: {
            onRequestFinished: wrapEvent(onRequestFinishedWrappers)
          }
        },
        runtime: {
          onMessage: wrapEvent(onMessageWrappers),
          onMessageExternal: wrapEvent(onMessageWrappers),
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 1,
            maxArgs: 3
          })
        },
        tabs: {
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 2,
            maxArgs: 3
          })
        }
      };
      const settingMetadata = {
        clear: {
          minArgs: 1,
          maxArgs: 1
        },
        get: {
          minArgs: 1,
          maxArgs: 1
        },
        set: {
          minArgs: 1,
          maxArgs: 1
        }
      };
      apiMetadata.privacy = {
        network: {
          "*": settingMetadata
        },
        services: {
          "*": settingMetadata
        },
        websites: {
          "*": settingMetadata
        }
      };
      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
    }; // The build process adds a UMD wrapper around this file, which makes the
    // `module` variable available.


    module.exports = wrapAPIs(chrome);
  } else {
    module.exports = globalThis.browser;
  }
});


/***/ }),

/***/ 42480:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 32380:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "x0": () => (/* binding */ nanoid)
/* harmony export */ });
/* unused harmony exports customAlphabet, customRandom, random */

let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
let customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  let step = -~((1.6 * mask * defaultSize) / alphabet.length)
  return (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      let j = step
      while (j--) {
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let customAlphabet = (alphabet, size = 21) =>
  customRandom(alphabet, size, random)
let nanoid = (size = 21) =>
  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    byte &= 63
    if (byte < 36) {
      id += byte.toString(36)
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte > 62) {
      id += '-'
    } else {
      id += '_'
    }
    return id
  }, '')



/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, [645], () => (__webpack_exec__(16267)));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);